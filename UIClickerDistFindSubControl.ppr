{
    Copyright (C) 2025 VCC
    creation date: 17 Mar 2024
    initial release date: 19 May 2024

    author: VCC
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}


library UIClickerDistFindSubControl;

{$H+}
{$IFDEF FPC}
  {$MODE Delphi}
{$ENDIF}

uses
  //Windows,
  Interfaces, Classes, SysUtils, Graphics, ExtCtrls, Forms, Math, IdTCPClient,
  DistFindSubControlDM, ImgList, TplZlibUnit, TplLzmaUnit, IntegerList,
  IdGlobal, ClickerUtils, ClickerExtraUtils, ClickerActionPlugins, DllUtils,
  ClickerFileProviderUtils, DynArrays, PollingFIFO, InMemFileSystem,
  DistFindSubControlCommonConsts, ClickerIniFiles, ClickerActionProperties,

  ClickerTemplates, MQTTClient, MQTTUtils, MQTTConnectCtrl, MQTTSubscribeCtrl,
  MQTTUnsubscribeCtrl, MemArchive, DistFindSubControlPluginProperties,
  ClickerPluginInMemFileSystem;

type
  //TStringArr = array of string;

  TArrayOfString = array[0..0] of string;
  PArrayOfString = ^TArrayOfString;
  TArrayOfEnumStrings = array[0..0] of PArrayOfString;
  PArrayOfEnumStrings = ^TArrayOfEnumStrings;


  TDbgPoint = function(APointName, ALogMsg: string): Boolean;

  TResponseVars = record
    ControlLeft, ControlTop, ControlRight, ControlBottom: string;
    ControlWidth, ControlHeight, HalfControlWidth, HalfControlHeight: string;
    SubCnvXOffset, SubCnvYOffset: string;

    AllControl_Handles, AllControl_XOffsets, AllControl_YOffsets: string;
    AllControl_MatchSource, AllControl_DetailedMatchSource, AllControl_ResultedErrorCount: string;
    AllControl_Lefts, AllControl_Tops, AllControl_Rights, AllControl_Bottoms: string;
    AllControl_Widths, AllControl_Heights, AllHalfControl_Widths, AllHalfControl_Heights: string;
  end;

  TWorker = record
    Name: string; //Maybe a unique part of the ClientID (or full ID if required), as assigned by broker. This name will also be used when requesting the execution of FindSubControl by the plugin.
    OS: string; // Win/Lin
    WorkerSpecificTask: string; //This field is set by plugin when preparing FindSubControl requests. Every worker receives instructions about what part of a FindSubControl action should work on (not the entire action).
    FileCacheInfo: TStringList; //list of files and their hashes, currently present in worker's InMemFS (not its pair UIClicker).
    ExtraName: string; //user-defined name
    FilesToSend: string; // CRLF separated list of filenames (bmps, pmtvs etc)
    ArchiveStream: TMemoryStream;
    Archive: TMemArchive;
    CompressionTime: QWord;   //for statistics only
    WorkerActionContentStr: string; //What is being sent via MQTT to a worker. This field contains action params, ArchiveStream and various other compression params.
    TxtCntW, BmpCntW, PmtvCntW: Integer; //counts per worker
    ResponseReceived: Boolean;    //Most dest UIClicker will timeout, because they won't find the search bmp. At least one should find.
    FindSubControlFound: Boolean; //At least one worker should have this property set to True, to pass the action.
    Response: string;
    ResponseVars: TResponseVars;
    ResponseBitmapStream: TMemoryStream;
    Fonts: string;
  end;

  TWorkerArr = array of TWorker;

  TMQTTReceiveThread = class(TThread)
  private
    FDone: Boolean;
    procedure AddMsgToLog(s: string);
  protected
    procedure Execute; override;
  end;


  TFSM = (SInit, SConnectToBroker, SWaitForConAck,
          SSubscribeToResponses, SWaitForResponsesSubAck,   //Responses can be capabilities, lists of missing files, processing results
          SRequestCapabilities, SWaitForCapabilitiesResponse,
          SGetFindSubControlActionContent,
          SPublishBackgroundImageToAllWorkers, SWaitForBackgroundImageResults,
          SPublishFindSubControlToAllWorkers, SWaitForFindSubControlResults,  //in addition to FindSubControl action details, the publish contains a list of assigned work info for every worker, so they know what exactly to work on
          SGetListOfFonts, SWaitForListOfFonts,
          SUpdateCache, SLoadCache,
          SDisconnectFromBroker,
          SDone
         );

  TPluginMQTTClientHandlers = class(TComponent)
  private
    tmrProcessRecData: TTimer;

    procedure tmrProcessRecDataTimer(Sender: TObject);

    procedure HandleClientOnConnected(Sender: TObject);
    procedure HandleClientOnDisconnected(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
  end;

  TExHandler = class
    procedure CustomExceptionHandler(Sender: TObject; E: Exception);
  end;


const
  CFSMStr: array[TFSM] of string = (
          'SInit', 'SConnectToBroker', 'SWaitForConAck',
          'SSubscribeToResponses', 'SWaitForResponsesSubAck',
          'SRequestCapabilities', 'SWaitForCapabilitiesResponse',
          'SGetFindSubControlActionContent',
          'SPublishBackgroundImageToAllWorkers', 'SWaitForBackgroundImageResults',
          'SPublishFindSubControlToAllWorkers', 'SWaitForFindSubControlResults',
          'SGetListOfFonts', 'SWaitForListOfFonts',
          'SUpdateCache', 'SLoadCache',
          'SDisconnectFromBroker',
          'SDone'
          );

var
  IdTCPClient1: TIdTCPClient;
  FRecBufFIFO: TPollingFIFO; //used by the reading thread to pass data to MQTT library
  DebugPoint: TDbgPoint;
  AtLeastOneWorkerFoundTheSubControl: Boolean;
  WorkerRespondedCount: Word;
  FLatestMsg: string = '';
  ConnectedSucessfully, ConAckReceived, SubAckReceived, SubscribedSucessfully, DisconnectedSuccessfully: Boolean;
  WaitingForWorkerCapabilities: Boolean;
  WaitingForWorkerFonts: Boolean;
  FSMDone: Boolean;
  AllWorkers: TWorkerArr;
  AllWorkerBackgroundBmpStr: string;

  BkArchiveStream: TMemoryStream;
  BkArchive: TMemArchive;
  BkCompressionTime: QWord;   //for statistics only

  AddToLogCallback: TOnActionPlugin_AddToLog;
  ActionPlugin_InMemFSCallback: TOnActionPlugin_InMemFS;
  ActionPlugin_ExecuteActionallback: TOnActionPlugin_ExecuteAction;
  GPluginReference: Pointer;

  FindSubControlActionPropertyValue: string;
  CredentialsFullFileNamePropertyValue: string;  //for connection to broker
  AddressPropertyValue: string;
  PortPropertyValue: string;
  VarsForWorkers_Names, VarsForWorkers_Values, VarsForWorkers_EvalBefore: string;
  UpdateCacheActionName, LoadCacheActionName: string;

  GetAllControls: Boolean;
  WorkerQoS: Integer;
  GetWorkerCapabilitiesTimeout: Integer;
  FindSubControlWorkerTimeout: Integer;
  FSMError: string;
  FindSubControlTimeoutDiff: Integer;
  WorkerCapabilitiesSource: string; //set by property at CWorkerCapabilitiesSourcePropertyIndex
  RequestedTextRenderingOS: string;

  RecTh: TMQTTReceiveThread;

  State, NextState: TFSM;
  tk: QWord; //used for timeouts

  FExHandler: TExHandler;


procedure AddToLog(AMsg: string);  //thread safe
begin
  if @AddToLogCallback <> nil then
    AddToLogCallback(DefaultPluginReference, @AMsg[1]);
end;

//
//function DbgPoint(APointName, ALogMsg: string): Boolean;
//begin
//  if @DefaultOnActionPlugin_DebugPoint <> nil then
//    Result := DefaultOnActionPlugin_DebugPoint(DefaultPluginReference, @APointName[1], @ALogMsg[1])
//  else
//    Result := True;
//end;


procedure GetCredentials(ACredentialsFilePath: string; out AUsername, APassword: string);
var
  Ini: TClkIniReadonlyFile;
begin
  Ini := TClkIniReadonlyFile.Create(ACredentialsFilePath);
  try
    AUsername := Ini.ReadString('Credentials', 'Username', '');
    APassword := Ini.ReadString('Credentials', 'Password', '');
  finally
    Ini.Free;
  end;
end;


procedure GetCredentialsFromInMemFS(ACredentialsFilePath: string; APluginReference: Pointer; AOnActionPlugin_InMemFS: TOnActionPlugin_InMemFS; out AUsername, APassword: string);
var
  Ini: TClkIniReadonlyFile;
  PluginInMemFS: TPluginInMemFileSystem;
  Content: TMemoryStream;
begin
  AddToLog('Loading credentials file from ' + ACredentialsFilePath);

  PluginInMemFS := TPluginInMemFileSystem.Create;
  try
    Content := TMemoryStream.Create;
    try
      PluginInMemFS.PluginReference := APluginReference;
      if PluginInMemFS.FileExistsInMem(AOnActionPlugin_InMemFS, ACredentialsFilePath) then
      begin
        Content.SetSize(PluginInMemFS.GetFileSize(AOnActionPlugin_InMemFS, ACredentialsFilePath));
        PluginInMemFS.LoadFileFromMem(AOnActionPlugin_InMemFS, ACredentialsFilePath, Content.Memory);

        Ini := TClkIniReadonlyFile.Create(Content);
        try
          AUsername := Ini.ReadString('Credentials', 'Username', '');
          APassword := Ini.ReadString('Credentials', 'Password', '');

          AddToLog('Username: ' + AUsername + '  Password: ' + APassword);
        finally
          Ini.Free;
        end;
      end
      else
      begin
        AUsername := 'not found';
        APassword := 'not found';
      end;
    finally
      Content.Free;
    end;
  finally
    PluginInMemFS.Free
  end;
end;


procedure SyncReceivedBuffer(var AReadBuf: TDynArrayOfByte); //thread safe
begin
  FRecBufFIFO.Put(DynArrayOfByteToString(AReadBuf));
end;


procedure ProcessReceivedBuffer;  //called by a timer, to process received data
var
  TempReadBuf: TDynArrayOfByte;
  NewData: string;
begin
  if FRecBufFIFO.Pop(NewData) then
  begin
    InitDynArrayToEmpty(TempReadBuf);
    try
      if StringToDynArrayOfByte(NewData, TempReadBuf) then
      begin
        MQTT_PutReceivedBufferToMQTTLib(0, TempReadBuf);
        MQTT_Process(0);
      end
      else
        AddToLog('Out of memory in ProcessReceivedBuffer.');
    finally
      FreeDynArray(TempReadBuf);
    end;
  end;
end;


procedure SendDynArrayOfByte(AArr: TDynArrayOfByte);
var
  TempArr: TIdBytes;
begin
  //AddToLog('============Sending: ' + StringReplace(DynArrayOfByteToString(AArr), #0, #1, [rfReplaceAll]));
  SetLength(TempArr, AArr.Len);
  Move(AArr.Content^, TempArr[0], AArr.Len);
  IdTCPClient1.IOHandler.Write(TempArr);
end;


procedure SendPacketToServer(ClientInstance: DWord);
var
  BufferPointer: PMQTTBuffer;
  Err: Word;
begin
  BufferPointer := MQTT_GetClientToServerBuffer(ClientInstance, Err){$IFnDEF SingleOutputBuffer}^.Content^[0]{$ENDIF};
  SendDynArrayOfByte(BufferPointer^);

  {$IFnDEF SingleOutputBuffer}
    if not MQTT_RemovePacketFromClientToServerBuffer(ClientInstance) then
      AddToLog('Can''t remove latest packet from send buffer.');
  {$ELSE}
    raise Exception.Create('MQTT_RemovePacketFromClientToServerBuffer no implemented for SingleOutputBuffer.');
  {$ENDIF}
end;


procedure HandleOnMQTTError(ClientInstance: DWord; AErr: Word; APacketType: Byte);
var
  PacketTypeStr: string;
begin
  MQTTPacketToString(APacketType, PacketTypeStr);
  AddToLog('Client: ' + IntToHex(ClientInstance, 8) + '  Err: $' + IntToHex(AErr) + '  PacketType: $' + IntToHex(APacketType) + ' (' + PacketTypeStr + ').');  //The error is made of an upper byte and a lower byte.

  if Hi(AErr) = CMQTT_Reason_NotAuthorized then   // $87
  begin
    FLatestMsg := 'MQTT broker error: Not authorized.';
    AddToLog(FLatestMsg);
    if APacketType = CMQTT_CONNACK then
      AddToLog('             on receiving CONNACK.');
  end;

  if Lo(AErr) = CMQTT_PacketIdentifierNotFound_ClientToServer then   // $CE
    AddToLog('Client error: PacketIdentifierNotFound.');
end;


procedure HandleOnSend_MQTT_Packet(ClientInstance: DWord; APacketType: Byte);
var
  PacketName: string;
begin
  MQTTPacketToString(APacketType, PacketName);
  AddToLog('Sending ' + PacketName + ' packet...');

  try
    SendPacketToServer(ClientInstance);
  except
    on E: Exception do
      AddToLog('Cannot send ' + PacketName + ' packet... Ex: ' + E.Message);
  end;
end;


function HandleOnBeforeMQTT_CONNECT(ClientInstance: DWord;  //The lower byte identifies the client instance (the library is able to implement multiple MQTT clients / device). The higher byte can identify the call in user handlers for various events (e.g. TOnBeforeMQTT_CONNECT).
                                    var AConnectFields: TMQTTConnectFields;                    //user code has to fill-in this parameter
                                    var AConnectProperties: TMQTTConnectProperties;
                                    ACallbackID: Word): Boolean;
var
  TempWillProperties: TMQTTWillProperties;
  UserName, Password: string;
  //ClientId: string;
  //Id: Char;
  ConnectFlags: Byte;
  EnabledProperties: Word;
begin
  Result := True;

  AddToLog('Preparing CONNECT data..');

  //Id := Chr((ClientInstance and $FF) + 48);
  //ClientId := 'MyClient' + Id;

  if Pos('Mem:\', CredentialsFullFileNamePropertyValue) = 1 then
    GetCredentialsFromInMemFS(CredentialsFullFileNamePropertyValue, GPluginReference, ActionPlugin_InMemFSCallback, UserName, Password)
  else
    GetCredentials(CredentialsFullFileNamePropertyValue, UserName, Password);

  //StringToDynArrayOfByte(ClientId, AConnectFields.PayloadContent.ClientID);
  StringToDynArrayOfByte(UserName, AConnectFields.PayloadContent.UserName);
  StringToDynArrayOfByte(Password, AConnectFields.PayloadContent.Password);

  ConnectFlags := CMQTT_UsernameInConnectFlagsBitMask or
                  CMQTT_PasswordInConnectFlagsBitMask or
                  CMQTT_CleanStartInConnectFlagsBitMask {or
                  CMQTT_WillQoSB1InConnectFlagsBitMask};

  EnabledProperties := CMQTTConnect_EnSessionExpiryInterval or
                       CMQTTConnect_EnMaximumPacketSize or
                       CMQTTConnect_EnRequestResponseInformation or
                       CMQTTConnect_EnRequestProblemInformation {or
                       CMQTTConnect_EnAuthenticationMethod or
                       CMQTTConnect_EnAuthenticationData};

  MQTT_InitWillProperties(TempWillProperties);
  TempWillProperties.WillDelayInterval := 30; //some value
  TempWillProperties.PayloadFormatIndicator := 1;  //0 = do not send.  1 = UTF-8 string
  TempWillProperties.MessageExpiryInterval := 3600;
  StringToDynArrayOfByte('SomeType', TempWillProperties.ContentType);
  StringToDynArrayOfByte('SomeTopicName', TempWillProperties.ResponseTopic);
  StringToDynArrayOfByte('MyCorrelationData', TempWillProperties.CorrelationData);
  AddStringToDynOfDynArrayOfByte('Key=Value', TempWillProperties.UserProperty);
  AddStringToDynOfDynArrayOfByte('NewKey=NewValue', TempWillProperties.UserProperty);

  FillIn_PayloadWillProperties(TempWillProperties, AConnectFields.PayloadContent.WillProperties);
  MQTT_FreeWillProperties(TempWillProperties);
  StringToDynArrayOfByte('WillTopic', AConnectFields.PayloadContent.WillTopic);

  //Please set the Will Flag in ConnectFlags below, then uncomment above code, if "Will" properties are required.
  AConnectFields.ConnectFlags := ConnectFlags;  //bits 7-0:  User Name, Password, Will Retain, Will QoS, Will Flag, Clean Start, Reserved
  AConnectFields.EnabledProperties := EnabledProperties;
  AConnectFields.KeepAlive := 0; //any positive values require pinging the server if no other packet is being sent

  AConnectProperties.SessionExpiryInterval := 3600; //[s]
  AConnectProperties.ReceiveMaximum := 7000;
  AConnectProperties.MaximumPacketSize := 10 * 1024 * 1024;
  AConnectProperties.TopicAliasMaximum := 100;
  AConnectProperties.RequestResponseInformation := 1;
  AConnectProperties.RequestProblemInformation := 1;
  AddStringToDynOfDynArrayOfByte('UserProp=Value', AConnectProperties.UserProperty);
  StringToDynArrayOfByte('SCRAM-SHA-1', AConnectProperties.AuthenticationMethod);       //some example from spec, pag 108   the server may add to its log: "bad AUTH method"
  StringToDynArrayOfByte('client-first-data', AConnectProperties.AuthenticationData);   //some example from spec, pag 108

  AddToLog('Done preparing CONNECT data..');
  AddToLog('');
end;


procedure HandleOnAfterMQTT_CONNACK(ClientInstance: DWord; var AConnAckFields: TMQTTConnAckFields; var AConnAckProperties: TMQTTConnAckProperties);
begin
  ConAckReceived := True;
  AddToLog('Received CONNACK');

  //AddToLog('ConnAckFields.EnabledProperties: ' + IntToStr(AConnAckFields.EnabledProperties));
  //AddToLog('ConnAckFields.SessionPresentFlag: ' + IntToStr(AConnAckFields.SessionPresentFlag));
  //AddToLog('ConnAckFields.ConnectReasonCode: ' + IntToStr(AConnAckFields.ConnectReasonCode));  //should be 0
  //
  //AddToLog('SessionExpiryInterval: ' + IntToStr(AConnAckProperties.SessionExpiryInterval));
  //AddToLog('ReceiveMaximum: ' + IntToStr(AConnAckProperties.ReceiveMaximum));
  //AddToLog('MaximumQoS: ' + IntToStr(AConnAckProperties.MaximumQoS));
  //AddToLog('RetainAvailable: ' + IntToStr(AConnAckProperties.RetainAvailable));

  if AConnAckFields.EnabledProperties and CMQTTConnAck_EnMaximumPacketSize = CMQTTConnAck_EnMaximumPacketSize then
    AddToLog('MaximumPacketSize received: ' + IntToStr(AConnAckProperties.MaximumPacketSize))
  else
    AddToLog('MaximumPacketSize unknown: ' + IntToStr(AConnAckProperties.MaximumPacketSize));


  //AddToLog('AssignedClientIdentifier: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.AssignedClientIdentifier), #0, '#0', [rfReplaceAll]));
  //AddToLog('TopicAliasMaximum: ' + IntToStr(AConnAckProperties.TopicAliasMaximum));
  //AddToLog('ReasonString: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.ReasonString), #0, '#0', [rfReplaceAll]));
  //AddToLog('UserProperty: ' + StringReplace(DynOfDynArrayOfByteToString(AConnAckProperties.UserProperty), #0, '#0', [rfReplaceAll]));
  //AddToLog('WildcardSubscriptionAvailable: ' + IntToStr(AConnAckProperties.WildcardSubscriptionAvailable));
  //AddToLog('SubscriptionIdentifierAvailable: ' + IntToStr(AConnAckProperties.SubscriptionIdentifierAvailable));
  //AddToLog('SharedSubscriptionAvailable: ' + IntToStr(AConnAckProperties.SharedSubscriptionAvailable));
  //AddToLog('ServerKeepAlive: ' + IntToStr(AConnAckProperties.ServerKeepAlive));
  //AddToLog('ResponseInformation: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.ResponseInformation), #0, '#0', [rfReplaceAll]));
  //AddToLog('ServerReference: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.ServerReference), #0, '#0', [rfReplaceAll]));
  //AddToLog('AuthenticationMethod: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.AuthenticationMethod), #0, '#0', [rfReplaceAll]));
  //AddToLog('AuthenticationData: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.AuthenticationData), #0, '#0', [rfReplaceAll]));
  //

  ///////////////////////////////////////// when the server returns SessionPresentFlag set to 1, the library resends unacknowledged Publish and PubRel packets.
  //AConnAckFields.SessionPresentFlag := 1;
end;


function HandleOnBeforeSendingMQTT_SUBSCRIBE(ClientInstance: DWord;  //The lower word identifies the client instance
                                             var ASubscribeFields: TMQTTSubscribeFields;
                                             var ASubscribeProperties: TMQTTSubscribeProperties;
                                             ACallbackID: Word): Boolean;
var
  Options, QoS: Byte;
  SubId: Word;
begin
  Options := 0;
  QoS := 2;

  Options := Options or QoS; //bits 1 and 0
  //Bit 2 of the Subscription Options represents the No Local option.  - spec pag 73
  //Bit 3 of the Subscription Options represents the Retain As Published option.  - spec pag 73
  //Bits 4 and 5 of the Subscription Options represent the Retain Handling option.  - spec pag 73
  //Bits 6 and 7 of the Subscription Options byte are reserved for future use. - Must be set to 0.  - spec pag 73

                                                                            //Subscription identifiers are not mandatory (per spec).
  SubId := MQTT_CreateClientToServerSubscriptionIdentifier(ClientInstance); //This function has to be called here, in this handler only. The library does not call this function other than for init purposes.
                                                                            //If SubscriptionIdentifiers are used, then user code should free them when resubscribing or when unsubscribing.
  ASubscribeProperties.SubscriptionIdentifier := SubId;  //For now, the user code should keep track of these identifiers and free them on resubscribing or unsubscribing.
  AddToLog('Subscribing with new SubscriptionIdentifier: ' + IntToStr(SubId));

  Result := FillIn_SubscribePayload(CTopicName_WorkerToApp_GetCapabilities, Options, ASubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to ASubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_SUBSCRIBE not enough memory to add TopicFilters (GetCapabilities).');
    Exit;
  end;

  AddToLog('Subscribing to: ' + StringReplace(DynArrayOfByteToString(ASubscribeFields.TopicFilters), #0, '#0', [rfReplaceAll]));

  Result := FillIn_SubscribePayload(CTopicName_WorkerToApp_SendBackground, Options, ASubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to ASubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_SUBSCRIBE not enough memory to add TopicFilters (SendBackground).');
    Exit;
  end;

  Result := FillIn_SubscribePayload(CTopicName_WorkerToApp_FindSubControl, Options, ASubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to ASubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_SUBSCRIBE not enough memory to add TopicFilters (FindSubControl).');
    Exit;
  end;

  Result := FillIn_SubscribePayload(CTopicName_WorkerToApp_GetListOfFonts, Options, ASubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to ASubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_SUBSCRIBE not enough memory to add TopicFilters (GetListOfFonts).');
    Exit;
  end;


  //Enable SubscriptionIdentifier only if required (allocated above with CreateClientToServerSubscriptionIdentifier) !!!
  //The library initializes EnabledProperties to 0.
  //A subscription is allowed to be made without a SubscriptionIdentifier.
  ASubscribeFields.EnabledProperties := CMQTTSubscribe_EnSubscriptionIdentifier {or CMQTTSubscribe_EnUserProperty};

  AddToLog('Subscribing with PacketIdentifier: ' + IntToStr(ASubscribeFields.PacketIdentifier));
  AddToLog('Subscribing to: ' + StringReplace(DynArrayOfByteToString(ASubscribeFields.TopicFilters), #0, '#0', [rfReplaceAll]));

  AddToLog('');
end;


procedure HandleOnAfterReceivingMQTT_SUBACK(ClientInstance: DWord; var ASubAckFields: TMQTTSubAckFields; var ASubAckProperties: TMQTTSubAckProperties);
var
  i: Integer;
begin
  AddToLog('Received SUBACK');
  SubAckReceived := True;
  //AddToLog('ASubAckFields.IncludeReasonCode: ' + IntToStr(ASubAckFields.IncludeReasonCode));  //not used
  //AddToLog('ASubAckFields.ReasonCode: ' + IntToStr(ASubAckFields.ReasonCode));              //not used
  AddToLog('ASubAckFields.EnabledProperties: ' + IntToStr(ASubAckFields.EnabledProperties));
  AddToLog('ASubAckFields.PacketIdentifier: ' + IntToStr(ASubAckFields.PacketIdentifier));  //This must be the same as sent in SUBSCRIBE packet.

  AddToLog('ASubAckFields.Payload.Len: ' + IntToStr(ASubAckFields.SrcPayload.Len));

  for i := 0 to ASubAckFields.SrcPayload.Len - 1 do         //these are QoS values for each TopicFilter (if ok), or error codes (if not ok).
    AddToLog('ASubAckFields.ReasonCodes[' + IntToStr(i) + ']: ' + IntToStr(ASubAckFields.SrcPayload.Content^[i]));

  AddToLog('ASubAckProperties.ReasonString: ' + StringReplace(DynArrayOfByteToString(ASubAckProperties.ReasonString), #0, '#0', [rfReplaceAll]));
  AddToLog('ASubAckProperties.UserProperty: ' + StringReplace(DynOfDynArrayOfByteToString(ASubAckProperties.UserProperty), #0, '#0', [rfReplaceAll]));

  AddToLog('');
end;


function HandleOnBeforeSendingMQTT_UNSUBSCRIBE(ClientInstance: DWord;  //The lower word identifies the client instance
                                               var AUnsubscribeFields: TMQTTUnsubscribeFields;
                                               var AUnsubscribeProperties: TMQTTUnsubscribeProperties;
                                               ACallbackID: Word): Boolean;
begin
  Result := FillIn_UnsubscribePayload(CTopicName_WorkerToApp_GetCapabilities, AUnsubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to AUnsubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_UNSUBSCRIBE not enough memory to add TopicFilters.');
    Exit;
  end;

  Result := FillIn_UnsubscribePayload(CTopicName_WorkerToApp_SendBackground, AUnsubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to AUnsubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_UNSUBSCRIBE not enough memory to add TopicFilters.');
    Exit;
  end;

  Result := FillIn_UnsubscribePayload(CTopicName_WorkerToApp_FindSubControl, AUnsubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to AUnsubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_UNSUBSCRIBE not enough memory to add TopicFilters.');
    Exit;
  end;

  Result := FillIn_UnsubscribePayload(CTopicName_WorkerToApp_GetListOfFonts, AUnsubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to AUnsubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_UNSUBSCRIBE not enough memory to add TopicFilters.');
    Exit;
  end;

  AddToLog('Unsubscribing from "' + CTopicName_WorkerToApp_GetCapabilities + '" and "' +
                                    CTopicName_WorkerToApp_SendBackground + '" and "' +
                                    CTopicName_WorkerToApp_FindSubControl + '" and "' +
                                    CTopicName_WorkerToApp_GetListOfFonts + '"...'
                                    );

  //the user code should call RemoveClientToServerSubscriptionIdentifier to remove the allocate identifier.
end;


procedure HandleOnAfterReceivingMQTT_UNSUBACK(ClientInstance: DWord; var AUnsubAckFields: TMQTTUnsubAckFields; var AUnsubAckProperties: TMQTTUnsubAckProperties);
var
  i: Integer;
begin
  AddToLog('Received UNSUBACK');
  //AddToLog('AUnsubAckFields.IncludeReasonCode: ' + IntToStr(ASubAckFields.IncludeReasonCode));  //not used
  //AddToLog('AUnsubAckFields.ReasonCode: ' + IntToStr(ASubAckFields.ReasonCode));              //not used
  AddToLog('AUnsubAckFields.EnabledProperties: ' + IntToStr(AUnsubAckFields.EnabledProperties));
  AddToLog('AUnsubAckFields.PacketIdentifier: ' + IntToStr(AUnsubAckFields.PacketIdentifier));  //This must be the same as sent in SUBSCRIBE packet.

  AddToLog('AUnsubAckFields.Payload.Len: ' + IntToStr(AUnsubAckFields.SrcPayload.Len));

  for i := 0 to AUnsubAckFields.SrcPayload.Len - 1 do         //these are QoS values for each TopicFilter (if ok), or error codes (if not ok).
    AddToLog('AUnsubAckFields.ReasonCodes[' + IntToStr(i) + ']: ' + IntToStr(AUnsubAckFields.SrcPayload.Content^[i]));

  AddToLog('AUnsubAckProperties.ReasonString: ' + StringReplace(DynArrayOfByteToString(AUnsubAckProperties.ReasonString), #0, '#0', [rfReplaceAll]));
  AddToLog('AUnsubAckProperties.UserProperty: ' + StringReplace(DynOfDynArrayOfByteToString(AUnsubAckProperties.UserProperty), #0, '#0', [rfReplaceAll]));

  AddToLog('');
end;


//This handler is used when this client publishes a message to broker.
function HandleOnBeforeSendingMQTT_PUBLISH(ClientInstance: DWord;  //The lower word identifies the client instance (the library is able to implement multiple MQTT clients / device). The higher byte can identify the call in user handlers for various events (e.g. TOnBeforeMQTT_CONNECT).
                                           var APublishFields: TMQTTPublishFields;                    //user code has to fill-in this parameter
                                           var APublishProperties: TMQTTPublishProperties;            //user code has to fill-in this parameter
                                           ACallbackID: Word): Boolean;
var
  Msg: string;
  //QoS: Byte;
  TempWorkerSpecificTask: string;
  i: Integer;
  CurrentWorkerIndex: Byte;
begin
  Result := True;
  TempWorkerSpecificTask := 'Task not set.';

  case ACallbackID and $FF of
    CCallbackID_GetCapabilities:
    begin
      Msg := CMQTT_AppToWorkerCmd_GetCapabilities;
      TempWorkerSpecificTask := 'DebuggingString';
      Result := Result and StringToDynArrayOfByte(CTopicName_AppToWorker_GetCapabilities, APublishFields.TopicName);
      APublishFields.EnabledProperties := CMQTTPublish_EnContentType;
      AddToLog('Requesting worker capabilities...');
    end;

    CCallbackID_SendBackgroundToAll:
    begin
      Msg := AllWorkerBackgroundBmpStr;
      Result := Result and StringToDynArrayOfByte(CTopicName_AppToWorker_SendBackground, APublishFields.TopicName);

      AddToLog('Publishing SendBackground request to all workers...  Topic: ' + CTopicName_AppToWorker_SendBackground + '   Len(Msg): ' + IntToStr(Length(Msg)));

      //List of tasks for all workers. It can be an '&' separated list of WorkerName=TaskInfo, from all workers array.
      //The list separator has to be compatible with MQTT spec about UTF-8 encoding.
      //Every worker extracts its task from this array, based on its name.

      TempWorkerSpecificTask := 'DebuggingName:';
      APublishFields.EnabledProperties := CMQTTPublish_EnContentType;
    end;

    CCallbackID_SendBackgroundToSome:
    begin
      CurrentWorkerIndex := (ACallbackID shr 8) and $FF;  //assuming there are no more than 255 workers
      Msg := AllWorkerBackgroundBmpStr;
      Result := Result and StringToDynArrayOfByte(CTopicName_AppToWorker_SendBackground + '_' + AllWorkers[CurrentWorkerIndex].Name, APublishFields.TopicName);

      AddToLog('Publishing SendBackground request to worker[' + IntToStr(CurrentWorkerIndex) + ']...');

      //List of tasks for all workers. It can be an '&' separated list of WorkerName=TaskInfo, from all workers array.
      //The list separator has to be compatible with MQTT spec about UTF-8 encoding.
      //Every worker extracts its task from this array, based on its name.

      TempWorkerSpecificTask := 'DebuggingName:';
      APublishFields.EnabledProperties := CMQTTPublish_EnContentType;
    end;

    CCallbackID_SendFindSubControl:
    begin
      CurrentWorkerIndex := (ACallbackID shr 8) and $FF;  //assuming there are no more than 255 workers
      Msg := AllWorkers[CurrentWorkerIndex].WorkerActionContentStr;
      Result := Result and StringToDynArrayOfByte(CTopicName_AppToWorker_FindSubControl + '_' + AllWorkers[CurrentWorkerIndex].Name, APublishFields.TopicName);

      AddToLog('Publishing FindSubControl request to worker[' + IntToStr(CurrentWorkerIndex) + ']...');

      //List of tasks for all workers. It can be an '&' separated list of WorkerName=TaskInfo, from all workers array.
      //The list separator has to be compatible with MQTT spec about UTF-8 encoding.
      //Every worker extracts its task from this array, based on its name.

      TempWorkerSpecificTask := 'DebuggingName:';
      for i := 0 to Length(AllWorkers) - 1 do
        TempWorkerSpecificTask := TempWorkerSpecificTask + AllWorkers[i].Name + {'='}CWorkerTaskAssignmentOperator + AllWorkers[i].WorkerSpecificTask {+ '&'} + CWorkerTaskLineBreak;

      APublishFields.EnabledProperties := CMQTTPublish_EnContentType;
    end;

    CCallbackID_GetListOfFonts:
    begin
      CurrentWorkerIndex := (ACallbackID shr 8) and $FF;  //assuming there are no more than 255 workers
      Msg := 'none'; //not a requirement so far
      Result := Result and StringToDynArrayOfByte(CTopicName_AppToWorker_GetListOfFonts, APublishFields.TopicName);

      AddToLog('Requesting GetListOfFonts from worker[' + IntToStr(CurrentWorkerIndex) + ']...');
    end;

    else
      Msg := 'UnhandledRequest';
  end;

  //QoS := (APublishFields.PublishCtrlFlags shr 1) and 3;
  //AddToLog('Publishing "' + Msg + '" at QoS = ' + IntToStr(QoS));  //commented, because Msg may contain bitmaps

  Result := Result and StringToDynArrayOfByte(Msg, APublishFields.ApplicationMessage);
  Result := Result and StringToDynArrayOfByte(TempWorkerSpecificTask, APublishProperties.ContentType);


  AddToLog('');
  //QoS can be overriden here. If users override QoS in this handler, then a a different PacketIdentifier might be allocated (depending on what is available)
end;


//This handler is used when this client publishes a message to broker and the broker responds with PUBACK.
procedure HandleOnBeforeSendingMQTT_PUBACK(ClientInstance: DWord; var APubAckFields: TMQTTPubAckFields; var APubAckProperties: TMQTTPubAckProperties);
begin
  AddToLog('Acknowledging with PUBACK');
  AddToLog('APubAckFields.EnabledProperties: ' + IntToStr(APubAckFields.EnabledProperties));
  AddToLog('APubAckFields.IncludeReasonCode: ' + IntToStr(APubAckFields.IncludeReasonCode));
  AddToLog('APubAckFields.PacketIdentifier: ' + IntToStr(APubAckFields.PacketIdentifier));
  AddToLog('APubAckFields.ReasonCode: ' + IntToStr(APubAckFields.ReasonCode));

  AddToLog('APubAckProperties.ReasonString: ' + StringReplace(DynArrayOfByteToString(APubAckProperties.ReasonString), #0, '#0', [rfReplaceAll]));
  AddToLog('APubAckProperties.UserProperty: ' + StringReplace(DynOfDynArrayOfByteToString(APubAckProperties.UserProperty), #0, '#0', [rfReplaceAll]));

  AddToLog('');
  //This handler can be used to override what is being sent to server as a reply to PUBLISH
end;


procedure HandleOnAfterReceivingMQTT_PUBACK(ClientInstance: DWord; var APubAckFields: TMQTTPubAckFields; var APubAckProperties: TMQTTPubAckProperties);
begin
  AddToLog('Received PUBACK');
  //AddToLog('APubAckFields.EnabledProperties: ' + IntToStr(APubAckFields.EnabledProperties));
  //AddToLog('APubAckFields.IncludeReasonCode: ' + IntToStr(APubAckFields.IncludeReasonCode));
  //AddToLog('APubAckFields.PacketIdentifier: ' + IntToStr(APubAckFields.PacketIdentifier));
  //AddToLog('APubAckFields.ReasonCode: ' + IntToStr(APubAckFields.ReasonCode));
  //
  //AddToLog('APubAckProperties.ReasonString: ' + StringReplace(DynArrayOfByteToString(APubAckProperties.ReasonString), #0, '#0', [rfReplaceAll]));
  //AddToLog('APubAckProperties.UserProperty: ' + StringReplace(DynOfDynArrayOfByteToString(APubAckProperties.UserProperty), #0, '#0', [rfReplaceAll]));
  AddToLog('');
end;


function GetAllWorkers_AtLeastOneFound: Boolean;
var
  i: Integer;
begin
  Result := False;
  for i := 0 to Length(AllWorkers) - 1 do
    if AllWorkers[i].ResponseReceived and AllWorkers[i].FindSubControlFound then
    begin
      Result := True;
      Break;
    end;
end;


function GetWorkerIndexByName(AWorkerName: string): Integer;
var
  i: Integer;
begin
  Result := -1;

  for i := 0 to Length(AllWorkers) - 1 do
    if AllWorkers[i].Name = AWorkerName then
    begin
      Result := i;
      Break;
    end;
end;


procedure AddNewWorkerToList(AName, AOS, AFileCacheInfoContent, AExtraName: string);
begin
  SetLength(AllWorkers, Length(AllWorkers) + 1);
  AllWorkers[Length(AllWorkers) - 1].Name := AName;
  AllWorkers[Length(AllWorkers) - 1].OS := AOS;
  AllWorkers[Length(AllWorkers) - 1].WorkerSpecificTask := '';
  AllWorkers[Length(AllWorkers) - 1].FileCacheInfo := TStringList.Create;
  AllWorkers[Length(AllWorkers) - 1].FileCacheInfo.LineBreak := #13#10;
  AllWorkers[Length(AllWorkers) - 1].FileCacheInfo.Text := AFileCacheInfoContent;
  AllWorkers[Length(AllWorkers) - 1].ExtraName := AExtraName;

  AllWorkers[Length(AllWorkers) - 1].FilesToSend := '';
  AllWorkers[Length(AllWorkers) - 1].ArchiveStream := nil;   //created when required
  AllWorkers[Length(AllWorkers) - 1].Archive := nil;         //created when required

  AllWorkers[Length(AllWorkers) - 1].TxtCntW := 0;
  AllWorkers[Length(AllWorkers) - 1].BmpCntW := 0;
  AllWorkers[Length(AllWorkers) - 1].PmtvCntW := 0;

  AllWorkers[Length(AllWorkers) - 1].ResponseReceived := False;
  AllWorkers[Length(AllWorkers) - 1].FindSubControlFound := False;
  AllWorkers[Length(AllWorkers) - 1].Response := 'unset';

  AllWorkers[Length(AllWorkers) - 1].ResponseBitmapStream := TMemoryStream.Create; //created here, destroyed on returning to app

  AllWorkers[Length(AllWorkers) - 1].Fonts := '';
end;


procedure SetWorkerResponseBitmapStream(AWorkerIndex: Integer; AArchiveAsResponseStr, AArchiveSizeStr: string);
var
  ArchiveStream: TMemoryStream;
  Archive: TMemArchive;
  TempArchiveHandlers: TArchiveHandlers;
begin
  AddToLog('Decoded response archive size: ' + IntToStr(Length(AArchiveAsResponseStr)));
  AArchiveAsResponseStr := Copy(AArchiveAsResponseStr, 1, StrToInt64Def(AArchiveSizeStr, Length(AArchiveAsResponseStr)));
  AddToLog('Received response archive size: ' + AArchiveSizeStr);
  AArchiveAsResponseStr := HexToString(AArchiveAsResponseStr);
  AddToLog('Received response raw archive size: ' + IntToStr(Length(AArchiveAsResponseStr)) + '   (* 2 = ' + IntToStr(Length(AArchiveAsResponseStr) shl 1) + ')');

  ArchiveStream := TMemoryStream.Create;
  Archive := TMemArchive.Create;
  TempArchiveHandlers := TArchiveHandlers.Create;
  try
    TempArchiveHandlers.OnAddToLogNoObj := @AddToLog;
    ArchiveStream.Write(AArchiveAsResponseStr[1], Length(AArchiveAsResponseStr));

    //AddToLog('First 10 archive bytes: "' + FastReplace_0To1(Copy(AArchiveAsResponseStr, 1, 10)));
    //AddToLog('Last 10 archive bytes: "' + FastReplace_0To1(Copy(AArchiveAsResponseStr, Length(AArchiveAsResponseStr) - 9, 10)));
    AddToLog('Computing Archive hash.. Size = ' + IntToStr(ArchiveStream.Size));
    try
      AddToLog('Archive hash: ' + ClickerExtraUtils.ComputeHash(ArchiveStream.Memory, ArchiveStream.Size));
    except
      on E: Exception do
        AddToLog('Ex on computing archive hash: ' + E.Message);
    end;

    Archive.OnCompress := TempArchiveHandlers.HandleOnCompress;
    Archive.OnDecompress := TempArchiveHandlers.HandleOnDecompress;
    Archive.OnComputeArchiveHash := TempArchiveHandlers.HandleOnComputeArchiveHash;

    try
      Archive.OpenArchive(ArchiveStream, False);
      try
        Archive.ExtractToStream(CResultFileNameInArchive, AllWorkers[AWorkerIndex].ResponseBitmapStream);
      finally
        Archive.CloseArchive;
      end;
    except
      on E: Exception do
        AddToLog('Ex on extracting archive: ' + E.Message);
    end;
  finally
    ArchiveStream.Free;
    Archive.Free;
    TempArchiveHandlers.Free;
  end;
end;


procedure HandleOnAfterReceivingMQTT_PUBLISH(ClientInstance: DWord; var APublishFields: TMQTTPublishFields; var APublishProperties: TMQTTPublishProperties);
var
  QoS: Byte;
  ID: Word;
  Topic, s, Msg: string;
  i: Integer;
  Content: TStringList;
  WorkerIndex: Integer;
  TempResponseArchiveStr: string;
begin
  QoS := (APublishFields.PublishCtrlFlags shr 1) and 3;
  Msg := StringReplace(DynArrayOfByteToString(APublishFields.ApplicationMessage), #0, '#0', [rfReplaceAll]);
  ID := APublishFields.PacketIdentifier;
  Topic := StringReplace(DynArrayOfByteToString(APublishFields.TopicName), #0, '#0', [rfReplaceAll]);

  AddToLog('Received PUBLISH  ServerPacketIdentifier: ' + IntToStr(ID) +
                                                 '  Msg: ' + Copy(Msg, 1, Pos(CProtocolParam_ResultImageArchive + '=', Msg) - 1) +
                                                 '  QoS: ' + IntToStr(QoS) +
                                                 '  TopicName: ' + Topic);

  s := '';
  for i := 0 to APublishProperties.SubscriptionIdentifier.Len - 1 do
    s := s + IntToStr(APublishProperties.SubscriptionIdentifier.Content^[i]) + ', ';
  AddToLog('SubscriptionIdentifier(s): ' + s);

  Content := TStringList.Create;
  try
    Content.LineBreak := #13#10;
    Content.Text := Msg;

    if Topic = CTopicName_WorkerToApp_GetCapabilities then
      if WaitingForWorkerCapabilities then //This is True only for a short while (see the state machine below). Any worker which publishes after this, is ignored.
        AddNewWorkerToList(Content.Values[CProtocolParam_Name],
                           Content.Values[CProtocolParam_OS],
                           FastReplace_45ToReturn(Content.Values[CProtocolParam_FileCache]), //#4#5 separated list of files. Each item uses the CDefaultInMemFileNameHashSeparator string between name and hash.
                           Content.Values[CProtocolParam_ExtraName]
                          );


    if Topic = CTopicName_WorkerToApp_SendBackground then
    begin
      WorkerIndex := GetWorkerIndexByName(Content.Values[CProtocolParam_Name]);
      if WorkerIndex = -1 then
        AddToLog('Error: cannot find worker "' + Content.Values[CProtocolParam_Name] + '" on receiving result.')
      else
      begin
        if Content.Values['$ExecAction_Err$'] = CBackgroundOKResponse then
        begin
          Inc(WorkerRespondedCount);
          AddToLog('Worker[' + IntToStr(WorkerIndex) + '] responded with success when sending background image.');
        end
        else
          AddToLog('Worker[' + IntToStr(WorkerIndex) + '] responded with error when sending background image: ' + Content.Values['$ExecAction_Err$']);
      end;
    end;

    if Topic = CTopicName_WorkerToApp_FindSubControl then
    begin
      WorkerIndex := GetWorkerIndexByName(Content.Values[CProtocolParam_Name]);
      if WorkerIndex = -1 then
        AddToLog('Error: cannot find worker "' + Content.Values[CProtocolParam_Name] + '" on receiving result.')
      else
      begin
        Inc(WorkerRespondedCount);
        AllWorkers[WorkerIndex].ResponseReceived := True;
        AllWorkers[WorkerIndex].Response := Content.Values['$ExecAction_Err$'];  /////////////// there is also CActionPlugin_ExecutionResultErrorVar, but the response is set to $ExecAction_Err$
        AllWorkers[WorkerIndex].FindSubControlFound := AllWorkers[WorkerIndex].Response = '';

        AllWorkers[WorkerIndex].ResponseVars.ControlLeft := Content.Values['$Control_Left$'];
        AllWorkers[WorkerIndex].ResponseVars.ControlTop := Content.Values['$Control_Top$'];
        AllWorkers[WorkerIndex].ResponseVars.ControlRight := Content.Values['$Control_Right$'];
        AllWorkers[WorkerIndex].ResponseVars.ControlBottom := Content.Values['$Control_Bottom$'];
        AllWorkers[WorkerIndex].ResponseVars.ControlWidth := Content.Values['$Control_Width$'];
        AllWorkers[WorkerIndex].ResponseVars.ControlHeight := Content.Values['$Control_Height$'];
        AllWorkers[WorkerIndex].ResponseVars.HalfControlWidth := Content.Values['$Half_Control_Width$'];
        AllWorkers[WorkerIndex].ResponseVars.HalfControlHeight := Content.Values['$Half_Control_Height$'];
        AllWorkers[WorkerIndex].ResponseVars.SubCnvXOffset := Content.Values['$DebugVar_SubCnvXOffset$'];
        AllWorkers[WorkerIndex].ResponseVars.SubCnvYOffset := Content.Values['$DebugVar_SubCnvYOffset$'];

        if GetAllControls then
        begin
          AllWorkers[WorkerIndex].ResponseVars.AllControl_Handles := Content.Values['$AllControl_Handles$'];
          AllWorkers[WorkerIndex].ResponseVars.AllControl_XOffsets := Content.Values['$AllControl_XOffsets$'];
          AllWorkers[WorkerIndex].ResponseVars.AllControl_YOffsets := Content.Values['$AllControl_YOffsets$'];

          AllWorkers[WorkerIndex].ResponseVars.AllControl_MatchSource := Content.Values['$AllControl_MatchSource$'];
          AllWorkers[WorkerIndex].ResponseVars.AllControl_DetailedMatchSource := Content.Values['$AllControl_DetailedMatchSource$'];
          AllWorkers[WorkerIndex].ResponseVars.AllControl_ResultedErrorCount := Content.Values['$AllControl_ResultedErrorCount$'];

          AllWorkers[WorkerIndex].ResponseVars.AllControl_Lefts := Content.Values['$AllControl_Lefts$'];
          AllWorkers[WorkerIndex].ResponseVars.AllControl_Tops := Content.Values['$AllControl_Lefts$'];
          AllWorkers[WorkerIndex].ResponseVars.AllControl_Rights := Content.Values['$AllControl_Rights$'];
          AllWorkers[WorkerIndex].ResponseVars.AllControl_Bottoms := Content.Values['$AllControl_Bottoms$'];

          AllWorkers[WorkerIndex].ResponseVars.AllControl_Widths := Content.Values['$AllControl_Widths$'];
          AllWorkers[WorkerIndex].ResponseVars.AllControl_Heights := Content.Values['$AllControl_Heights$'];
          AllWorkers[WorkerIndex].ResponseVars.AllHalfControl_Widths := Content.Values['$AllHalf_Control_Widths$'];
          AllWorkers[WorkerIndex].ResponseVars.AllHalfControl_Heights := Content.Values['$AllHalf_Control_Heights$'];
        end;

        TempResponseArchiveStr := Copy(Msg, Pos(CProtocolParam_ResultImageArchive + '=', Msg) + Length(CProtocolParam_ResultImageArchive + '='), MaxInt);
        SetWorkerResponseBitmapStream(WorkerIndex, TempResponseArchiveStr, Content.Values[CProtocolParam_ResponseArchiveSize]);

        AtLeastOneWorkerFoundTheSubControl := GetAllWorkers_AtLeastOneFound;   //this should be set after all responses
      end;
    end;

    if Topic = CTopicName_WorkerToApp_GetListOfFonts then
      if WaitingForWorkerFonts then
      begin
        AddToLog('Received fonts from worker: ' + Content.Values[CProtocolParam_Name]);

        WorkerIndex := GetWorkerIndexByName(Content.Values[CProtocolParam_Name]);
        if WorkerIndex = -1 then
          AddToLog('Error: cannot find worker "' + Content.Values[CProtocolParam_Name] + '" on receiving result.')
        else
          AllWorkers[WorkerIndex].Fonts := Content.Values[CProtocolParam_Fonts];
      end;

    //other fields which may pass metadata:
    //APublishProperties.UserProperty;
    //APublishProperties.ContentType;
    //APublishProperties.CorrelationData;
    //APublishProperties.ResponseTopic;     //this should match the CTopicName_AppToWorker_FindSubControl topic   (i.e. AppToWorker)
  finally
    Content.Free;
  end;

  AddToLog('');
end;


procedure HandleOnBeforeSending_MQTT_PUBREC(ClientInstance: DWord; var ATempPubRecFields: TMQTTPubRecFields; var ATempPubRecProperties: TMQTTPubRecProperties);
begin
  AddToLog('Acknowledging with PUBREC for ServerPacketID: ' + IntToStr(ATempPubRecFields.PacketIdentifier));
end;


procedure HandleOnAfterReceiving_MQTT_PUBREC(ClientInstance: DWord; var ATempPubRecFields: TMQTTPubRecFields; var ATempPubRecProperties: TMQTTPubRecProperties);
begin
  AddToLog('Received PUBREC for PacketID: ' + IntToStr(ATempPubRecFields.PacketIdentifier));
end;


//Sending PUBREL after the PUBREC response from server, after the client has sent a PUBLISH packet with QoS=2.
procedure HandleOnBeforeSending_MQTT_PUBREL(ClientInstance: DWord; var ATempPubRelFields: TMQTTPubRelFields; var ATempPubRelProperties: TMQTTPubRelProperties);
begin
  AddToLog('Acknowledging with PUBREL for PacketID: ' + IntToStr(ATempPubRelFields.PacketIdentifier));
end;


procedure HandleOnAfterReceiving_MQTT_PUBREL(ClientInstance: DWord; var ATempPubRelFields: TMQTTPubRelFields; var ATempPubRelProperties: TMQTTPubRelProperties);
begin
  AddToLog('Received PUBREL for ServerPacketID: ' + IntToStr(ATempPubRelFields.PacketIdentifier));
end;


procedure HandleOnBeforeSending_MQTT_PUBCOMP(ClientInstance: DWord; var ATempPubCompFields: TMQTTPubCompFields; var ATempPubCompProperties: TMQTTPubCompProperties);
begin
  AddToLog('Acknowledging with PUBCOMP for PacketID: ' + IntToStr(ATempPubCompFields.PacketIdentifier));
end;


procedure HandleOnAfterReceiving_MQTT_PUBCOMP(ClientInstance: DWord; var ATempPubCompFields: TMQTTPubCompFields; var ATempPubCompProperties: TMQTTPubCompProperties);
begin
  AddToLog('Received PUBCOMP for ServerPacketID: ' + IntToStr(ATempPubCompFields.PacketIdentifier));
end;


procedure HandleOnAfterReceivingMQTT_PINGRESP(ClientInstance: DWord);
begin
  AddToLog('Received PINGRESP');
end;


procedure HandleOnBeforeSendingMQTT_DISCONNECT(ClientInstance: DWord;  //The lower word identifies the client instance
                                               var ADisconnectFields: TMQTTDisconnectFields;
                                               var ADisconnectProperties: TMQTTDisconnectProperties;
                                               ACallbackID: Word);
begin
  AddToLog('Sending DISCONNECT');
  //ADisconnectFields.EnabledProperties := CMQTTDisconnect_EnSessionExpiryInterval;   //uncomment if needed
  //ADisconnectProperties.SessionExpiryInterval := 1;

  //From spec, pag 89:
  //If the Session Expiry Interval is absent, the Session Expiry Interval in the CONNECT packet is used.
  //If the Session Expiry Interval in the CONNECT packet was zero, then it is a Protocol Error to set a non-
  //zero Session Expiry Interval in the DISCONNECT packet sent by the Client.

  //From spec, pag 89:
  //After sending a DISCONNECT packet the sender
  //  MUST NOT send any more MQTT Control Packets on that Network Connection
  //  MUST close the Network Connection
end;


procedure HandleOnAfterReceivingMQTT_DISCONNECT(ClientInstance: DWord;  //The lower word identifies the client instance
                                                var ADisconnectFields: TMQTTDisconnectFields;
                                                var ADisconnectProperties: TMQTTDisconnectProperties);
begin
  AddToLog('Received DISCONNECT');

  AddToLog('ADisconnectFields.EnabledProperties' + IntToStr(ADisconnectFields.EnabledProperties));
  AddToLog('ADisconnectFields.DisconnectReasonCode' + IntToStr(ADisconnectFields.DisconnectReasonCode));

  AddToLog('ADisconnectProperties.SessionExpiryInterval' + IntToStr(ADisconnectProperties.SessionExpiryInterval));
  AddToLog('ADisconnectProperties.ReasonString' + StringReplace(DynArrayOfByteToString(ADisconnectProperties.ReasonString), #0, '#0', [rfReplaceAll]));
  AddToLog('ADisconnectProperties.ServerReference' + StringReplace(DynArrayOfByteToString(ADisconnectProperties.ServerReference), #0, '#0', [rfReplaceAll]));
  AddToLog('ADisconnectProperties.UserProperty' + StringReplace(DynOfDynArrayOfByteToString(ADisconnectProperties.UserProperty), #0, '#0', [rfReplaceAll]));
end;


procedure HandleOnBeforeSendingMQTT_AUTH(ClientInstance: DWord;  //The lower word identifies the client instance
                                         var AAuthFields: TMQTTAuthFields;
                                         var AAuthProperties: TMQTTAuthProperties;
                                         ACallbackID: Word);
begin
  AddToLog('Sending AUTH');
  AAuthFields.AuthReasonCode := $19; //Example: reauth   - see spec, pag 108.

  StringToDynArrayOfByte('SCRAM-SHA-1', AAuthProperties.AuthenticationMethod);       //some example from spec, pag 108
  StringToDynArrayOfByte('client-second-data', AAuthProperties.AuthenticationData);   //some modified example from spec, pag 108
end;


procedure HandleOnAfterReceivingMQTT_AUTH(ClientInstance: DWord;  //The lower word identifies the client instance
                                          var AAuthFields: TMQTTAuthFields;
                                          var AAuthProperties: TMQTTAuthProperties);
begin
  AddToLog('Received AUTH');

  AddToLog('AAuthFields.EnabledProperties' + IntToStr(AAuthFields.EnabledProperties));
  AddToLog('AAuthFields.AuthReasonCode' + IntToStr(AAuthFields.AuthReasonCode));

  AddToLog('AAuthProperties.ReasonString' + StringReplace(DynArrayOfByteToString(AAuthProperties.ReasonString), #0, '#0', [rfReplaceAll]));
  AddToLog('AAuthProperties.ServerReference' + StringReplace(DynArrayOfByteToString(AAuthProperties.AuthenticationMethod), #0, '#0', [rfReplaceAll]));
  AddToLog('AAuthProperties.ServerReference' + StringReplace(DynArrayOfByteToString(AAuthProperties.AuthenticationData), #0, '#0', [rfReplaceAll]));
  AddToLog('AAuthProperties.UserProperty' + StringReplace(DynOfDynArrayOfByteToString(AAuthProperties.UserProperty), #0, '#0', [rfReplaceAll]));
end;


procedure InitHandlers;
begin
  OnMQTTError^ := @HandleOnMQTTError;
  OnSendMQTT_Packet^ := @HandleOnSend_MQTT_Packet;
  OnBeforeMQTT_CONNECT^ := @HandleOnBeforeMQTT_CONNECT;
  OnAfterMQTT_CONNACK^ := @HandleOnAfterMQTT_CONNACK;
  OnBeforeSendingMQTT_PUBLISH^ := @HandleOnBeforeSendingMQTT_PUBLISH;
  OnBeforeSendingMQTT_PUBACK^ := @HandleOnBeforeSendingMQTT_PUBACK;
  OnAfterReceivingMQTT_PUBACK^ := @HandleOnAfterReceivingMQTT_PUBACK;
  OnAfterReceivingMQTT_PUBLISH^ := @HandleOnAfterReceivingMQTT_PUBLISH;
  OnBeforeSendingMQTT_PUBREC^ := @HandleOnBeforeSending_MQTT_PUBREC;
  OnAfterReceivingMQTT_PUBREC^ := @HandleOnAfterReceiving_MQTT_PUBREC;
  OnBeforeSendingMQTT_PUBREL^ := @HandleOnBeforeSending_MQTT_PUBREL;
  OnAfterReceivingMQTT_PUBREL^ := @HandleOnAfterReceiving_MQTT_PUBREL;
  OnBeforeSendingMQTT_PUBCOMP^ := @HandleOnBeforeSending_MQTT_PUBCOMP;
  OnAfterReceivingMQTT_PUBCOMP^ := @HandleOnAfterReceiving_MQTT_PUBCOMP;
  OnBeforeSendingMQTT_SUBSCRIBE^ := @HandleOnBeforeSendingMQTT_SUBSCRIBE;
  OnAfterReceivingMQTT_SUBACK^ := @HandleOnAfterReceivingMQTT_SUBACK;
  OnBeforeSendingMQTT_UNSUBSCRIBE^ := @HandleOnBeforeSendingMQTT_UNSUBSCRIBE;
  OnAfterReceivingMQTT_UNSUBACK^ := @HandleOnAfterReceivingMQTT_UNSUBACK;
  OnAfterReceivingMQTT_PINGRESP^ := @HandleOnAfterReceivingMQTT_PINGRESP;
  OnBeforeSendingMQTT_DISCONNECT^ := @HandleOnBeforeSendingMQTT_DISCONNECT;
  OnAfterReceivingMQTT_DISCONNECT^ := @HandleOnAfterReceivingMQTT_DISCONNECT;
  OnBeforeSendingMQTT_AUTH^ := @HandleOnBeforeSendingMQTT_AUTH;
  OnAfterReceivingMQTT_AUTH^ := @HandleOnAfterReceivingMQTT_AUTH;
end;


procedure TMQTTReceiveThread.AddMsgToLog(s: string);
begin
  AddToLog(s);
end;


procedure TMQTTReceiveThread.Execute;
var
  TempReadBuf, ExactPacket: TDynArrayOfByte;
  //ReadCount: Integer;
  TempByte: Byte;
  PacketName: string;
  PacketSize: DWord;
  //LoggedDisconnection: Boolean;
  TempArr: TIdBytes;
  SuccessfullyDecoded: Boolean;
  ProcessBufferLengthResult: Word;
begin
  FDone := False;

  try
    //ReadCount := 0;
    InitDynArrayToEmpty(TempReadBuf);

    try
      //LoggedDisconnection := False;
      repeat
        //try
        //  TempByte := IdTCPClient1.IOHandler.ReadByte;
        //  AddByteToDynArray(TempByte, TempReadBuf);
        //except
        //  on E: Exception do      ////////////////// ToDo: switch to EIdReadTimeout
        //  begin
        //    if (E.Message = 'Read timed out.') and (TempReadBuf.Len > 0) then
        //    begin
        //      MQTTPacketToString(TempReadBuf.Content^[0], PacketName);
        //      AddMsgToLog('done receiving packet: ' + E.Message + {'   ReadCount: ' + IntToStr(ReadCount) +} '   E.ClassName: ' + E.ClassName);
        //      AddMsgToLog('Buffer size: ' + IntToStr(TempReadBuf.Len) + '  Packet header: $' + IntToHex(TempReadBuf.Content^[0]) + ' (' + PacketName + ')');
        //
        //      SyncReceivedBuffer(TempReadBuf);
        //
        //      FreeDynArray(TempReadBuf);
        //      //ReadCount := 0; //reset for next packet
        //    end
        //    else
        //      if E.Message = 'Connection Closed Gracefully.' then
        //        if not LoggedDisconnection then
        //        begin
        //          LoggedDisconnection := True;
        //          AddMsgToLog('Disconnected from server. Cannot receive more data. Ex: ' + E.Message);
        //        end;
        //
        //    Sleep(1);
        //  end;
        //end;

        try
          TempByte := IdTCPClient1.IOHandler.ReadByte;
          if not AddByteToDynArray(TempByte, TempReadBuf) then
          begin
            HandleOnMQTTError(0, CMQTT_UserError, CMQTT_UNDEFINED);
            AddToLog('Cannot allocate buffer when reading. TempReadBuf.Len = ' + IntToStr(TempReadBuf.Len));
            MessageBoxFunction('Cannot allocate buffer when reading.', 'th_', 0);
            FreeDynArray(TempReadBuf);
            Sleep(1000);
          end
          else
          begin
            SuccessfullyDecoded := True;                                         //PacketSize should be the expected size, which can be greater than TempReadBuf.Len
            ProcessBufferLengthResult := MQTT_ProcessBufferLength(TempReadBuf, PacketSize);

            if ProcessBufferLengthResult <> CMQTTDecoderNoErr then
            begin
              SuccessfullyDecoded := False;

              if (ProcessBufferLengthResult = CMQTTDecoderIncompleteBuffer) and (PacketSize > 0) then  //PacketSize is successfully decoded, but the packet is incomplete
              begin
                //to get a complete packet, the number of bytes to be read next is PacketSize - TempReadBuf.Len.
                IdTCPClient1.IOHandler.ReadTimeout := 10;

                SetLength(TempArr, 0);
                IdTCPClient1.IOHandler.ReadBytes(TempArr, PacketSize - TempReadBuf.Len);

                if Length(TempArr) > 0 then //it should be >0, otherwise there should be a read timeout exception
                begin
                  if not AddBufferToDynArrayOfByte(@TempArr[0], Length(TempArr), TempReadBuf) then
                  begin
                    AddToLog('Out of memory on allocating TempReadBuf, for multiple bytes.');
                    MessageBoxFunction('Cannot allocate buffer when reading multiple bytes.', 'th_', 0);
                    FreeDynArray(TempReadBuf);
                    Sleep(1000);
                  end
                  else
                  begin
                    SetLength(TempArr, 0);
                    ProcessBufferLengthResult := MQTT_ProcessBufferLength(TempReadBuf, PacketSize);
                    SuccessfullyDecoded := ProcessBufferLengthResult = CMQTTDecoderNoErr;
                  end;
                end;

                IdTCPClient1.IOHandler.ReadTimeout := 10; //restore timeout, in case the above is increased
              end;
            end;

            if SuccessfullyDecoded then
            begin
              MQTTPacketToString(TempReadBuf.Content^[0], PacketName);
              AddToLog('done receiving packet');
              AddToLog('Buffer size: ' + IntToStr(TempReadBuf.Len) + '  Packet header: $' + IntToHex(TempReadBuf.Content^[0]) + ' (' + PacketName + ')');

              if PacketSize <> TempReadBuf.Len then
              begin
                if CopyFromDynArray(ExactPacket, TempReadBuf, 0, PacketSize) then
                begin
                  SyncReceivedBuffer(ExactPacket);
                  FreeDynArray(ExactPacket);
                  if not RemoveStartBytesFromDynArray(PacketSize, TempReadBuf) then
                    AddToLog('Cannot remove processed packet from TempReadBuf. Packet type: '+ PacketName);
                end
                else
                  AddToLog('Out of memory on allocating ExactPacket.');
              end
              else
              begin
                SyncReceivedBuffer(TempReadBuf);   //MQTT_Process returns an error for unknown and incomplete packets
                FreeDynArray(TempReadBuf);   //freed here, only when a valid packet is formed
              end;

              Sleep(1);
            end; //SuccessfullyDecoded
          end;
        except
        end;

        //Inc(ReadCount);
      until Terminated;
    finally
      AddMsgToLog('Thread done..');
    end;
  except
    on E: Exception do
      AddMsgToLog('Th ex: ' + E.Message);
  end;

  FDone := True;
end;



function GetAPIVersion: DWord; cdecl;
begin
  Result := CActionPlugin_APIVersion;
end;


procedure GetListOfProperties(APluginReference: Pointer;                 //UIClicker passes the plugin reference to the plugin, then the plugin calls some callbacks with that reference
                              AListOfProperties: Pointer;
                              AListOfPropertiesLen: PDWord;
                              AOnActionPlugin_UpdatePropertyIcons: TOnActionPlugin_UpdatePropertyIcons); cdecl;
var
  Properties: string;
  i: Integer;
  TempMemStream: TMemoryStream;
  Bmp: TBitmap;
begin
  Properties := FillInPropertyDetails;
  AListOfPropertiesLen^ := SetPointedContentFromString(Properties, AListOfProperties);

  dmProperties := TdmProperties.Create(nil);
  try
    for i := 0 to CPropertiesCount - 1 do
    begin
      TempMemStream := TMemoryStream.Create;
      Bmp := TBitmap.Create;
      try
        Bmp.PixelFormat := pf24bit;
        Bmp.Width := dmProperties.imglstProperties.Width;
        Bmp.Height := dmProperties.imglstProperties.Height;
        Bmp.Canvas.Pen.Color := clWhite;
        Bmp.Canvas.Brush.Color := clWhite;
        Bmp.Canvas.Rectangle(0, 0, Bmp.Width, Bmp.Height);

        dmProperties.imglstProperties.Draw(Bmp.Canvas, 0, 0, i, dsNormal, itImage);
        Bmp.SaveToStream(TempMemStream);

        AOnActionPlugin_UpdatePropertyIcons(APluginReference, TempMemStream.Memory, TempMemStream.Size);
      finally
        TempMemStream.Free;
        Bmp.Free;
      end;
    end;
  finally
    dmProperties.Free;
  end;
end;


constructor TPluginMQTTClientHandlers.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  tmrProcessRecData := TTimer.Create(Self);
  tmrProcessRecData.Interval := 5;
  tmrProcessRecData.OnTimer := tmrProcessRecDataTimer;
  tmrProcessRecData.Enabled := True;
end;


procedure TPluginMQTTClientHandlers.tmrProcessRecDataTimer(Sender: TObject);
begin
  //try
  //  DebugPoint('ProcessReceivedBuffer timer', '');
  //except
  //end;

  try
    ProcessReceivedBuffer;
  except
    on E: Exception do
    begin
      AddToLog('_________________ Ex on processing received data: ' + E.Message);
      Sleep(1000); //this loop is pretty fast, so slow it to the point where the user can manually stop the process
    end;
  end;
end;


procedure TPluginMQTTClientHandlers.HandleClientOnConnected(Sender: TObject);
begin
  AddToLog('Connected to broker... on port ' + IntToStr(IdTCPClient1.Port));
end;


procedure TPluginMQTTClientHandlers.HandleClientOnDisconnected(Sender: TObject);
var
  tk: QWord;
begin
  AddToLog('Disconnected from broker...');
  try
    RecTh.Terminate;
    tk := GetTickCount64;
    repeat
      Application.ProcessMessages;
      Sleep(1);

      if GetTickCount64 - tk > 2000 then
      begin
        AddToLog('+++++++++++++++++++ Timeout waiting for RecTh to terminate.');
        Break;
      end;
    until RecTh.FDone;
  except
    on E: Exception do
      AddToLog('+++++++++++++++++++ Ex on terminating RecTh: ' + E.Message);
  end;
end;


function DoConnectToBroker: Boolean;
begin
  Result := False;
  try
    IdTCPClient1.Connect(AddressPropertyValue, StrToIntDef(PortPropertyValue, 12345));
    IdTCPClient1.IOHandler.ReadTimeout := 1;

    RecTh := TMQTTReceiveThread.Create(True);
    RecTh.FreeOnTerminate := False;
    RecTh.Start;

    if not MQTT_CONNECT(0, 0) then
    begin
      Result := False;
      Exit;
    end;

    Result := True;
  except
    on E: Exception do
      AddToLog('Can''t connect.  ' + E.Message + '   Class: ' + E.ClassName);
  end; //connect
end;


//procedure DoWaitForAllResponses;
//var
//  tk: QWord;
//begin
//  PublishAckReceived := False;
//  tk := GetTickCount64;
//  repeat
//    Application.ProcessMessages;
//    Sleep(1);
//  until (GetTickCount64 - tk > 1500) or PublishAckReceived;
//end;


function DoDisconnect: Boolean;
var
  tk: QWord;
  ClientToServerBuf: {$IFDEF SingleOutputBuffer} PMQTTBuffer; {$ELSE} PMQTTMultiBuffer; {$ENDIF}
  Err: Word;
begin
  Result := False;
  //Disconnecting:
  if not MQTT_DISCONNECT(0, 0) then
  begin
    AddToLog('Can''t disconnect.');
    Exit;
  end;

  tk := GetTickCount64;
  repeat
    ClientToServerBuf := MQTT_GetClientToServerBuffer(0, Err);
    Application.ProcessMessages;
    Sleep(10);
  until (GetTickCount64 - tk > 1500) or ((ClientToServerBuf <> nil) and (ClientToServerBuf^.Len = 0));

  RecTh.Terminate;
  tk := GetTickCount64;
  repeat
    Application.ProcessMessages;
    Sleep(1);
  until (GetTickCount64 - tk > 1500) or RecTh.Terminated;
  FreeAndNil(RecTh);

  IdTCPClient1.Disconnect(False);
  Result := True;
end;


//see https://wiki.freepascal.org/Logging_exceptions
procedure TExHandler.CustomExceptionHandler(Sender: TObject; E: Exception);
var
  ClName, EMsg: string;
begin
  try
    ClName := Sender.ClassName;
  except
    ClName := '';
  end;

  try
    EMsg := E.Message;
  except
    EMsg := '';
  end;

  try
    AddToLog('Custom exception in plugin: "' + EMsg + '"   Class: "' + ClName + '"."');
  except
    on EE: Exception do
      //MessageBox(0, PChar('Ex on custom exception: ' + EE.Message), 'Plugin', MB_ICONERROR);
  end;
end;


//see https://wiki.freepascal.org/Logging_exceptions
procedure CatchUnhandledException(Obj: TObject; Addr: Pointer; FrameCount: LongInt; Frames: PPointer);
var
  Msg: string;
  i: Integer;
begin
  try //use another try..excempt, just in case parsing the stack would raise more exceptions
    Msg := 'Unhandled exception at adddr $' + SysBacktraceStr(Addr) + ':' + #13#10;

    if Obj is Exception then
      Msg := Msg + Exception(Obj).ClassName + ' : ' + Exception(Obj).Message
    else
      Msg := Msg + 'Exception object '  + Exception(Obj).ClassName + ' is not class Exception.';

    Msg := Msg + #13#10;
    Msg := Msg + BacktraceStrFunc(Addr) + #13#10;

    for i := 0 to FrameCount - 1 do
      Msg := Msg + BacktraceStrFunc(Frames[i]) + #13#10;

    AddToLog('Custom exception in plugin: "' + Msg + '".');
  except
  end;
end;


procedure GetAllVarsAndValuesFromVarsForWorkers(AVarsForWorkers: string; AListOfAllVars: TStringList; out AAllNames, AAllValues, AAllEvalBefore: string);
var
  ListOfVarsForWorkers: TStringList;
  i: Integer;
  VarName, VarValue: string;
  AllNames, AllValues, AllEvalBefore: string;
begin
  ListOfVarsForWorkers := TStringList.Create;
  try
    ListOfVarsForWorkers.LineBreak := #13#10;
    AVarsForWorkers := StringReplace(AVarsForWorkers, ', ', #13#10, [rfReplaceAll]);
    AVarsForWorkers := StringReplace(AVarsForWorkers, ',', #13#10, [rfReplaceAll]);

    ListOfVarsForWorkers.Text := AVarsForWorkers;

    AllNames := '';
    AllValues := '';
    AllEvalBefore := '';
    for i := 0 to ListOfVarsForWorkers.Count - 1 do
    begin
      VarName := ListOfVarsForWorkers.Strings[i];
      VarValue := AListOfAllVars.Values[VarName];

      AAllNames := AAllNames + VarName + #4#5;
      AAllValues := AAllValues + VarValue + #4#5;
      AAllEvalBefore := AAllEvalBefore + '0' + #4#5;
    end;
  finally
    ListOfVarsForWorkers.Free;
  end;
end;


procedure GetPluginSettingsFromProperties(AProperties: TStringList; AListOfVars: string);
var
  ListOfVars: TStringList;
begin
  FindSubControlActionPropertyValue := AProperties.Values[CFindSubControlActionPropertyName];
  CredentialsFullFileNamePropertyValue := AProperties.Values[CCredentialsFullFileNamePropertyName];  //for connection to broker
  AddressPropertyValue := AProperties.Values[CAddressPropertyName];
  PortPropertyValue := AProperties.Values[CPortPropertyName];

  ListOfVars := TStringList.Create;
  try
    ListOfVars.LineBreak := #13#10;
    ListOfVars.Text := AListOfVars;
    CredentialsFullFileNamePropertyValue := EvaluateAllReplacements(ListOfVars, CredentialsFullFileNamePropertyValue);

    // AProperties.Values[CVariablesForWorkersPropertyName] is a comma-separated list of vars
    GetAllVarsAndValuesFromVarsForWorkers(AProperties.Values[CVariablesForWorkersPropertyName], ListOfVars, VarsForWorkers_Names, VarsForWorkers_Values, VarsForWorkers_EvalBefore);
  finally
    ListOfVars.Free;
  end;
end;


procedure ExecFSM_Part1;
var
  i: Integer;
begin
  case State of
    SInit:
    begin
      FSMDone := False;
      ConnectedSucessfully := False;
      ConAckReceived := False;
      SubAckReceived := False;
      SubscribedSucessfully := False;
      DisconnectedSuccessfully := False;
      tk := GetTickCount64;
    end;

    SConnectToBroker:
    begin
      AddToLog('Connecting to broker.');
      ConnectedSucessfully := DoConnectToBroker;

      if ConnectedSucessfully then
      begin
        tk := GetTickCount64;
        DbgPoint('Connected to broker.', '')
      end
      else
      begin
        FSMError := 'Can''t connect to broker.';
        AddToLog(FSMError);
      end;
    end;

    SWaitForConAck:
    begin
      // ConAckReceived is set by handler
    end;

    SSubscribeToResponses:
    begin
      SubscribedSucessfully := MQTT_SUBSCRIBE(0, 0);     //subscribing with CTopicNameResult
      if not SubscribedSucessfully then
      begin
        FSMError := 'Can''t subscribe for responses.';
        AddToLog(FSMError);
      end
      else
        tk := GetTickCount64;
    end;

    SWaitForResponsesSubAck:   //Responses can be capabilities, lists of missing files, processing results
    begin
      //SubAckReceived is set by handler
    end;

    SRequestCapabilities:
    begin
      WaitingForWorkerCapabilities := True;    //reset below
      if not MQTT_PUBLISH(0, CCallbackID_GetCapabilities, WorkerQoS) then  //notice CallbackID = 0      (i.e. 'GetCapabilities')
      begin
        FSMError := 'Can''t send GetCapabilities request to broker.';
        AddToLog(FSMError);
      end
      else
        tk := GetTickCount64;
    end;

    SWaitForCapabilitiesResponse:
    begin
      // Every worker has to respond with what capabilities is configured.
      // Some can process Text, others Bmp files, others Primitives.
      // If the FindSubControl action has only two text profiles, it makes sense to distribute the search to both workers.
      // That means, all workers should be able to process anything. Anyway, since all have UIClicker installed, all of them should be able to do all.
      // The only real difference between workers would be the OS (Win vs Lin), where each may have different lists of fonts and different GPU rendering settings.
      // So, the best option would be to evenly split (as best as possible) all types of FindSubControls (Txt, Bmp, Pmtv) across all workers.

      // For efficient use of the network, it would be better if all workers can respond here with the list of the bmp/pmtv files (including backgrounds),
      // along with their MD5 hashes, so that the plugin would know what files to send to each worker.
      // Since all backgrounds may have the same name ('Background.bmp'), this bmp should be renamed to 'Background_<MD5>.bmp'.
      // The backgrounds are likely to change, but some of them, like menus or various window parts may stay the same.
      // The worker should be configurable about the cache size.
    end;

    SGetFindSubControlActionContent:
    begin
      //This is where GetFindControlActionProperties is called (unfortunately in FSM's loop) instead of this case item.
    end;

    SPublishBackgroundImageToAllWorkers:
    begin
      AtLeastOneWorkerFoundTheSubControl := False;
      WorkerRespondedCount := 0;

      AddToLog('Sending background image to broker...');
      if not MQTT_PUBLISH(0, CCallbackID_SendBackgroundToAll, WorkerQoS) then   //notice CallbackID = 1     (i.e. 'SendBackgroundToAll')
      begin
        FSMError := 'Can''t send background image to all workers.';
        AddToLog(FSMError);
      end
      else
        tk := GetTickCount64;
      AddToLog('Done sending background image.');
    end;

    SWaitForBackgroundImageResults:
    begin

    end;

    SPublishFindSubControlToAllWorkers:
    begin
      AtLeastOneWorkerFoundTheSubControl := False;
      WorkerRespondedCount := 0;

      AddToLog('Sending FindSubControl settings to broker...');
      for i := 0 to Length(AllWorkers) - 1 do
      begin
        if not MQTT_PUBLISH(0, CCallbackID_SendFindSubControl or (i shl 8), WorkerQoS) then   //notice CallbackID = 3     (i.e. 'FindSubControl')
        begin
          FSMError := 'Can''t send FindSubControl settings to broker for worker[' + IntToStr(i) + '].';
          AddToLog(FSMError);
        end
        else
          tk := GetTickCount64;
      end;
      AddToLog('Done sending FindSubControl settings.');
    end;

    SWaitForFindSubControlResults:
    begin
      // It is possible that the plugin may receive "missing files" requests.
      // If that's the case, it should send those files, here in the same state.
    end;

    SGetListOfFonts:
    begin
      WaitingForWorkerFonts := True; //reset below
      for i := 0 to Length(AllWorkers) - 1 do
      begin
        if not MQTT_PUBLISH(0, CCallbackID_GetListOfFonts or (i shl 8), WorkerQoS) then   //notice CallbackID = 4     (i.e. 'GetListOfFonts')
        begin
          FSMError := 'Can''t send GetListOfFonts settings to broker for worker[' + IntToStr(i) + '].';
          AddToLog(FSMError);
        end
        else
          tk := GetTickCount64;
      end;
    end;

    SWaitForListOfFonts:
    begin

    end;

    SUpdateCache:
    begin
      AddToLog('Updating plugin cache..');
      if UpdateCacheActionName = '' then
      begin
        FSMError := 'There is no configured action for updating plugin cache.';
        AddToLog(FSMError);
      end
      else
        if not ActionPlugin_ExecuteActionallback(GPluginReference, @UpdateCacheActionName[1]) then
          FSMError := 'Error updating plugin cache. The ' + UpdateCacheActionName + ' action failed.';
          //ToDo: load all vars, then read the value of $ExecAction_Err$ and concatenate it to the error message above.
    end;

    SLoadCache:
    begin
      AddToLog('Loading plugin cache..');
      if LoadCacheActionName = '' then
      begin
        FSMError := 'There is no configured action for loading plugin cache.';
        AddToLog(FSMError);
      end
      else
        if not ActionPlugin_ExecuteActionallback(GPluginReference, @LoadCacheActionName[1]) then
          FSMError := 'Error loading plugin cache. The ' + LoadCacheActionName + ' action failed.';
          //ToDo: load all vars, then read the value of $ExecAction_Err$ and concatenate it to the error message above.
    end;

    SDisconnectFromBroker:
    begin
      FSMDone := True;
      DisconnectedSuccessfully := DoDisconnect;
    end;

    SDone:
    begin
      FSMDone := True;
      AddToLog('Plugin done');
    end;
  end;
end;


procedure ExecFSM_Part2;
begin
  case State of
    SInit:
      NextState := SConnectToBroker;

    SConnectToBroker:
      if ConnectedSucessfully then
        NextState := SWaitForConAck
      else
        NextState := SDone;

    SWaitForConAck:
    begin
      if ConAckReceived then  //there should be one ConAckReceived event only (this plugin to broker), unlike multiple workers below
        NextState := SSubscribeToResponses
      else
        if GetTickCount64 - tk > 1000 then
          NextState := SDone //Timeout
        else
          NextState := SWaitForConAck;
    end;

    SSubscribeToResponses:
      if SubscribedSucessfully then
        NextState := SWaitForResponsesSubAck
      else
        NextState := SDone;

    SWaitForResponsesSubAck:   //Responses can be capabilities, lists of missing files, processing results
      if SubAckReceived then
      begin
        if WorkerCapabilitiesSource = CReqCapOperation_wcsLoadCacheAndFindSubControl then
          NextState := SLoadCache
        else
          NextState := SRequestCapabilities
      end
      else
        if GetTickCount64 - tk > 1000 then
          NextState := SDone //Timeout
        else
          NextState := SWaitForResponsesSubAck;

    SRequestCapabilities:
      NextState := SWaitForCapabilitiesResponse;

    SWaitForCapabilitiesResponse:
      if GetTickCount64 - tk > GetWorkerCapabilitiesTimeout then   //Waiting for some time, for all workers to present their capabilities. This way, the plugin knows home many are they.
      begin
        if WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndFindSubControl then
          NextState := SGetFindSubControlActionContent
        else
          if WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndGetFonts then
            NextState := SGetListOfFonts
          else
            if WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndGetFontsAndFindSubControl then
              NextState := SGetListOfFonts  //in SWaitForListOfFonts, there is still a verification of WorkerCapabilitiesSource
            else
              if WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndUpdateCache then
                NextState := SUpdateCache
              else
                if WorkerCapabilitiesSource = CReqCapOperation_wcsLoadCacheAndFindSubControl then   //////////// this should not happen in this state
                begin
                  NextState := SDisconnectFromBroker; /////////////// set here to a different state when implemented
                  AddToLog('________' + CReqCapOperation_wcsLoadCacheAndFindSubControl + ' not implemented yet...'); //remove comment
                end
                else
                begin
                  NextState := SDisconnectFromBroker;
                  AddToLog('________ Unknown operation: ' + WorkerCapabilitiesSource + '. Exiting plugin.');
                end;

        WaitingForWorkerCapabilities := False;
      end
      else
        NextState := SWaitForCapabilitiesResponse;

    SGetFindSubControlActionContent:
    begin
      if Length(AllWorkers) > 255 then
      begin
        FSMError := 'Too many workers (' + IntToStr(Length(AllWorkers)) + '). Please modify the index encoding to raise the limit above 255.';
        AddToLog(FSMError);
        NextState := SDone;
      end
      else
        NextState := SPublishBackgroundImageToAllWorkers;
    end;

    SPublishBackgroundImageToAllWorkers:
      NextState := SWaitForBackgroundImageResults;

    SWaitForBackgroundImageResults:
      if GetTickCount64 - tk > FindSubControlWorkerTimeout then   //not sure what timeout to use here
      begin
        NextState := SDone; //Timeout

        if WorkerRespondedCount = 0 then
          FSMError := 'Timeout waiting for workers to send the background image to their local UIClicker.'
        else
          FSMError := 'Some of the responding workers could not send the the background image to their local UIClicker.';

        FSMError := FSMError + ' ResponseCount = ' + IntToStr(WorkerRespondedCount) + ' / ' + IntToStr(Length(AllWorkers)) + '.';

        AddToLog(FSMError);
      end
      else
      begin
        NextState := SWaitForBackgroundImageResults;

        if WorkerRespondedCount >= Length(AllWorkers) then
        begin
          NextState := SPublishFindSubControlToAllWorkers;
          AddToLog('All workers responded after having the background image in ' + IntToStr(GetTickCount64 - tk) + 'ms.');
        end;
      end;

    SPublishFindSubControlToAllWorkers:
      NextState := SWaitForFindSubControlResults;

    SWaitForFindSubControlResults:
      if AtLeastOneWorkerFoundTheSubControl then
        NextState := SDisconnectFromBroker
      else
        if GetTickCount64 - tk > FindSubControlWorkerTimeout then
        begin
          NextState := SDone; //Timeout

          if WorkerRespondedCount = 0 then
            FSMError := 'Timeout waiting for workers to find the SubControl.'
          else
            FSMError := 'None of the responding workers found the SubControl.';

          FSMError := FSMError + ' ResponseCount = ' + IntToStr(WorkerRespondedCount) + ' / ' + IntToStr(Length(AllWorkers)) + '.';

          AddToLog(FSMError);
        end
        else
          NextState := SWaitForFindSubControlResults;

    SGetListOfFonts:
      NextState := SWaitForListOfFonts;

    SWaitForListOfFonts:
      if GetTickCount64 - tk > GetWorkerCapabilitiesTimeout then   //Waiting for some time, for all workers to present their fonts.
      begin
        if WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndGetFontsAndFindSubControl then
          NextState := SGetFindSubControlActionContent
        else
          NextState := SDisconnectFromBroker;

        WaitingForWorkerFonts := False;
      end
      else
        NextState := SWaitForListOfFonts;

    SUpdateCache:
      NextState := SDisconnectFromBroker;

    SLoadCache:
    begin
      //NextState := SGetFindSubControlActionContent;  //from SLoadCache, the next state should be SGetFindSubControlActionContent
      WorkerCapabilitiesSource := CReqCapOperation_wcsReqCapAndFindSubControl; //but the list of workers is not updated yet by the cache.  ToDo
      NextState := SRequestCapabilities; //Go and get capabilities, which updates the list of workers and then execute FindSubControl. (Temp solution.)
    end;

    SDisconnectFromBroker:
      NextState := SDone;

    SDone:
      NextState := SDone;
  end;
end;


procedure ExecFSM;
begin
  ExecFSM_Part1;
  ExecFSM_Part2;
  State := NextState;
end;


procedure HandleOnFileContent(ACallReference, AStreamContent: Pointer; AStreamSize: Int64); cdecl;
var
  TempStream: TMemoryStream;
  DestBmp: TBitmap;
begin
  if AStreamSize <= 0 then
    Exit;

  DestBmp := TBitmap(ACallReference); //created by caller

  TempStream := TMemoryStream.Create;
  try
    TempStream.SetSize(AStreamSize);
    Move(AStreamContent^, TempStream.Memory^, AStreamSize);
    DestBmp.LoadFromStream(TempStream, AStreamSize);
  finally
    TempStream.Free;
  end;
end;


procedure HandleOnFileContentAsRawStream(ACallReference, AStreamContent: Pointer; AStreamSize: Int64); cdecl;
var
  DestMemStream: TMemoryStream;
begin
  if AStreamSize <= 0 then
    Exit;

  DestMemStream := TMemoryStream(ACallReference); //created by caller
  DestMemStream.SetSize(AStreamSize);
  Move(AStreamContent^, DestMemStream.Memory^, AStreamSize);
end;


function ExecutePlugin(APluginReference: Pointer;
                       AListOfPluginSettings: Pointer;
                       AListOfPluginSettingsLen: PDWord;

                       AOnActionPlugin_GetActionCount: TOnActionPlugin_GetActionCount;
                       AOnActionPlugin_GetActionInfoByIndex: TOnActionPlugin_GetActionInfoByIndex;
                       AOnActionPlugin_GetActionContentByIndex: TOnActionPlugin_GetActionContentByIndex;
                       AOnActionPlugin_ExecuteAction: TOnActionPlugin_ExecuteAction;
                       AOnActionPlugin_GetAllTemplateVars: TOnActionPlugin_GetAllTemplateVars;
                       AOnActionPlugin_SetTemplateVar: TOnActionPlugin_SetTemplateVar;
                       AOnActionPlugin_DebugPoint: TOnActionPlugin_DebugPoint;
                       AOnActionPlugin_AddToLog: TOnActionPlugin_AddToLog;
                       AOnActionPlugin_SetResultImg: TOnActionPlugin_SetResultImg;
                       AOnActionPlugin_LoadBitmap: TOnActionPlugin_LoadBitmap;
                       AOnActionPlugin_GetAllowedFilesInfo: TOnActionPlugin_GetAllowedFilesInfo;
                       AOnActionPlugin_SetBitmap: TOnActionPlugin_SetBitmap;
                       AOnActionPlugin_Screenshot: TOnActionPlugin_Screenshot;
                       AOnActionPlugin_CheckStopAllActionsOnDemand: TOnActionPlugin_CheckStopAllActionsOnDemand;
                       AOnActionPlugin_InMemFS: TOnActionPlugin_InMemFS
                       ): Boolean; cdecl;
var
  ActionCount, IndexOfFindSubControlActionProperty: Integer;
  PluginSettingsStr, AllVarsStr: string;
  ListOfAllVars: TStringList;
  TempPluginMQTTClientHandlers: TPluginMQTTClientHandlers;
  s: string;
  ActionTypeDWord: DWord;
  ActionType: TClkAction;
  UsingCompression: Boolean;
  PluginSettings: TStringList;

  procedure SetTemplateVar(AVarName, AVarValue: string);
  begin
    AOnActionPlugin_SetTemplateVar(APluginReference, @AVarName[1], @AVarValue[1]);
  end;

  procedure GetActionInfoByIndex(AIndex: Integer; out AActionName: string; var AActionType: DWord);
  var
    Buffer: string;
    ActionNamePtr: Pointer;
    NameLengthDWord: DWord;
  begin
    SetLength(Buffer, CMaxSharedStringLength + 1);
    ActionNamePtr := @Buffer[1];
    NameLengthDWord := 0;

    AActionName := '';
    AOnActionPlugin_GetActionInfoByIndex(APluginReference, AIndex, ActionNamePtr, @NameLengthDWord, @AActionType);
    SetPointedContentToString(ActionNamePtr, AActionName);
    SetLength(AActionName, NameLengthDWord);
  end;

  procedure GetAllTemplateVars(out AAllTemplateVars: string);  //AAllTemplateVars are encoded as CRLF separated key=value strings, ready to be used on a TStringlist
  var
    Buffer: string;
    AllTemplateVarsPtr: Pointer;
    NameLengthDWord: DWord;
  begin
    SetLength(Buffer, CMaxSharedStringLength + 1);
    AllTemplateVarsPtr := @Buffer[1];
    NameLengthDWord := 0;
    AAllTemplateVars := '';

    AOnActionPlugin_GetAllTemplateVars(APluginReference, AllTemplateVarsPtr, @NameLengthDWord);  //decode action execution results

    SetPointedContentToString(AllTemplateVarsPtr, AAllTemplateVars);
    SetLength(AAllTemplateVars, NameLengthDWord);
  end;

  function GetPluginSettings: string;
  begin
    SetLength(Result, CMaxSharedStringLength);
    SetPointedContentToString(AListOfPluginSettings, Result);
    SetLength(Result, AListOfPluginSettingsLen^);
  end;

  function BitmapIsAllowedToBeLoaded(AFnm: string; out ADenyReason: string): Boolean;
  var
    TempFileProvider: TFileProvider;
    FullTemplatesDir, AllowedFileDirsForServer, AllowedFileExtensionsForServer: string;
    FullTemplatesDirPtr, AllowedFileDirsForServerPtr, AllowedFileExtensionsForServerPtr: Pointer;
  begin
    TempFileProvider := TFileProvider.Create;
    try
      SetLength(FullTemplatesDir, CMaxSharedStringLength + 1);
      SetLength(AllowedFileDirsForServer, CMaxSharedStringLength + 1);
      SetLength(AllowedFileExtensionsForServer, CMaxSharedStringLength + 1);

      FullTemplatesDirPtr := @FullTemplatesDir[1];
      AllowedFileDirsForServerPtr := @AllowedFileDirsForServer[1];
      AllowedFileExtensionsForServerPtr := @AllowedFileExtensionsForServer[1];

      AOnActionPlugin_GetAllowedFilesInfo(APluginReference, FullTemplatesDirPtr, AllowedFileDirsForServerPtr, AllowedFileExtensionsForServerPtr);
      FullTemplatesDir := Copy(FullTemplatesDir, 1, Pos(#0, FullTemplatesDir) - 1);
      AllowedFileDirsForServer := Copy(AllowedFileDirsForServer, 1, Pos(#0, AllowedFileDirsForServer) - 1);
      AllowedFileExtensionsForServer := Copy(AllowedFileExtensionsForServer, 1, Pos(#0, AllowedFileExtensionsForServer) - 1);

      TempFileProvider.FullTemplatesDir := FullTemplatesDir;

      TempFileProvider.AddListOfAccessibleDirs(AllowedFileDirsForServer);
      TempFileProvider.AddListOfAccessibleFileExtensions(AllowedFileExtensionsForServer);

      Result := TempFileProvider.FileIsAllowed(AFnm, ADenyReason);
    finally
      TempFileProvider.Free;
    end;
  end;

  function LoadBitmap(AFnm: string; ADestBmp: TBitmap; AFileLocation: TImageSourceFileNameLocation): Boolean;
  var
    TempDenyReason: string;
  begin
    if BitmapIsAllowedToBeLoaded(AFnm, TempDenyReason) then                                      //isflDisk=0, isflMem=1
      Result := AOnActionPlugin_LoadBitmap(APluginReference, @AFnm[1], ADestBmp, Ord(AFileLocation), @HandleOnFileContent)
    else
      Result := False;
  end;

  function LoadBitmapAsStream(AFnm: string; AMemStream: TMemoryStream; AFileLocation: TImageSourceFileNameLocation): Boolean;
  var
    TempDenyReason: string;
  begin
    if BitmapIsAllowedToBeLoaded(AFnm, TempDenyReason) then                                      //isflDisk=0, isflMem=1
      Result := AOnActionPlugin_LoadBitmap(APluginReference, @AFnm[1], AMemStream, Ord(AFileLocation), @HandleOnFileContentAsRawStream)
    else
    begin
      AddToLog('Bitmap is not allowed to be loaded: "' + AFnm + '"   ' + TempDenyReason);
      Result := False;
    end;
  end;

  procedure GenerateSomeResultImg;
  var
    TempBmp, BkBmp: TBitmap;
    TempStream: TMemoryStream;
  begin
    TempBmp := TBitmap.Create;
    BkBmp := TBitmap.Create;
    TempStream := TMemoryStream.Create;
    try
      TempBmp.Width := 700;
      TempBmp.Height := 400;
      TempBmp.Canvas.Brush.Color := clBlack;
      TempBmp.Canvas.Pen.Color := clBlack;

      if LoadBitmap(ExtractFilePath(ParamStr(0)) + 'Tests\TestFiles\Gradient30deg.bmp', BkBmp, isflDisk) then
        TempBmp.Canvas.Draw(50, 25, BkBmp);

      TempBmp.Canvas.Font.Color := clYellow;
      TempBmp.Canvas.Font.Name := 'Courier New';
      TempBmp.Canvas.TextOut(30, 10, 'Plugin done.');

      TempBmp.SaveToStream(TempStream);
      AOnActionPlugin_SetResultImg(APluginReference, 0, 0, 0, TempStream.Memory, TempStream.Size, TempBmp.Width, TempBmp.Height);
    finally
      TempStream.Free;
      TempBmp.Free;
      BkBmp.Free;
    end;
  end;

  procedure SaveBitmapToExtRenderingInMemFS;
  var
    Bmp: TBitmap;
    MemStream: TMemoryStream;
  begin
    Bmp := TBitmap.Create;
    MemStream := TMemoryStream.Create;
    try
      Bmp.Width := 150;
      Bmp.Height := 180;
      Bmp.PixelFormat := pf24bit;
      Bmp.Canvas.Brush.Color := clBlack;
      Bmp.Canvas.Font.Color := clYellow;
      Bmp.Canvas.TextOut(50, 60, 'Generated bitmap');
      Bmp.Canvas.TextOut(50, 130, 'Generated bitmap');
      bmp.SaveToStream(MemStream);

      AOnActionPlugin_SetBitmap(APluginReference, @string('GenBmp.bmp')[1], MemStream.Memory, MemStream.Size, Bmp.Width, Bmp.Height);
    finally
      Bmp.Free;
      MemStream.Free;
    end;
  end;

  //var
  //  SplitActions: array of TClkFindControlOptions;

  function HashFoundInFileCacheInfo(AFileCacheInfo: TStringList; AHash: string): Boolean;
  var
    i: Integer;
    s: string;
  begin
    Result := False;

    for i := 0 to AFileCacheInfo.Count - 1 do
    begin
      s := AFileCacheInfo.Strings[i];
      s := Copy(s, Pos(CDefaultInMemFileNameHashSeparator, s) + Length(CDefaultInMemFileNameHashSeparator), MaxInt);

      if s = AHash then
      begin
        Result := True;
        Break;
      end;
    end;
  end;

  procedure OpenWorkerArchivesForAddingBitmaps(AArchiveHandlers: TArchiveHandlers);
  var
    i: Integer;
  begin
    for i := 0 to Length(AllWorkers) - 1 do
    begin
      AllWorkers[i].Archive.OpenArchive(AllWorkers[i].ArchiveStream, True);
      AllWorkers[i].Archive.OnCompress := AArchiveHandlers.HandleOnCompress;
      AllWorkers[i].Archive.OnDecompress := AArchiveHandlers.HandleOnDecompress;
      AllWorkers[i].Archive.OnComputeArchiveHash := AArchiveHandlers.HandleOnComputeArchiveHash;
      AllWorkers[i].Archive.Password := '';

      AllWorkers[i].Archive.CompressionLevel := 9 * Ord(UsingCompression);
    end;

    BkArchive.OpenArchive(BkArchiveStream, True);
    BkArchive.OnCompress := AArchiveHandlers.HandleOnCompress;
    BkArchive.OnDecompress := AArchiveHandlers.HandleOnDecompress;
    BkArchive.OnComputeArchiveHash := AArchiveHandlers.HandleOnComputeArchiveHash;
    BkArchive.Password := '';

    BkArchive.CompressionLevel := 9 * Ord(UsingCompression);
  end;


  function AddBackgroundBitmapToWorkerArchives(AImageSource, AImageSourceFileNameLocation, ASourceFileName: string; out ABackgroundSize: Int64; out ABackgroundWidth, ABackgroundHeight: Integer): Boolean;
  var
    TempBk: TMemoryStream;
    BkFileNameLocation: TImageSourceFileNameLocation;
    BkHash: string;
    TempBmp: TBitmap;
  begin
    ABackgroundSize := -2; //init with something
    ABackgroundWidth := 1;
    ABackgroundHeight := 1;

    if AImageSource = '0' then  //isScreenshot
    begin
      AddToLog('----------- ImageSource is a screenshot. Taking the screenshot, using the settings from ' + PluginSettings.ValueFromIndex[CFindSubControlActionPropertyIndex] + ' action.');
      AOnActionPlugin_Screenshot(APluginReference, @string(PluginSettings.ValueFromIndex[CFindSubControlActionPropertyIndex])[1]);
      AddToLog('----------- The screenshot should be found in in-mem FS, as ' + CScreenshotFilename);
      ASourceFileName := CScreenshotFilename;
    end;

    BkFileNameLocation := TImageSourceFileNameLocation(StrToIntDef(AImageSourceFileNameLocation, 1));

    AddToLog('----------- loading background bitmap as stream and adding it to archive...');
    TempBk := TMemoryStream.Create;
    try
      if LoadBitmapAsStream(ASourceFileName, TempBk, BkFileNameLocation) then
      begin
        ABackgroundSize := TempBk.Size;
        BkHash := ComputeHash(TempBk.Memory, TempBk.Size);
        BkArchive.AddFromStream(CBackgroundFileNameInArchive, TempBk);

        TempBmp := TBitmap.Create;
        try
          TempBk.Position := 0;
          TempBmp.LoadFromStream(TempBk);
          ABackgroundWidth := TempBmp.Width;
          ABackgroundHeight := TempBmp.Height;
          AddToLog('----------- Background size: ' + IntToStr(TempBmp.Width) + ' : ' + IntToStr(TempBmp.Height));
        finally
          TempBmp.Free;
        end;
      end
      else
      begin
        ABackgroundSize := 0;
        AddToLog('----------- LoadBitmapAsStream is False. Probably the file does not exist: ' + ASourceFileName);
        Result := False;
        Exit;
      end;
    finally
      TempBk.Free;
    end;
  end;


  procedure AddBitmapsToWorkerArchives;
  var
    i, j: Integer;
    TempFilesToSend: TStringList;
    TempMemFile: TMemoryStream;
  begin
    for i := 0 to Length(AllWorkers) - 1 do
    begin
      TempFilesToSend := TStringList.Create;
      try
        TempFilesToSend.LineBreak := #13#10;
        TempFilesToSend.Text := AllWorkers[i].FilesToSend;

        for j := 0 to TempFilesToSend.Count - 1 do
        begin
          TempMemFile := TMemoryStream.Create;
          try
            AddToLog('----------- loading bitmap as stream: "' + TempFilesToSend.Strings[j] + '" and adding it to archive.');
            if LoadBitmapAsStream(TempFilesToSend.Strings[j], TempMemFile, isflDisk) then
            begin
              AllWorkers[i].Archive.AddFromStream(TempFilesToSend.Strings[j], TempMemFile);
              AddToLog('----------- Added "' + TempFilesToSend.Strings[j] + '" to archive, of ' + IntToStr(TempMemFile.Size) + 'bytes in size.');
            end
            else
            begin
              FLatestMsg := 'Error loading bitmap as stream: "' + TempFilesToSend.Strings[j] + '".';
              AddToLog('----------- ' + FLatestMsg + '  Either the file is not allowed to be loaded or it doesn''t exist.');
            end;
          finally
            TempMemFile.Free;
          end;
        end; //for j

        TempMemFile := TMemoryStream.Create;
        try
          TempMemFile.Write(VarsForWorkers_Names[1], Length(VarsForWorkers_Names));
          AllWorkers[i].Archive.AddFromStream(CVarsForWorkersInArchive_Names, TempMemFile);
          TempMemFile.Clear;

          TempMemFile.Write(VarsForWorkers_Values[1], Length(VarsForWorkers_Values));
          AllWorkers[i].Archive.AddFromStream(CVarsForWorkersInArchive_Values, TempMemFile);
          TempMemFile.Clear;

          TempMemFile.Write(VarsForWorkers_EvalBefore[1], Length(VarsForWorkers_EvalBefore));
          AllWorkers[i].Archive.AddFromStream(CVarsForWorkersInArchive_EvalBefore, TempMemFile);
        finally
          TempMemFile.Free;
        end;
      finally
        TempFilesToSend.Free;
      end;
    end; //for i
  end;


  function FontExistsInList(AFontName, AListOfFontsStr: string): Boolean;
  var
    ListOfFonts: TStringList;
  begin
    ListOfFonts := TStringList.Create;
    try
      ListOfFonts.LineBreak := #13#10;
      ListOfFonts.Text := FastReplace_45ToReturn(AListOfFontsStr);
      Result := ListOfFonts.IndexOf(AFontName) > -1;
    finally
      ListOfFonts.Free;
    end;
  end;


  function CompFuncByTaskCount(const a, b: Int64): Integer;
  begin
    try
      if AllWorkers[a].TxtCntW < AllWorkers[b].TxtCntW then
        Result := -1
      else
        if AllWorkers[a].TxtCntW = AllWorkers[b].TxtCntW then
          Result := 0
        else
          Result := 1;
    except
      Result := -1;
      AddToLog('Ex on CompFuncByTaskCount  a = ' + IntToStr(a) + '  b = ' + IntToStr(b) + '  Len(AllWorkers) = ' + IntToStr(Length(AllWorkers)));
    end;
  end;


  type
    TCompFunc = function(const a, b: Int64): Integer;

  procedure CustomSortByTaskCount(var AArr: TIntArr; ACmpFunc: TCompFunc);
  var
    SortingArray: TInt64List;
    i: Integer;
  begin
    SortingArray := TInt64List.Create;
    try
      SortingArray.Capacity := Length(AArr);
      for i := 0 to Length(AArr) - 1 do
        SortingArray.Add(AArr[i]);

      SortingArray.Sort(@ACmpFunc);

      for i := 0 to Length(AArr) - 1 do
        AArr[i] := SortingArray.Items[i];
    finally
      SortingArray.Free;
    end;
  end;


  procedure SortByTaskCount(var AArr: TIntArr);
  begin
    CustomSortByTaskCount(AArr, @CompFuncByTaskCount);
  end;


  procedure AssignTasksToWorkers(AMaxSplitActionsCount: Integer; AListOfBmps, AListOfPmtvs: TStringList; var AFindSubControlOptions: TClkFindSubControlOptions);
  var
    i, j: Integer;
    WorkersIndex, StartIndex: Integer;
    WorkersMatchingOS: TIntArr; //each item is an index in the AllWorkers array
    WorkersMatchingFonts: TIntArr; //this is a subset of WorkersMatchingOS, based on what fonts are available on every worker
  begin
    Randomize;

    if Length(AllWorkers) > 0 then
    begin
      AddToLog('Splitting work from ' + IntToStr(AMaxSplitActionsCount) + ' (max) task(s).');

      //Filter, based on RequestedTextRenderingOS.  - property at CTextRenderingOSPropertyIndex index
      SetLength(WorkersMatchingOS, 0);
      for i := 0 to Length(AllWorkers) - 1 do
        if Pos(AllWorkers[i].OS, RequestedTextRenderingOS) > 0 then    //RequestedTextRenderingOS can be 'Win', 'Lin', 'Win+Lin'.
        begin
          SetLength(WorkersMatchingOS, Length(WorkersMatchingOS) + 1);
          WorkersMatchingOS[Length(WorkersMatchingOS) - 1] := i;
        end;

      //Filter, based on available fonts.
      for i := 0 to Length(AFindSubControlOptions.MatchBitmapText) - 1 do
      begin
        SetLength(WorkersMatchingFonts, 0);
        for j := 0 to Length(WorkersMatchingOS) - 1 do
          if FontExistsInList(AFindSubControlOptions.MatchBitmapText[i].FontName, AllWorkers[WorkersMatchingOS[j]].Fonts) then
          begin
            SetLength(WorkersMatchingFonts, Length(WorkersMatchingFonts) + 1);
            WorkersMatchingFonts[Length(WorkersMatchingFonts) - 1] := WorkersMatchingOS[j];
          end;

        //Here, WorkersMatchingFonts is sorted based on AllWorkers[WorkersMatchingFonts[k]].TxtCntW;  where, k goes from 0 to Length(WorkersMatchingFonts)
        SortByTaskCount(WorkersMatchingFonts);

        //Allocate:
        if Length(WorkersMatchingFonts) > 0 then
        begin
          WorkersIndex := WorkersMatchingFonts[0];  //since the WorkersMatchingFonts is sorted, the first item should point to the worker with the least number of allocated tasks
          AllWorkers[WorkersIndex].WorkerSpecificTask := AllWorkers[WorkersIndex].WorkerSpecificTask + 'Txt_' + IntToStr(i) + '=1&';  //i is the profile index
          Inc(AllWorkers[WorkersIndex].TxtCntW);
        end;
      end;

      Sleep(33);
      Randomize;
      StartIndex := Random(Length(AllWorkers));
      for i := 0 to AMaxSplitActionsCount - 1 do //Length(SplitActions) - 1 do         //AMaxSplitActionsCount includes text profiles. This might require some changes.
      begin
        //WorkersIndex := i mod Length(AllWorkers);
        WorkersIndex := (i + StartIndex) mod Length(AllWorkers);  //simple load balancing

        //Worker allocation, for bmp and Pmtv should also take into account the worker OS and the plugin setting.

        if i < AListOfBmps.Count then
        begin
          AllWorkers[WorkersIndex].WorkerSpecificTask := AllWorkers[WorkersIndex].WorkerSpecificTask + 'Bmp_' + IntToStr(i) + '=1&';
          AllWorkers[WorkersIndex].FilesToSend := AllWorkers[WorkersIndex].FilesToSend + AListOfBmps.Strings[i] + #13#10;
          Inc(AllWorkers[WorkersIndex].BmpCntW);
        end;

        if i < AListOfPmtvs.Count then
        begin
          AllWorkers[WorkersIndex].WorkerSpecificTask := AllWorkers[WorkersIndex].WorkerSpecificTask + 'Pmtv_' + IntToStr(i) + '=1&';
          AllWorkers[WorkersIndex].FilesToSend := AllWorkers[WorkersIndex].FilesToSend + AListOfPmtvs.Strings[i] + #13#10;
          Inc(AllWorkers[WorkersIndex].PmtvCntW);
        end;
      end;

      for i := 0 to Length(AllWorkers) - 1 do
        AllWorkers[i].WorkerSpecificTask := 'TxtCnt' + '=' + IntToStr(AllWorkers[i].TxtCntW) + '&' +
                                            'BmpCnt' + '=' + IntToStr(AllWorkers[i].BmpCntW) + '&' +
                                            'PmtvCnt' + '=' + IntToStr(AllWorkers[i].PmtvCntW) + '&' +
                                            AllWorkers[i].WorkerSpecificTask;
    end;
  end;

  procedure CloseWorkerArchives;
  var
    i: Integer;
  begin
    for i := 0 to Length(AllWorkers) - 1 do
    begin
      try
        //AddToLog('----------- closing archive at index ' + IntToStr(i));
        AllWorkers[i].CompressionTime := GetTickCount64;
        try
          AllWorkers[i].Archive.CloseArchive;
        finally
          AllWorkers[i].CompressionTime := GetTickCount64 - AllWorkers[i].CompressionTime;
        end;
      except
        on E: Exception do
        begin
          FLatestMsg := 'Error closing archive at index ' + IntToStr(i) + '.  Ex: ' + E.Message;
          AddToLog('----------- ' + FLatestMsg);
          Result := False;
        end;
      end;
    end;

    try
      BkCompressionTime := GetTickCount64;
      try
        BkArchive.CloseArchive;
      finally
        BkCompressionTime := GetTickCount64 - BkCompressionTime;
      end;
    except
      on E: Exception do
      begin
        FLatestMsg := 'Error closing archive with background image.  Ex: ' + E.Message;
        AddToLog('----------- ' + FLatestMsg);
        Result := False;
      end;
    end;
  end;

  function GetFindSubControlContent: Boolean;
  const
    CWillMatchBitmapText = 'WillMatchBitmapText'; //0..1
    CWillMatchBitmapFiles = 'WillMatchBitmapFiles'; //0..1
    CWillMatchPrimitiveFiles = 'WillMatchPrimitiveFiles'; //0..1
    CTxtProfilesCount_PropName = 'MatchBitmapText.Count';
    CBmpFiles_PropName = 'MatchBitmapFiles';     // #4#5 separated paths
    CPmtvFiles_PropName = 'MatchPrimitiveFiles'; // #4#5 separated paths
    CPrecisionTimeout_PropName = 'PrecisionTimeout';
    CFullBackgroundImageInResult_PropName = 'FullBackgroundImageInResult';
    CGetAllControls_PropName = 'GetAllControls';
  var
    ActionContentStr: string;
    ActionContentPtr: Pointer;
    ActionContentLen: DWord;
    i, WorkersIndex: Integer;
    ListOfFindSubControlProperties, ListOfBmps, ListOfPmtvs: TStringList;
    MaxSplitActionsCount, TxtCount: Integer;
    DecodedAction: TClkFindSubControlOptions;
    DecodingErr: string;
    ActionOptions: TClkActionOptions;
    TempBkStr: string;
    TempArchiveHandlers: TArchiveHandlers;
    BkSize: Int64;
    BackgroundWidth, BackgroundHeight: Integer;
  begin
    Result := True;

    SetLength(ActionContentStr, CMaxSharedStringLength + 1);
    ActionContentPtr := @ActionContentStr[1];
    AOnActionPlugin_GetActionContentByIndex(APluginReference, IndexOfFindSubControlActionProperty, ActionContentPtr, @ActionContentLen);
    SetLength(ActionContentStr, ActionContentLen);

    //AddToLog('ActionContentStr: ' + #13#10 + ActionContentStr);
    //
    ListOfFindSubControlProperties := TStringList.Create;
    try
      ListOfFindSubControlProperties.LineBreak := #13#10;
      ListOfFindSubControlProperties.Text := StringReplace(ActionContentStr, '&', #13#10, [rfReplaceAll]);
      //for i := 0 to ListOfFindSubControlProperties.Count - 1 do
      //  AddToLog('===Prop: ' + ListOfFindSubControlProperties.Strings[i]);

      if ListOfFindSubControlProperties.Values[CPrecisionTimeout_PropName] <> '1' then
      begin
        FLatestMsg := 'Error: Bad action configuration. This plugin requires that the "PrecisionTimeout" property of the configured FindSubControl action, to be set to True.';
        AddToLog(FLatestMsg);
        Result := False;
        Exit;
      end;

      GetAllControls := ListOfFindSubControlProperties.Values[CGetAllControls_PropName] = '1';

      if ListOfFindSubControlProperties.Values[CFullBackgroundImageInResult_PropName] <> '0' then
        AddToLog('Warning: The "' + CFullBackgroundImageInResult_PropName + '" property, of the configured FindSubControl action, is set to True. This will cause resulted debugging images to have full size, which will take longer to be compressed and transferred.');

      TxtCount := StrToIntDef(ListOfFindSubControlProperties.Values[CTxtProfilesCount_PropName], 0);
      MaxSplitActionsCount := TxtCount;

      ListOfBmps := TStringList.Create;
      ListOfPmtvs := TStringList.Create;
      TempArchiveHandlers := TArchiveHandlers.Create;

      for i := 0 to Length(AllWorkers) - 1 do
      begin
        AllWorkers[i].ArchiveStream := TMemoryStream.Create;
        AllWorkers[i].Archive := TMemArchive.Create;
        //AllWorkers[i].ResponseBitmapStream := TMemoryStream.Create;   //do not create here
      end;
      BkArchiveStream := TMemoryStream.Create;
      BkArchive := TMemArchive.Create;

      try
        ListOfBmps.LineBreak := #13#10;
        ListOfPmtvs.LineBreak := #13#10;

        ListOfBmps.Text := FastReplace_45ToReturn(ListOfFindSubControlProperties.Values[CBmpFiles_PropName]);
        MaxSplitActionsCount := Max(MaxSplitActionsCount, ListOfBmps.Count);

        ListOfPmtvs.Text := FastReplace_45ToReturn(ListOfFindSubControlProperties.Values[CPmtvFiles_PropName]);
        MaxSplitActionsCount := Max(MaxSplitActionsCount, ListOfPmtvs.Count);

        DecodingErr := SetFindSubControlActionProperties(ListOfFindSubControlProperties, nil, DecodedAction, ActionOptions);
        if DecodingErr <> '' then
        begin
          AddToLog('--- Action decoding errror: ' + DecodingErr);
          //SetLength(SplitActions, 0);
          MaxSplitActionsCount := 0; /////////////////////////////////// added later (to prevent indexing an empty SplitActions array), not sure if ok
        end
        else
          ;//SetLength(SplitActions, MaxSplitActionsCount);


        //The number of available workers can be less than, equal to or greater than the number of subproperties.
        //The number of some subproperties can be less than, other can be greater than.
        //If the number of all subproperty types is less than the number of workers, then the last remaining workers won't receive work.
        //Otherwise (if it's greater), then some workers will receive more work.
        //Delete from every action if the subproperty index is greater than MaxSplitActionsCount

        AssignTasksToWorkers(MaxSplitActionsCount, ListOfBmps, ListOfPmtvs, DecodedAction);

        UsingCompression := PluginSettings.ValueFromIndex[CUseCompressionPropertyIndex] = 'True';
        if UsingCompression then
        begin
          TempArchiveHandlers.CompressionAlgorithm := TCompressionAlgorithm(Ord(PluginSettings.ValueFromIndex[CCompressionAlgorithmPropertyIndex] = CCompressionAlgorithms[caLzma]));  //default min max

          if TempArchiveHandlers.CompressionAlgorithm = caLzma then
            TempArchiveHandlers.LzmaOptions := FillInLzmaOptionsFromPluginProperties(PluginSettings);
        end;

        BackgroundWidth := -3;  //Values used for debugging. Do not change.
        BackgroundHeight := -3;

        TempArchiveHandlers.OnAddToLogNoObj := @AddToLog;
        OpenWorkerArchivesForAddingBitmaps(TempArchiveHandlers);   //creates new archive on BkArchiveStream
        try
          //for cropping, the following properties have to be read from ListOfFindSubControlProperties
          //InitialRectangle_Left
          //InitialRectangle_LeftOffset
          //Top, Right, Bottom

          if not AddBackgroundBitmapToWorkerArchives(ListOfFindSubControlProperties.Values['ImageSource'],
                                                     ListOfFindSubControlProperties.Values['ImageSourceFileNameLocation'],
                                                     ListOfFindSubControlProperties.Values['SourceFileName'],
                                                     BkSize,
                                                     BackgroundWidth,
                                                     BackgroundHeight) then
          begin
            FLatestMsg := 'Error loading background bitmap as stream.';
            AddToLog('----------- ' + FLatestMsg);
            Result := False;
            Exit;
          end;

          if ListOfFindSubControlProperties.Values['ImageSource'] = '0' then //screenshot
          begin
            DecodedAction.InitialRectangle.Left := '0';
            DecodedAction.InitialRectangle.Top := '0';
            DecodedAction.InitialRectangle.Right := IntToStr(BackgroundWidth);        //This fixes one problem and creates another.
            DecodedAction.InitialRectangle.Bottom := IntToStr(BackgroundHeight);      //HandleOnScreenshotByActionName , from UIClicker does extra cropping, based on InitialRectangle.<##>Offset fields.
            ActionContentStr := GetFindSubControlActionProperties(DecodedAction);     //The screenshot should not be cropped.
            AddToLog('Updated the search limits from the initial request, to fit the screenshot.  BackgroundWidth = ' + IntToStr(BackgroundWidth) + '  BackgroundHeight = ' + IntToStr(BackgroundHeight));
          end
          else
            AddToLog('Image source is "' + ListOfFindSubControlProperties.Values['ImageSource'] + '". The search limits remain as they are.');

          AddBitmapsToWorkerArchives;
        finally
          CloseWorkerArchives;
        end;

        if UsingCompression then
        begin
          AddToLog('-----------');
          AddToLog('----------- The following ratio calculation is close to accurate, only if a single file is added to archive:');
          AddToLog('----------- Background bitmap size: ' + IntToStr(BkSize) + '  Compressed size: ' + IntToStr(BkArchiveStream.Size) + '   Ratio: ' + FloatToStr(BkSize / BkArchiveStream.Size) + '    CompressionTime: ' + FloatToStrF(BkCompressionTime / 1000, ffNumber, 15, 3) + 's.');
        end
        else
          AddToLog('----------- Not using compression. Background bitmap size: ' + IntToStr(BkSize) + '  Compressed size: ' + IntToStr(BkArchiveStream.Size));

        if Length(AllWorkers) > 0 then
        begin
          SetLength(AllWorkerBackgroundBmpStr, BkArchiveStream.Size);
          BkArchiveStream.Position := 0;
          BkArchiveStream.Read(AllWorkerBackgroundBmpStr[1], BkArchiveStream.Size);

          if BkArchiveStream.Size = 0 then
            BkArchiveStream.Write(string('1')[1], 1);  //prevent division by 0

          AllWorkerBackgroundBmpStr := CProtocolParam_UsingCompression + '=' + IntToStr(Ord(UsingCompression)) +
                             '&' + CProtocolParam_CompressionAlgorithm + '=' + CCompressionAlgorithms[TempArchiveHandlers.CompressionAlgorithm] +
                            '&' + CProtocolParam_ImageSourceRawContent + '=' + AllWorkerBackgroundBmpStr;

          for i := 0 to Length(AllWorkers) - 1 do
          begin
            SetLength(TempBkStr, AllWorkers[i].ArchiveStream.Size);
            AllWorkers[i].ArchiveStream.Position := 0;
            AllWorkers[i].ArchiveStream.Read(TempBkStr[1], AllWorkers[i].ArchiveStream.Size);

            if AllWorkers[i].ArchiveStream.Size = 0 then
              AllWorkers[i].ArchiveStream.Write(string('1')[1], 1);  //prevent division by 0

            AllWorkers[i].WorkerActionContentStr := ActionContentStr +
                                '&' + CPropertyName_ActionTimeout + '=' + IntToStr(Max(CMinFindSubControlActionTimeout, FindSubControlWorkerTimeout - FindSubControlTimeoutDiff)) +
                                '&' + AllWorkers[i].WorkerSpecificTask +
                                '&' + CProtocolParam_UsingCompression + '=' + IntToStr(Ord(UsingCompression)) +
                                '&' + CProtocolParam_CompressionAlgorithm + '=' + CCompressionAlgorithms[TempArchiveHandlers.CompressionAlgorithm] +
                                '&' + CProtocolParam_ImageSourceRawContent + '=' + TempBkStr;  //it is possible that the MQTT server won't allow big files to be sent in one piece
          end;
        end  //if Length(AllWorkers) > 0 then
        else
        begin
          FLatestMsg := 'No workers available. (A worker application might still be running, but it may be busy.)';
          AddToLog('----------- ' + FLatestMsg);
          Result := False;
        end;
      finally
        ListOfBmps.Free;
        ListOfPmtvs.Free;
        TempArchiveHandlers.Free;

        for i := 0 to Length(AllWorkers) - 1 do
        begin
          FreeAndNil(AllWorkers[i].ArchiveStream);
          FreeAndNil(AllWorkers[i].Archive);
          //FreeAndNil(AllWorkers[i].ResponseBitmapStream); //do not destroy here
        end;

        FreeAndNil(BkArchiveStream);
        FreeAndNil(BkArchive);
      end;
    finally
      ListOfFindSubControlProperties.Free;
      AddToLog('----------- Exiting GetFindSubControlContent with ' + BoolToStr(Result, 'True', 'False') + '.');
    end;
  end;  //GetFindSubControlContent

var
  i: Integer;
  TempResponseVars: TResponseVars;

begin
  Result := False;
  DebugPoint := @DbgPoint;
  SetLength(AllWorkers, 0);
  FLatestMsg := 'Error message not set.';

  try
    IdTCPClient1 := TIdTCPClient.Create;
    RecTh := nil;
    FRecBufFIFO := TPollingFIFO.Create;
    TempPluginMQTTClientHandlers := TPluginMQTTClientHandlers.Create(nil);
    PluginSettings := TStringList.Create;
    try
      PluginSettings.LineBreak := #13#10;
      DefaultOnActionPlugin_DebugPoint := AOnActionPlugin_DebugPoint;
      DefaultPluginReference := APluginReference;
      AddToLogCallback := AOnActionPlugin_AddToLog;
      ActionPlugin_InMemFSCallback := AOnActionPlugin_InMemFS;
      ActionPlugin_ExecuteActionallback := AOnActionPlugin_ExecuteAction;
      GPluginReference := APluginReference;

      if FLatestMsg <> '' then
        FLatestMsg := FLatestMsg + ' +++ Error: This plugin hasn''t been unloaded successfully on previous execution.';

      FLatestMsg := FLatestMsg + ' /// Starting plugin...';
      AddToLog(FLatestMsg);
      FLatestMsg := '';

      IdTCPClient1.OnConnected := TempPluginMQTTClientHandlers.HandleClientOnConnected;
      IdTCPClient1.OnDisconnected := TempPluginMQTTClientHandlers.HandleClientOnDisconnected;

      if not DbgPoint('Entering ExecutePlugin', '') then     //see ClkDbgSym.ppr for expected statement formats
        Exit;

      ActionCount := AOnActionPlugin_GetActionCount(APluginReference);
      if ActionCount = 0 then
      begin
        SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, 'This plugin does not run on an empty template.');
        Exit;
      end;

      PluginSettingsStr := GetPluginSettings;
      PluginSettings.Text := PluginSettingsStr;

      if PluginSettings.Count <> CPropertiesCount then
      begin
        SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, 'Cannot get the list of plugin properties.');
        Exit;
      end;

      GetAllTemplateVars(AllVarsStr);
      GetPluginSettingsFromProperties(PluginSettings, AllVarsStr);

      s := 'unset action';
      IndexOfFindSubControlActionProperty := -1;
      for i := 0 to ActionCount - 1 do
      begin
        GetActionInfoByIndex(i, s, ActionTypeDWord);
        AddToLog('Found action [' + IntToStr(i) + ']: ' + s);

        if ActionTypeDWord <> $FFFFFFFF then
        begin
          ActionType := TClkAction(ActionTypeDWord);

          if ActionType in [acFindSubControl, acPlugin] then
            if s = PluginSettings.ValueFromIndex[CFindSubControlActionPropertyIndex] then   //the current action name ([i]) matches FindSubControl property
            begin
              IndexOfFindSubControlActionProperty := i;
              Break;
            end;
        end;
      end;

      if IndexOfFindSubControlActionProperty = -1 then
      begin
        SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, 'FindSubControl action not configured.');
        Exit;
      end;

      WorkerQoS := StrToIntDef(PluginSettings.ValueFromIndex[CWorkerQoSPropertyIndex], 2);
      WorkerQoS := Min(Max(WorkerQoS, 1), 2);  //limited to 1..2

      GetWorkerCapabilitiesTimeout := StrToIntDef(PluginSettings.ValueFromIndex[CGetWorkerCapabilitiesTimeoutPropertyIndex], 2);
      GetWorkerCapabilitiesTimeout := Min(Max(GetWorkerCapabilitiesTimeout, 50), 60000);  //limited to 50..60000

      FindSubControlWorkerTimeout := StrToIntDef(PluginSettings.ValueFromIndex[CFindSubControlWorkerTimeoutPropertyIndex], 2);
      FindSubControlWorkerTimeout := Min(Max(FindSubControlWorkerTimeout, 50), 60000);  //limited to 50..60000

      FindSubControlTimeoutDiff := StrToIntDef(PluginSettings.ValueFromIndex[CFindSubControlTimeoutDiffPropertyIndex], 2500);
      FindSubControlTimeoutDiff := Min(Max(FindSubControlTimeoutDiff, 1500), 60000);  //limited to 50..60000

      WorkerCapabilitiesSource := PluginSettings.ValueFromIndex[CWorkerCapabilitiesSourcePropertyIndex];
      UpdateCacheActionName := PluginSettings.ValueFromIndex[CSaveWorkerCapabilitiesCacheActionPropertyIndex];
      LoadCacheActionName := PluginSettings.ValueFromIndex[CLoadWorkerCapabilitiesCacheActionPropertyIndex];
      RequestedTextRenderingOS := PluginSettings.ValueFromIndex[CTextRenderingOSPropertyIndex];

      SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, '');

      Application.Initialize;
      FExHandler := TExHandler.Create;
      ExceptProc := @CatchUnhandledException;
      Application.OnException := FExHandler.CustomExceptionHandler;

      MQTT_Init;
      FSMError := '';
      State := SInit;

      if MQTT_CreateClient then
      begin
        try
          InitHandlers;

          repeat
            ExecFSM;

            if State = SGetFindSubControlActionContent then
            begin
              try
                if not GetFindSubControlContent then
                begin
                  AddToLog('Stopping FSM, because GetFindSubControlContent returned False.');
                  FSMDone := True;
                end;
              except
                on EFSM: Exception do
                begin
                  FSMError := FSMError + 'Stopping FSM, because GetFindSubControlContent raised an exception: ' + EFSM.Message;
                  AddToLog(FSMError);
                  FSMDone := True;
                end;
              end;
            end;

            try
              Application.ProcessMessages;
            except
              on E: Exception do
                AddToLog('-----------  Ex on FSM loop: ' + E.Message);
            end;

            if AOnActionPlugin_CheckStopAllActionsOnDemand(APluginReference) then
            begin
              FLatestMsg := 'Stopping plugin on demand...';
              AddToLog(FLatestMsg);
              Result := False;
              Exit;
            end;

            Sleep(1);
          until FSMDone;

          AddToLog('-----------  Exiting FSM');
        finally
          AddToLog('Last FSM state: ' + CFSMStr[State]);
          MQTT_DestroyClient(0);
          AddToLog('Client module destroyed successfully...');
        end;
      end
      else
      begin
        AddToLog('Can''t create client...');
        Result := False;
        Exit;
      end;

      TempPluginMQTTClientHandlers.tmrProcessRecData.Enabled := False;
      AddToLog('Stopped MQTT timer...');

      Result := DisconnectedSuccessfully;

      if FSMError <> '' then
      begin
        Result := False;
        FLatestMsg := FSMError;
      end;
    finally
      try
        Application.ProcessMessages; //process last logging data

        //ToDo: set these vars only when their values are known

        if (WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndGetFonts) or
           (WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndGetFontsAndFindSubControl) then
        begin
          SetTemplateVar('$WorkerCount$', IntToStr(Length(AllWorkers)));
          for i := 0 to Length(AllWorkers) - 1 do
          begin
            SetTemplateVar('$Worker[' + IntToStr(i) + '].Name$', AllWorkers[i].Name);
            SetTemplateVar('$Worker[' + IntToStr(i) + '].OS$', AllWorkers[i].OS);
            SetTemplateVar('$Worker[' + IntToStr(i) + '].Fonts$', AllWorkers[i].Fonts);  //it is possible that on a subsequent run, the workers come up in a different order, so this info will be outdated
            SetTemplateVar('$Worker[' + IntToStr(i) + '].ExtraName$', AllWorkers[i].ExtraName);
          end;
        end;

        if not Result then
          SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, FLatestMsg)
        else
        begin
          for i := 0 to Length(AllWorkers) - 1 do
            if AllWorkers[i].FindSubControlFound then
            begin
              SetTemplateVar('$Control_Left$', AllWorkers[i].ResponseVars.ControlLeft);
              SetTemplateVar('$Control_Top$', AllWorkers[i].ResponseVars.ControlTop);
              SetTemplateVar('$Control_Right$', AllWorkers[i].ResponseVars.ControlRight);
              SetTemplateVar('$Control_Bottom$', AllWorkers[i].ResponseVars.ControlBottom);

              SetTemplateVar('$Control_Width$', AllWorkers[i].ResponseVars.ControlWidth);
              SetTemplateVar('$Control_Height$', AllWorkers[i].ResponseVars.ControlHeight);
              SetTemplateVar('$Half_Control_Width$', AllWorkers[i].ResponseVars.HalfControlWidth);
              SetTemplateVar('$Half_Control_Height$', AllWorkers[i].ResponseVars.HalfControlHeight);

              SetTemplateVar('$DebugVar_SubCnvXOffset$', AllWorkers[i].ResponseVars.SubCnvXOffset);
              SetTemplateVar('$DebugVar_SubCnvYOffset$', AllWorkers[i].ResponseVars.SubCnvYOffset);

              if GetAllControls then
              begin
                TempResponseVars.AllControl_Handles := TempResponseVars.AllControl_Handles + AllWorkers[i].ResponseVars.AllControl_Handles;
                TempResponseVars.AllControl_XOffsets := TempResponseVars.AllControl_XOffsets + AllWorkers[i].ResponseVars.AllControl_XOffsets;
                TempResponseVars.AllControl_YOffsets := TempResponseVars.AllControl_YOffsets + AllWorkers[i].ResponseVars.AllControl_YOffsets;

                //ToDo: somehow, fix the index of each AllControl_MatchSource array item, for MatchSource and DetailedMatchSource, to be [0], [1], [2]...
                //This has to match text/bmp/pmtv profile index
                TempResponseVars.AllControl_MatchSource := TempResponseVars.AllControl_MatchSource + AllWorkers[i].ResponseVars.AllControl_MatchSource;
                TempResponseVars.AllControl_DetailedMatchSource := TempResponseVars.AllControl_DetailedMatchSource + AllWorkers[i].ResponseVars.AllControl_DetailedMatchSource;
                TempResponseVars.AllControl_ResultedErrorCount := TempResponseVars.AllControl_ResultedErrorCount + AllWorkers[i].ResponseVars.AllControl_ResultedErrorCount;

                TempResponseVars.AllControl_Lefts := TempResponseVars.AllControl_Lefts + AllWorkers[i].ResponseVars.AllControl_Lefts;
                TempResponseVars.AllControl_Tops := TempResponseVars.AllControl_Tops + AllWorkers[i].ResponseVars.AllControl_Tops;
                TempResponseVars.AllControl_Rights := TempResponseVars.AllControl_Rights + AllWorkers[i].ResponseVars.AllControl_Rights;
                TempResponseVars.AllControl_Bottoms := TempResponseVars.AllControl_Bottoms + AllWorkers[i].ResponseVars.AllControl_Bottoms;

                TempResponseVars.AllControl_Widths := TempResponseVars.AllControl_Widths + AllWorkers[i].ResponseVars.AllControl_Widths;
                TempResponseVars.AllControl_Heights := TempResponseVars.AllControl_Heights + AllWorkers[i].ResponseVars.AllControl_Heights;
                TempResponseVars.AllHalfControl_Widths := TempResponseVars.AllHalfControl_Widths + AllWorkers[i].ResponseVars.AllHalfControl_Widths;
                TempResponseVars.AllHalfControl_Heights := TempResponseVars.AllHalfControl_Heights + AllWorkers[i].ResponseVars.AllHalfControl_Heights;
              end;
            end;

          if GetAllControls then
          begin
            SetTemplateVar('$AllControl_Handles$', TempResponseVars.AllControl_Handles);
            SetTemplateVar('$AllControl_XOffsets$', TempResponseVars.AllControl_XOffsets);
            SetTemplateVar('$AllControl_YOffsets$', TempResponseVars.AllControl_YOffsets);

            //ToDo: somehow, fix the index of each AllControl_MatchSource array item, for MatchSource and DetailedMatchSource, to be [0], [1], [2]...
            //This has to match text/bmp/pmtv profile index
            SetTemplateVar('$AllControl_MatchSource$', TempResponseVars.AllControl_MatchSource);
            SetTemplateVar('$AllControl_DetailedMatchSource$', TempResponseVars.AllControl_DetailedMatchSource);
            SetTemplateVar('$AllControl_ResultedErrorCount$', TempResponseVars.AllControl_ResultedErrorCount);

            SetTemplateVar('$AllControl_Lefts$', TempResponseVars.AllControl_Lefts);
            SetTemplateVar('$AllControl_Tops$', TempResponseVars.AllControl_Tops);
            SetTemplateVar('$AllControl_Rights$', TempResponseVars.AllControl_Rights);
            SetTemplateVar('$AllControl_Bottoms$', TempResponseVars.AllControl_Bottoms);

            SetTemplateVar('$AllControl_Widths$', TempResponseVars.AllControl_Widths);
            SetTemplateVar('$AllControl_Heights$', TempResponseVars.AllControl_Heights);
            SetTemplateVar('$AllHalf_Control_Widths$', TempResponseVars.AllHalfControl_Widths);
            SetTemplateVar('$AllHalf_Control_Heights$', TempResponseVars.AllHalfControl_Heights);
          end;
        end;
      except
      end;

      FreeAndNil(IdTCPClient1);
      FreeAndNil(FRecBufFIFO);
      FreeAndNil(TempPluginMQTTClientHandlers);
      FreeAndNil(PluginSettings);


      if Length(AllWorkers) = 0 then
      begin
        GenerateSomeResultImg;
        AddToLog('No available workers for result image.');
      end
      else
        if AllWorkers[0].ResponseBitmapStream.Size = 0 then
        begin
          GenerateSomeResultImg;
          AddToLog('Worker[0] returned an empty result image.');
        end
        else
        begin
          AOnActionPlugin_SetResultImg(APluginReference, 0, 0, 0, AllWorkers[0].ResponseBitmapStream.Memory, AllWorkers[0].ResponseBitmapStream.Size, -1, -1);
          FreeAndNil(AllWorkers[0].ResponseBitmapStream);
          AddToLog('Result image set from worker[0].');
        end;


      try
        for i := 0 to Length(AllWorkers) - 1 do
          FreeAndNil(AllWorkers[i].FileCacheInfo);
      except
        on E: Exception do
          AddToLog('Cannot free FileCacheInfo at index ' + IntToStr(i));
      end;


      FLatestMsg := 'Cleaning up all worker info...';
      AddToLog(FLatestMsg);
      SetTemplateVar(CActionPlugin_DebuggingVar, FLatestMsg);
      SetLength(AllWorkers, 0);

      if RecTh <> nil then
        FreeAndNil(RecTh);
    end;

    SaveBitmapToExtRenderingInMemFS;

    FLatestMsg := 'Exiting plugin...';
    AddToLog(FLatestMsg);
    SetTemplateVar(CActionPlugin_DebuggingVar, FLatestMsg);

    //AOnActionPlugin_Screenshot(APluginReference, @string('ScreenshotSettings')[1]);
  except
    on E: Exception do
      SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, 'Plugin exception: "' + E.Message + '".');
  end;
end;


exports
  GetAPIVersion,
  GetListOfProperties,
  ExecutePlugin;

begin
end.

