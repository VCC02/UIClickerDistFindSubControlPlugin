{
    Copyright (C) 2025 VCC
    creation date: 17 Mar 2024
    initial release date: 19 May 2024

    author: VCC
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}


library UIClickerDistFindSubControl;

{$H+}
{$IFDEF FPC}
  {$MODE Delphi}
{$ENDIF}

uses
  Windows,
  Interfaces, Classes, SysUtils, Graphics, ExtCtrls, Forms, Math, IdTCPClient,
  DistFindSubControlDM, ImgList, TplZlibUnit, TplLzmaUnit, IntegerList,
  IdGlobal, ClickerUtils, ClickerExtraUtils, ClickerActionPlugins, DllUtils,
  ClickerFileProviderUtils, DynArrays, PollingFIFO, InMemFileSystem,
  DistFindSubControlCommonConsts, ClickerIniFiles, ClickerActionProperties,

  ClickerTemplates, MQTTClient, MQTTUtils, MQTTConnectCtrl, MQTTSubscribeCtrl,
  MQTTUnsubscribeCtrl, MemArchive, DistFindSubControlPluginProperties,
  ClickerPluginInMemFileSystem, ClickerPrimitives,
  DistFindSubControlPropertyEditorForm, FontSorting;

type
  //TStringArr = array of string;

  //TArrayOfString = array[0..0] of string;
  //PArrayOfString = ^TArrayOfString;
  //TArrayOfEnumStrings = array[0..0] of PArrayOfString;
  //PArrayOfEnumStrings = ^TArrayOfEnumStrings;


  //TDbgPoint = function(APointName, ALogMsg: string): Boolean;


  TMQTTReceiveThread = class(TThread)
  private
    FDone: Boolean;
    procedure AddMsgToLog(s: string);
  protected
    procedure Execute; override;
  end;


  TFSM = (SInit, SConnectToBroker, SWaitForConAck,
          SSubscribeToResponses, SWaitForResponsesSubAck,   //Responses can be capabilities, lists of missing files, processing results
          SRequestCapabilities, SWaitForCapabilitiesResponse,
          SGetFindSubControlActionContent,
          SPublishBackgroundImageToAllWorkers, SWaitForBackgroundImageResults,
          SPublishFindSubControlToAllWorkers, SWaitForFindSubControlResults,  //in addition to FindSubControl action details, the publish contains a list of assigned work info for every worker, so they know what exactly to work on
          SGetListOfFonts, SWaitForListOfFonts,
          SUpdateCache, SLoadCache,
          SDisconnectFromBroker,
          SDone
         );

  TPluginMQTTClientHandlers = class(TComponent)
  private
    tmrProcessRecData: TTimer;

    procedure tmrProcessRecDataTimer(Sender: TObject);

    procedure HandleClientOnConnected(Sender: TObject);
    procedure HandleClientOnDisconnected(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
  end;


const
  CFSMStr: array[TFSM] of string = (
          'SInit', 'SConnectToBroker', 'SWaitForConAck',
          'SSubscribeToResponses', 'SWaitForResponsesSubAck',
          'SRequestCapabilities', 'SWaitForCapabilitiesResponse',
          'SGetFindSubControlActionContent',
          'SPublishBackgroundImageToAllWorkers', 'SWaitForBackgroundImageResults',
          'SPublishFindSubControlToAllWorkers', 'SWaitForFindSubControlResults',
          'SGetListOfFonts', 'SWaitForListOfFonts',
          'SUpdateCache', 'SLoadCache',
          'SDisconnectFromBroker',
          'SDone'
          );

 CNoWorkerFoundSubControlErr = 'None of the responding workers found the SubControl.';
 CNoWorkerMatchesOSErr = 'None of the responding workers matches the selected target OS.';

var
  IdTCPClient1: TIdTCPClient;
  FRecBufFIFO: TPollingFIFO; //used by the reading thread to pass data to MQTT library
  //DebugPoint: TDbgPoint;
  AtLeastOneWorkerFoundTheSubControl: Boolean;
  WorkerRespondedCountBG: Word; //Background
  WorkerRespondedCountFS: Word; //FindSubControl
  FLatestMsg: string = '';
  ConnectedSucessfully, ConAckReceived, SubAckReceived, SubscribedSucessfully, DisconnectedSuccessfully: Boolean;
  WaitingForWorkerCapabilities: Boolean;
  WaitingForWorkerFonts: Boolean;
  FSMDone: Boolean;
  AllWorkers: TWorkerArr;
  AllWorkerBackgroundBmpStr: string;

  BkArchiveStream: TMemoryStream;
  BkArchive: TMemArchive;
  BkCompressionTime: QWord;   //for statistics only

  AddToLogCallback: TOnActionPlugin_AddToLog;
  ActionPlugin_InMemFSCallback: TOnActionPlugin_InMemFS;
  ActionPlugin_ExecuteActionCallback: TOnActionPlugin_ExecuteAction;
  ActionPlugin_AppProcMsgCallback: TOnActionPlugin_AppProcMsg;
  GPluginReference: Pointer;

  FindSubControlActionPropertyValue: string;
  CredentialsFullFileNamePropertyValue: string;  //for connection to broker
  AddressPropertyValue: string;
  PortPropertyValue: string;
  VarsForWorkers_Names, VarsForWorkers_Values, VarsForWorkers_EvalBefore: string;
  UpdateCacheActionName, LoadCacheActionName: string;

  GetAllControls: Boolean;
  WorkerQoS: Integer;
  GetWorkerCapabilitiesTimeout: Integer;
  FindSubControlWorkerTimeout: Integer;
  FSMError: string;
  FindSubControlTimeoutDiff: Integer;
  WorkerCapabilitiesSource: string; //set by property at CWorkerCapabilitiesSourcePropertyIndex
  RequestedTextRenderingOS: string;
  FindSubControlFonts: TClkFindControlMatchBitmapTextArr = nil; //used for sorting
  FontsUsedByPmtvs: TStringArray;  //used for sorting and task allocation
  DisplayExtraDebuggingInfo: Boolean;
  EvaluateFileNameBeforeSending: Boolean;
  UsingCustomFontProfiles: Boolean;
  CustomProfilesFnm: string;
  MinExpectedWorkerCount: Integer;

  RequestIDCnt: Integer;
  GetCapabilitiesRequestID: string;
  SendBackgroundToAllRequestID: string;

  RecTh: TMQTTReceiveThread;

  State, NextState: TFSM;
  tk: QWord; //used for timeouts
  VerbLevel: Integer;        //0 = low-level MQTT logging, 1 = Dist plugin general logging, 2 = Dist plugin important logging.
                             //error messages are displayed regardless of this value


procedure AddToLog(AMsg: string);  //thread safe
begin
  if @AddToLogCallback <> nil then
    AddToLogCallback(DefaultPluginReference, @AMsg[1]);
end;


procedure AppProcMsg;
begin
  if @ActionPlugin_AppProcMsgCallback <> nil then
    ActionPlugin_AppProcMsgCallback(DefaultPluginReference)
  else
    raise Exception.Create('ActionPlugin_AppProcMsgCallback not assigned.');
end;

//
//function DbgPoint(APointName, ALogMsg: string): Boolean;
//begin
//  if @DefaultOnActionPlugin_DebugPoint <> nil then
//    Result := DefaultOnActionPlugin_DebugPoint(DefaultPluginReference, @APointName[1], @ALogMsg[1])
//  else
//    Result := True;
//end;


procedure GetCredentials(ACredentialsFilePath: string; out AUsername, APassword: string);
var
  Ini: TClkIniReadonlyFile;
begin
  Ini := TClkIniReadonlyFile.Create(ACredentialsFilePath);
  try
    AUsername := Ini.ReadString('Credentials', 'Username', '');
    APassword := Ini.ReadString('Credentials', 'Password', '');
  finally
    Ini.Free;
  end;
end;


procedure GetCredentialsFromInMemFS(ACredentialsFilePath: string; APluginReference: Pointer; AOnActionPlugin_InMemFS: TOnActionPlugin_InMemFS; out AUsername, APassword: string);
var
  Ini: TClkIniReadonlyFile;
  PluginInMemFS: TPluginInMemFileSystem;
  Content: TMemoryStream;
begin
  AddToLog('Loading credentials file from ' + ACredentialsFilePath);

  PluginInMemFS := TPluginInMemFileSystem.Create;
  try
    Content := TMemoryStream.Create;
    try
      PluginInMemFS.PluginReference := APluginReference;
      if PluginInMemFS.FileExistsInMem(AOnActionPlugin_InMemFS, ACredentialsFilePath) then
      begin
        Content.SetSize(PluginInMemFS.GetFileSize(AOnActionPlugin_InMemFS, ACredentialsFilePath));
        AddToLog('Credentials file size: ' + IntToStr(Content.Size));
        PluginInMemFS.LoadFileFromMem(AOnActionPlugin_InMemFS, ACredentialsFilePath, Content.Memory);

        Ini := TClkIniReadonlyFile.Create(Content);
        try
          AUsername := Ini.ReadString('Credentials', 'Username', '');
          APassword := Ini.ReadString('Credentials', 'Password', '');

          //AddToLog('Username: ' + AUsername + '  Password: ' + APassword);  //for debugging only
        finally
          Ini.Free;
        end;
      end
      else
      begin
        AUsername := 'not found';
        APassword := 'not found';
      end;
    finally
      Content.Free;
    end;
  finally
    PluginInMemFS.Free;
  end;
end;


procedure SyncReceivedBuffer(var AReadBuf: TDynArrayOfByte); //thread safe
begin
  FRecBufFIFO.Put(DynArrayOfByteToString(AReadBuf));
end;


procedure ProcessReceivedBuffer;  //called by a timer, to process received data
var
  TempReadBuf: TDynArrayOfByte;
  NewData: string;
begin
  if FRecBufFIFO.Pop(NewData) then
  begin
    InitDynArrayToEmpty(TempReadBuf);
    try
      if StringToDynArrayOfByte(NewData, TempReadBuf) then
      begin
        MQTT_PutReceivedBufferToMQTTLib(0, TempReadBuf);
        MQTT_Process(0);
      end
      else
        AddToLog('Out of memory in ProcessReceivedBuffer.');
    finally
      FreeDynArray(TempReadBuf);
    end;
  end;
end;


procedure SendDynArrayOfByte(AArr: TDynArrayOfByte);
var
  TempArr: TIdBytes;
begin
  //AddToLog('============Sending: ' + StringReplace(DynArrayOfByteToString(AArr), #0, #1, [rfReplaceAll]));
  SetLength(TempArr, AArr.Len);
  Move(AArr.Content^, TempArr[0], AArr.Len);
  IdTCPClient1.IOHandler.Write(TempArr);
end;


procedure SendPacketToServer(ClientInstance: DWord);
var
  BufferPointer: PMQTTBuffer;
  Err: Word;
begin
  BufferPointer := MQTT_GetClientToServerBuffer(ClientInstance, Err){$IFnDEF SingleOutputBuffer}^.Content^[0]{$ENDIF};
  SendDynArrayOfByte(BufferPointer^);

  {$IFnDEF SingleOutputBuffer}
    if not MQTT_RemovePacketFromClientToServerBuffer(ClientInstance) then
      AddToLog('Can''t remove latest packet from send buffer.');
  {$ELSE}
    raise Exception.Create('MQTT_RemovePacketFromClientToServerBuffer no implemented for SingleOutputBuffer.');
  {$ENDIF}
end;


procedure HandleOnMQTTError(ClientInstance: DWord; AErr: Word; APacketType: Byte);
var
  PacketTypeStr: string;
begin
  MQTTPacketToString(APacketType, PacketTypeStr);
  AddToLog('Client: ' + IntToHex(ClientInstance, 8) + '  Err: $' + IntToHex(AErr) + '  PacketType: $' + IntToHex(APacketType) + ' (' + PacketTypeStr + ').');  //The error is made of an upper byte and a lower byte.

  if Hi(AErr) = CMQTT_Reason_NotAuthorized then   // $87
  begin
    FLatestMsg := 'MQTT broker error: Not authorized.';
    AddToLog(FLatestMsg);
    if APacketType = CMQTT_CONNACK then
      AddToLog('             on receiving CONNACK.');
  end;

  if Lo(AErr) = CMQTT_PacketIdentifierNotFound_ClientToServer then   // $CE
    AddToLog('Client error: PacketIdentifierNotFound.');
end;


procedure HandleOnSend_MQTT_Packet(ClientInstance: DWord; APacketType: Byte);
var
  PacketName: string;
begin
  MQTTPacketToString(APacketType, PacketName);

  if VerbLevel < 1 then
    AddToLog('Sending ' + PacketName + ' packet...');

  try
    SendPacketToServer(ClientInstance);
  except
    on E: Exception do
      AddToLog('Cannot send ' + PacketName + ' packet... Ex: ' + E.Message);
  end;
end;


function HandleOnBeforeMQTT_CONNECT(ClientInstance: DWord;  //The lower byte identifies the client instance (the library is able to implement multiple MQTT clients / device). The higher byte can identify the call in user handlers for various events (e.g. TOnBeforeMQTT_CONNECT).
                                    var AConnectFields: TMQTTConnectFields;                    //user code has to fill-in this parameter
                                    var AConnectProperties: TMQTTConnectProperties;
                                    ACallbackID: Word): Boolean;
var
  TempWillProperties: TMQTTWillProperties;
  UserName, Password: string;
  //ClientId: string;
  //Id: Char;
  ConnectFlags: Byte;
  EnabledProperties: Word;
begin
  Result := True;

  if VerbLevel < 1 then
    AddToLog('Preparing CONNECT data..');

  //Id := Chr((ClientInstance and $FF) + 48);
  //ClientId := 'MyClient' + Id;

  if Pos('Mem:\', CredentialsFullFileNamePropertyValue) = 1 then
    GetCredentialsFromInMemFS(CredentialsFullFileNamePropertyValue, GPluginReference, ActionPlugin_InMemFSCallback, UserName, Password)
  else
    GetCredentials(CredentialsFullFileNamePropertyValue, UserName, Password);

  //StringToDynArrayOfByte(ClientId, AConnectFields.PayloadContent.ClientID);
  StringToDynArrayOfByte(UserName, AConnectFields.PayloadContent.UserName);
  StringToDynArrayOfByte(Password, AConnectFields.PayloadContent.Password);

  ConnectFlags := CMQTT_UsernameInConnectFlagsBitMask or
                  CMQTT_PasswordInConnectFlagsBitMask or
                  CMQTT_CleanStartInConnectFlagsBitMask {or
                  CMQTT_WillQoSB1InConnectFlagsBitMask};

  EnabledProperties := CMQTTConnect_EnSessionExpiryInterval or
                       CMQTTConnect_EnMaximumPacketSize or
                       CMQTTConnect_EnRequestResponseInformation or
                       CMQTTConnect_EnRequestProblemInformation {or
                       CMQTTConnect_EnAuthenticationMethod or
                       CMQTTConnect_EnAuthenticationData};

  MQTT_InitWillProperties(TempWillProperties);
  TempWillProperties.WillDelayInterval := 30; //some value
  TempWillProperties.PayloadFormatIndicator := 1;  //0 = do not send.  1 = UTF-8 string
  TempWillProperties.MessageExpiryInterval := 3600;
  StringToDynArrayOfByte('SomeType', TempWillProperties.ContentType);
  StringToDynArrayOfByte('SomeTopicName', TempWillProperties.ResponseTopic);
  StringToDynArrayOfByte('MyCorrelationData', TempWillProperties.CorrelationData);
  AddStringToDynOfDynArrayOfByte('Key=Value', TempWillProperties.UserProperty);
  AddStringToDynOfDynArrayOfByte('NewKey=NewValue', TempWillProperties.UserProperty);

  FillIn_PayloadWillProperties(TempWillProperties, AConnectFields.PayloadContent.WillProperties);
  MQTT_FreeWillProperties(TempWillProperties);
  StringToDynArrayOfByte('WillTopic', AConnectFields.PayloadContent.WillTopic);

  //Please set the Will Flag in ConnectFlags below, then uncomment above code, if "Will" properties are required.
  AConnectFields.ConnectFlags := ConnectFlags;  //bits 7-0:  User Name, Password, Will Retain, Will QoS, Will Flag, Clean Start, Reserved
  AConnectFields.EnabledProperties := EnabledProperties;
  AConnectFields.KeepAlive := 0; //any positive values require pinging the server if no other packet is being sent

  AConnectProperties.SessionExpiryInterval := 3600; //[s]
  AConnectProperties.ReceiveMaximum := 7000;
  AConnectProperties.MaximumPacketSize := 10 * 1024 * 1024;
  AConnectProperties.TopicAliasMaximum := 100;
  AConnectProperties.RequestResponseInformation := 1;
  AConnectProperties.RequestProblemInformation := 1;
  AddStringToDynOfDynArrayOfByte('UserProp=Value', AConnectProperties.UserProperty);
  StringToDynArrayOfByte('SCRAM-SHA-1', AConnectProperties.AuthenticationMethod);       //some example from spec, pag 108   the server may add to its log: "bad AUTH method"
  StringToDynArrayOfByte('client-first-data', AConnectProperties.AuthenticationData);   //some example from spec, pag 108

  if VerbLevel < 1 then
  begin
    AddToLog('Done preparing CONNECT data..');
    AddToLog('');
  end;
end;


procedure HandleOnAfterMQTT_CONNACK(ClientInstance: DWord; var AConnAckFields: TMQTTConnAckFields; var AConnAckProperties: TMQTTConnAckProperties);
begin
  ConAckReceived := True;

  if VerbLevel < 1 then
  begin
    AddToLog('Received CONNACK');

    //AddToLog('ConnAckFields.EnabledProperties: ' + IntToStr(AConnAckFields.EnabledProperties));
    //AddToLog('ConnAckFields.SessionPresentFlag: ' + IntToStr(AConnAckFields.SessionPresentFlag));
    //AddToLog('ConnAckFields.ConnectReasonCode: ' + IntToStr(AConnAckFields.ConnectReasonCode));  //should be 0
    //
    //AddToLog('SessionExpiryInterval: ' + IntToStr(AConnAckProperties.SessionExpiryInterval));
    //AddToLog('ReceiveMaximum: ' + IntToStr(AConnAckProperties.ReceiveMaximum));
    //AddToLog('MaximumQoS: ' + IntToStr(AConnAckProperties.MaximumQoS));
    //AddToLog('RetainAvailable: ' + IntToStr(AConnAckProperties.RetainAvailable));

    if AConnAckFields.EnabledProperties and CMQTTConnAck_EnMaximumPacketSize = CMQTTConnAck_EnMaximumPacketSize then
      AddToLog('MaximumPacketSize received: ' + IntToStr(AConnAckProperties.MaximumPacketSize))
    else
      AddToLog('MaximumPacketSize unknown: ' + IntToStr(AConnAckProperties.MaximumPacketSize));


    //AddToLog('AssignedClientIdentifier: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.AssignedClientIdentifier), #0, '#0', [rfReplaceAll]));
    //AddToLog('TopicAliasMaximum: ' + IntToStr(AConnAckProperties.TopicAliasMaximum));
    //AddToLog('ReasonString: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.ReasonString), #0, '#0', [rfReplaceAll]));
    //AddToLog('UserProperty: ' + StringReplace(DynOfDynArrayOfByteToString(AConnAckProperties.UserProperty), #0, '#0', [rfReplaceAll]));
    //AddToLog('WildcardSubscriptionAvailable: ' + IntToStr(AConnAckProperties.WildcardSubscriptionAvailable));
    //AddToLog('SubscriptionIdentifierAvailable: ' + IntToStr(AConnAckProperties.SubscriptionIdentifierAvailable));
    //AddToLog('SharedSubscriptionAvailable: ' + IntToStr(AConnAckProperties.SharedSubscriptionAvailable));
    //AddToLog('ServerKeepAlive: ' + IntToStr(AConnAckProperties.ServerKeepAlive));
    //AddToLog('ResponseInformation: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.ResponseInformation), #0, '#0', [rfReplaceAll]));
    //AddToLog('ServerReference: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.ServerReference), #0, '#0', [rfReplaceAll]));
    //AddToLog('AuthenticationMethod: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.AuthenticationMethod), #0, '#0', [rfReplaceAll]));
    //AddToLog('AuthenticationData: ' + StringReplace(DynArrayOfByteToString(AConnAckProperties.AuthenticationData), #0, '#0', [rfReplaceAll]));
    //
  end;

  ///////////////////////////////////////// when the server returns SessionPresentFlag set to 1, the library resends unacknowledged Publish and PubRel packets.
  //AConnAckFields.SessionPresentFlag := 1;
end;


function HandleOnBeforeSendingMQTT_SUBSCRIBE(ClientInstance: DWord;  //The lower word identifies the client instance
                                             var ASubscribeFields: TMQTTSubscribeFields;
                                             var ASubscribeProperties: TMQTTSubscribeProperties;
                                             ACallbackID: Word): Boolean;
var
  Options, QoS: Byte;
  SubId: Word;
begin
  Options := 0;
  QoS := 2;

  Options := Options or QoS; //bits 1 and 0
  //Bit 2 of the Subscription Options represents the No Local option.  - spec pag 73
  //Bit 3 of the Subscription Options represents the Retain As Published option.  - spec pag 73
  //Bits 4 and 5 of the Subscription Options represent the Retain Handling option.  - spec pag 73
  //Bits 6 and 7 of the Subscription Options byte are reserved for future use. - Must be set to 0.  - spec pag 73

                                                                            //Subscription identifiers are not mandatory (per spec).
  SubId := MQTT_CreateClientToServerSubscriptionIdentifier(ClientInstance); //This function has to be called here, in this handler only. The library does not call this function other than for init purposes.
                                                                            //If SubscriptionIdentifiers are used, then user code should free them when resubscribing or when unsubscribing.
  ASubscribeProperties.SubscriptionIdentifier := SubId;  //For now, the user code should keep track of these identifiers and free them on resubscribing or unsubscribing.

  if VerbLevel < 1 then
    AddToLog('Subscribing with new SubscriptionIdentifier: ' + IntToStr(SubId));

  Result := FillIn_SubscribePayload(CTopicName_WorkerToApp_GetCapabilities, Options, ASubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to ASubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_SUBSCRIBE not enough memory to add TopicFilters (GetCapabilities).');
    Exit;
  end;

  if VerbLevel < 1 then
    AddToLog('Subscribing to: ' + StringReplace(DynArrayOfByteToString(ASubscribeFields.TopicFilters), #0, '#0', [rfReplaceAll]));

  Result := FillIn_SubscribePayload(CTopicName_WorkerToApp_SendBackground, Options, ASubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to ASubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_SUBSCRIBE not enough memory to add TopicFilters (SendBackground).');
    Exit;
  end;

  Result := FillIn_SubscribePayload(CTopicName_WorkerToApp_FindSubControl, Options, ASubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to ASubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_SUBSCRIBE not enough memory to add TopicFilters (FindSubControl).');
    Exit;
  end;

  Result := FillIn_SubscribePayload(CTopicName_WorkerToApp_GetListOfFonts, Options, ASubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to ASubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_SUBSCRIBE not enough memory to add TopicFilters (GetListOfFonts).');
    Exit;
  end;


  //Enable SubscriptionIdentifier only if required (allocated above with CreateClientToServerSubscriptionIdentifier) !!!
  //The library initializes EnabledProperties to 0.
  //A subscription is allowed to be made without a SubscriptionIdentifier.
  ASubscribeFields.EnabledProperties := CMQTTSubscribe_EnSubscriptionIdentifier {or CMQTTSubscribe_EnUserProperty};

  if VerbLevel < 1 then
  begin
    AddToLog('Subscribing with PacketIdentifier: ' + IntToStr(ASubscribeFields.PacketIdentifier));
    AddToLog('Subscribing to: ' + StringReplace(DynArrayOfByteToString(ASubscribeFields.TopicFilters), #0, '#0', [rfReplaceAll]));

    AddToLog('');
  end;
end;


procedure HandleOnAfterReceivingMQTT_SUBACK(ClientInstance: DWord; var ASubAckFields: TMQTTSubAckFields; var ASubAckProperties: TMQTTSubAckProperties);
var
  i: Integer;
begin
  SubAckReceived := True;

  if VerbLevel < 1 then
  begin
    AddToLog('Received SUBACK');
    //AddToLog('ASubAckFields.IncludeReasonCode: ' + IntToStr(ASubAckFields.IncludeReasonCode));  //not used
    //AddToLog('ASubAckFields.ReasonCode: ' + IntToStr(ASubAckFields.ReasonCode));              //not used
    AddToLog('ASubAckFields.EnabledProperties: ' + IntToStr(ASubAckFields.EnabledProperties));
    AddToLog('ASubAckFields.PacketIdentifier: ' + IntToStr(ASubAckFields.PacketIdentifier));  //This must be the same as sent in SUBSCRIBE packet.

    AddToLog('ASubAckFields.Payload.Len: ' + IntToStr(ASubAckFields.SrcPayload.Len));

    for i := 0 to ASubAckFields.SrcPayload.Len - 1 do         //these are QoS values for each TopicFilter (if ok), or error codes (if not ok).
      AddToLog('ASubAckFields.ReasonCodes[' + IntToStr(i) + ']: ' + IntToStr(ASubAckFields.SrcPayload.Content^[i]));

    AddToLog('ASubAckProperties.ReasonString: ' + StringReplace(DynArrayOfByteToString(ASubAckProperties.ReasonString), #0, '#0', [rfReplaceAll]));
    AddToLog('ASubAckProperties.UserProperty: ' + StringReplace(DynOfDynArrayOfByteToString(ASubAckProperties.UserProperty), #0, '#0', [rfReplaceAll]));

    AddToLog('');
  end;
end;


function HandleOnBeforeSendingMQTT_UNSUBSCRIBE(ClientInstance: DWord;  //The lower word identifies the client instance
                                               var AUnsubscribeFields: TMQTTUnsubscribeFields;
                                               var AUnsubscribeProperties: TMQTTUnsubscribeProperties;
                                               ACallbackID: Word): Boolean;
begin
  Result := FillIn_UnsubscribePayload(CTopicName_WorkerToApp_GetCapabilities, AUnsubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to AUnsubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_UNSUBSCRIBE not enough memory to add TopicFilters.');
    Exit;
  end;

  Result := FillIn_UnsubscribePayload(CTopicName_WorkerToApp_SendBackground, AUnsubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to AUnsubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_UNSUBSCRIBE not enough memory to add TopicFilters.');
    Exit;
  end;

  Result := FillIn_UnsubscribePayload(CTopicName_WorkerToApp_FindSubControl, AUnsubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to AUnsubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_UNSUBSCRIBE not enough memory to add TopicFilters.');
    Exit;
  end;

  Result := FillIn_UnsubscribePayload(CTopicName_WorkerToApp_GetListOfFonts, AUnsubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to AUnsubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_UNSUBSCRIBE not enough memory to add TopicFilters.');
    Exit;
  end;

  if VerbLevel < 1 then
    AddToLog('Unsubscribing from "' + CTopicName_WorkerToApp_GetCapabilities + '" and "' +
                                      CTopicName_WorkerToApp_SendBackground + '" and "' +
                                      CTopicName_WorkerToApp_FindSubControl + '" and "' +
                                      CTopicName_WorkerToApp_GetListOfFonts + '"...'
                                      );

  //the user code should call RemoveClientToServerSubscriptionIdentifier to remove the allocate identifier.
end;


procedure HandleOnAfterReceivingMQTT_UNSUBACK(ClientInstance: DWord; var AUnsubAckFields: TMQTTUnsubAckFields; var AUnsubAckProperties: TMQTTUnsubAckProperties);
var
  i: Integer;
begin
  if VerbLevel < 1 then
  begin
    AddToLog('Received UNSUBACK');
    //AddToLog('AUnsubAckFields.IncludeReasonCode: ' + IntToStr(ASubAckFields.IncludeReasonCode));  //not used
    //AddToLog('AUnsubAckFields.ReasonCode: ' + IntToStr(ASubAckFields.ReasonCode));              //not used
    AddToLog('AUnsubAckFields.EnabledProperties: ' + IntToStr(AUnsubAckFields.EnabledProperties));
    AddToLog('AUnsubAckFields.PacketIdentifier: ' + IntToStr(AUnsubAckFields.PacketIdentifier));  //This must be the same as sent in SUBSCRIBE packet.

    AddToLog('AUnsubAckFields.Payload.Len: ' + IntToStr(AUnsubAckFields.SrcPayload.Len));

    for i := 0 to AUnsubAckFields.SrcPayload.Len - 1 do         //these are QoS values for each TopicFilter (if ok), or error codes (if not ok).
      AddToLog('AUnsubAckFields.ReasonCodes[' + IntToStr(i) + ']: ' + IntToStr(AUnsubAckFields.SrcPayload.Content^[i]));

    AddToLog('AUnsubAckProperties.ReasonString: ' + StringReplace(DynArrayOfByteToString(AUnsubAckProperties.ReasonString), #0, '#0', [rfReplaceAll]));
    AddToLog('AUnsubAckProperties.UserProperty: ' + StringReplace(DynOfDynArrayOfByteToString(AUnsubAckProperties.UserProperty), #0, '#0', [rfReplaceAll]));

    AddToLog('');
  end;
end;


//This handler is used when this client publishes a message to broker.
function HandleOnBeforeSendingMQTT_PUBLISH(ClientInstance: DWord;  //The lower word identifies the client instance (the library is able to implement multiple MQTT clients / device). The higher byte can identify the call in user handlers for various events (e.g. TOnBeforeMQTT_CONNECT).
                                           var APublishFields: TMQTTPublishFields;                    //user code has to fill-in this parameter
                                           var APublishProperties: TMQTTPublishProperties;            //user code has to fill-in this parameter
                                           ACallbackID: Word): Boolean;
var
  Msg: string;
  //QoS: Byte;
  TempWorkerSpecificTask: string;
  i: Integer;
  CurrentWorkerIndex: Byte;
begin
  Result := True;
  TempWorkerSpecificTask := 'Task not set.';

  case ACallbackID and $FF of
    CCallbackID_GetCapabilities:
    begin
      GetCapabilitiesRequestID := IntToStr(GetTickCount64) + '_' + IntToStr(RequestIDCnt);
      Inc(RequestIDCnt);

      Msg := CMQTT_AppToWorkerCmd_GetCapabilities + #13#10 + CProtocolParam_RequestID + '=' + GetCapabilitiesRequestID;
      TempWorkerSpecificTask := 'DebuggingString';
      Result := Result and StringToDynArrayOfByte(CTopicName_AppToWorker_GetCapabilities, APublishFields.TopicName);
      APublishFields.EnabledProperties := CMQTTPublish_EnContentType;

      if VerbLevel < 2 then
        AddToLog('Requesting worker capabilities...');
    end;

    CCallbackID_SendBackgroundToAll:
    begin
      SendBackgroundToAllRequestID := IntToStr(GetTickCount64) + '_' + IntToStr(RequestIDCnt);
      Inc(RequestIDCnt);

      Msg := CProtocolParam_RequestID + '=' + SendBackgroundToAllRequestID + '&' + AllWorkerBackgroundBmpStr;  //AllWorkerBackgroundBmpStr uses '&' instead of #13#10 and the last string is the background itself
      Result := Result and StringToDynArrayOfByte(CTopicName_AppToWorker_SendBackground, APublishFields.TopicName);

      if VerbLevel < 2 then
        AddToLog('Publishing SendBackground request to all workers...  Topic: ' + CTopicName_AppToWorker_SendBackground + '   Len(Msg): ' + IntToStr(Length(Msg)));

      //List of tasks for all workers. It can be an '&' separated list of WorkerName=TaskInfo, from all workers array.
      //The list separator has to be compatible with MQTT spec about UTF-8 encoding.
      //Every worker extracts its task from this array, based on its name.

      TempWorkerSpecificTask := 'DebuggingName:';
      APublishFields.EnabledProperties := CMQTTPublish_EnContentType;
    end;

    CCallbackID_SendBackgroundToSome:
    begin
      CurrentWorkerIndex := (ACallbackID shr 8) and $FF;  //assuming there are no more than 255 workers
      Msg := AllWorkerBackgroundBmpStr;
      Result := Result and StringToDynArrayOfByte(CTopicName_AppToWorker_SendBackground + '_' + AllWorkers[CurrentWorkerIndex].Name, APublishFields.TopicName);

      if VerbLevel < 2 then
        AddToLog('Publishing SendBackground request to worker[' + IntToStr(CurrentWorkerIndex) + ']...');

      //List of tasks for all workers. It can be an '&' separated list of WorkerName=TaskInfo, from all workers array.
      //The list separator has to be compatible with MQTT spec about UTF-8 encoding.
      //Every worker extracts its task from this array, based on its name.

      TempWorkerSpecificTask := 'DebuggingName:';
      APublishFields.EnabledProperties := CMQTTPublish_EnContentType;
    end;

    CCallbackID_SendFindSubControl:
    begin
      CurrentWorkerIndex := (ACallbackID shr 8) and $FF;  //assuming there are no more than 255 workers

      AllWorkers[CurrentWorkerIndex].FindSubControlRequestID := IntToStr(GetTickCount64) + '_' + IntToStr(RequestIDCnt);
      Inc(RequestIDCnt);

      Msg := CProtocolParam_RequestID + '=' + AllWorkers[CurrentWorkerIndex].FindSubControlRequestID + '&' + AllWorkers[CurrentWorkerIndex].WorkerActionContentStr;
      Result := Result and StringToDynArrayOfByte(CTopicName_AppToWorker_FindSubControl + '_' + AllWorkers[CurrentWorkerIndex].Name, APublishFields.TopicName);
      //AddToLog('---------------------------------- Sending FindSubControl request with ID: ' + AllWorkers[CurrentWorkerIndex].FindSubControlRequestID);

      if VerbLevel < 2 then
        AddToLog('Publishing FindSubControl request to worker[' + IntToStr(CurrentWorkerIndex) + ']...');

      //List of tasks for all workers. It can be an '&' separated list of WorkerName=TaskInfo, from all workers array.
      //The list separator has to be compatible with MQTT spec about UTF-8 encoding.
      //Every worker extracts its task from this array, based on its name.

      TempWorkerSpecificTask := 'DebuggingName:';
      for i := 0 to Length(AllWorkers) - 1 do
        TempWorkerSpecificTask := TempWorkerSpecificTask + AllWorkers[i].Name + {'='}CWorkerTaskAssignmentOperator + AllWorkers[i].WorkerSpecificTask {+ '&'} + CWorkerTaskLineBreak;

      APublishFields.EnabledProperties := CMQTTPublish_EnContentType;
    end;

    CCallbackID_GetListOfFonts:
    begin
      CurrentWorkerIndex := (ACallbackID shr 8) and $FF;  //assuming there are no more than 255 workers
      Msg := 'none'; //not a requirement so far
      Result := Result and StringToDynArrayOfByte(CTopicName_AppToWorker_GetListOfFonts, APublishFields.TopicName);

      if VerbLevel < 2 then
        AddToLog('Requesting GetListOfFonts from worker[' + IntToStr(CurrentWorkerIndex) + ']...');
    end;

    else
      Msg := 'UnhandledRequest';
  end;

  //QoS := (APublishFields.PublishCtrlFlags shr 1) and 3;
  //AddToLog('Publishing "' + Msg + '" at QoS = ' + IntToStr(QoS));  //commented, because Msg may contain bitmaps

  Result := Result and StringToDynArrayOfByte(Msg, APublishFields.ApplicationMessage);
  Result := Result and StringToDynArrayOfByte(TempWorkerSpecificTask, APublishProperties.ContentType);

  if VerbLevel < 2 then
    AddToLog('');
  //QoS can be overriden here. If users override QoS in this handler, then a a different PacketIdentifier might be allocated (depending on what is available)
end;


//This handler is used when this client publishes a message to broker and the broker responds with PUBACK.
procedure HandleOnBeforeSendingMQTT_PUBACK(ClientInstance: DWord; var APubAckFields: TMQTTPubAckFields; var APubAckProperties: TMQTTPubAckProperties);
begin
  if VerbLevel < 1 then
  begin
    AddToLog('Acknowledging with PUBACK');
    AddToLog('APubAckFields.EnabledProperties: ' + IntToStr(APubAckFields.EnabledProperties));
    AddToLog('APubAckFields.IncludeReasonCode: ' + IntToStr(APubAckFields.IncludeReasonCode));
    AddToLog('APubAckFields.PacketIdentifier: ' + IntToStr(APubAckFields.PacketIdentifier));
    AddToLog('APubAckFields.ReasonCode: ' + IntToStr(APubAckFields.ReasonCode));

    AddToLog('APubAckProperties.ReasonString: ' + StringReplace(DynArrayOfByteToString(APubAckProperties.ReasonString), #0, '#0', [rfReplaceAll]));
    AddToLog('APubAckProperties.UserProperty: ' + StringReplace(DynOfDynArrayOfByteToString(APubAckProperties.UserProperty), #0, '#0', [rfReplaceAll]));

    AddToLog('');
    //This handler can be used to override what is being sent to server as a reply to PUBLISH
  end;
end;


procedure HandleOnAfterReceivingMQTT_PUBACK(ClientInstance: DWord; var APubAckFields: TMQTTPubAckFields; var APubAckProperties: TMQTTPubAckProperties);
begin
  if VerbLevel < 1 then
  begin
    AddToLog('Received PUBACK');
    //AddToLog('APubAckFields.EnabledProperties: ' + IntToStr(APubAckFields.EnabledProperties));
    //AddToLog('APubAckFields.IncludeReasonCode: ' + IntToStr(APubAckFields.IncludeReasonCode));
    //AddToLog('APubAckFields.PacketIdentifier: ' + IntToStr(APubAckFields.PacketIdentifier));
    //AddToLog('APubAckFields.ReasonCode: ' + IntToStr(APubAckFields.ReasonCode));
    //
    //AddToLog('APubAckProperties.ReasonString: ' + StringReplace(DynArrayOfByteToString(APubAckProperties.ReasonString), #0, '#0', [rfReplaceAll]));
    //AddToLog('APubAckProperties.UserProperty: ' + StringReplace(DynOfDynArrayOfByteToString(APubAckProperties.UserProperty), #0, '#0', [rfReplaceAll]));
    AddToLog('');
  end;
end;


function GetAllWorkers_AtLeastOneFound: Boolean;
var
  i: Integer;
begin
  Result := False;
  for i := 0 to Length(AllWorkers) - 1 do
    if AllWorkers[i].ResponseReceived and AllWorkers[i].FindSubControlFound then
    begin
      Result := True;
      Break;
    end;
end;


function GetWorkerIndexByName(AWorkerName: string): Integer;
var
  i: Integer;
begin
  Result := -1;

  for i := 0 to Length(AllWorkers) - 1 do
    if AllWorkers[i].Name = AWorkerName then
    begin
      Result := i;
      Break;
    end;
end;


procedure AddNewWorkerToList(AName, AOS, AFileCacheInfoContent, AExtraName: string);
begin
  SetLength(AllWorkers, Length(AllWorkers) + 1);
  AllWorkers[Length(AllWorkers) - 1].Name := AName;
  AllWorkers[Length(AllWorkers) - 1].OS := AOS;
  AllWorkers[Length(AllWorkers) - 1].WorkerSpecificTask := '';
  AllWorkers[Length(AllWorkers) - 1].FileCacheInfo := TStringList.Create;
  AllWorkers[Length(AllWorkers) - 1].FileCacheInfo.LineBreak := #13#10;
  AllWorkers[Length(AllWorkers) - 1].FileCacheInfo.Text := AFileCacheInfoContent;
  AllWorkers[Length(AllWorkers) - 1].ExtraName := AExtraName;

  AllWorkers[Length(AllWorkers) - 1].FilesToSend := '';
  AllWorkers[Length(AllWorkers) - 1].BmpFilesToSend := '';
  AllWorkers[Length(AllWorkers) - 1].PmtvFilesToSend := '';
  AllWorkers[Length(AllWorkers) - 1].ArchiveStream := nil;   //created when required
  AllWorkers[Length(AllWorkers) - 1].Archive := nil;         //created when required

  AllWorkers[Length(AllWorkers) - 1].TxtCntW := 0;
  AllWorkers[Length(AllWorkers) - 1].BmpCntW := 0;
  AllWorkers[Length(AllWorkers) - 1].PmtvCntW := 0;

  AllWorkers[Length(AllWorkers) - 1].ResponseReceived := False;
  AllWorkers[Length(AllWorkers) - 1].FindSubControlFound := False;
  AllWorkers[Length(AllWorkers) - 1].Response := 'unset';

  AllWorkers[Length(AllWorkers) - 1].ResponseBitmapStream := TMemoryStream.Create; //created here, destroyed on returning to app

  AllWorkers[Length(AllWorkers) - 1].Fonts := '';
  AllWorkers[Length(AllWorkers) - 1].FindSubControlRequestID := 'NotSet';
end;


procedure SetWorkerResponseBitmapStream(AWorkerIndex: Integer; AArchiveAsResponseStr, AArchiveSizeStr: string);
var
  ArchiveStream: TMemoryStream;
  Archive: TMemArchive;
  TempArchiveHandlers: TArchiveHandlers;
begin
  if VerbLevel < 2 then
    AddToLog('Decoded response archive size: ' + IntToStr(Length(AArchiveAsResponseStr)));

  AArchiveAsResponseStr := Copy(AArchiveAsResponseStr, 1, StrToInt64Def(AArchiveSizeStr, Length(AArchiveAsResponseStr)));

  if VerbLevel < 2 then
    AddToLog('Received response archive size: ' + AArchiveSizeStr);

  AArchiveAsResponseStr := HexToString(AArchiveAsResponseStr);

  if VerbLevel < 2 then
    AddToLog('Received response raw archive size: ' + IntToStr(Length(AArchiveAsResponseStr)) + '   (* 2 = ' + IntToStr(Length(AArchiveAsResponseStr) shl 1) + ')');

  ArchiveStream := TMemoryStream.Create;
  Archive := TMemArchive.Create;
  TempArchiveHandlers := TArchiveHandlers.Create;
  try
    TempArchiveHandlers.OnAddToLogNoObj := @AddToLog;
    ArchiveStream.Write(AArchiveAsResponseStr[1], Length(AArchiveAsResponseStr));

    if VerbLevel < 2 then
    begin
      //AddToLog('First 10 archive bytes: "' + FastReplace_0To1(Copy(AArchiveAsResponseStr, 1, 10)));
      //AddToLog('Last 10 archive bytes: "' + FastReplace_0To1(Copy(AArchiveAsResponseStr, Length(AArchiveAsResponseStr) - 9, 10)));
      AddToLog('Computing Archive hash.. Size = ' + IntToStr(ArchiveStream.Size));
      try
        AddToLog('Archive hash: ' + ClickerExtraUtils.ComputeHash(ArchiveStream.Memory, ArchiveStream.Size));
      except
        on E: Exception do
          AddToLog('Ex on computing archive hash: ' + E.Message);
      end;
    end;

    Archive.OnCompress := TempArchiveHandlers.HandleOnCompress;
    Archive.OnDecompress := TempArchiveHandlers.HandleOnDecompress;
    Archive.OnComputeArchiveHash := TempArchiveHandlers.HandleOnComputeArchiveHash;

    try
      Archive.OpenArchive(ArchiveStream, False);
      try
        Archive.ExtractToStream(CResultFileNameInArchive, AllWorkers[AWorkerIndex].ResponseBitmapStream);
      finally
        Archive.CloseArchive;
      end;
    except
      on E: Exception do
        AddToLog('Ex on extracting archive: ' + E.Message);
    end;
  finally
    ArchiveStream.Free;
    Archive.Free;
    TempArchiveHandlers.Free;
  end;
end;


procedure HandleOnAfterReceivingMQTT_PUBLISH(ClientInstance: DWord; var APublishFields: TMQTTPublishFields; var APublishProperties: TMQTTPublishProperties);
var
  QoS: Byte;
  ID: Word;
  Topic, s, Msg: string;
  i: Integer;
  Content: TStringList;
  WorkerIndex: Integer;
  TempResponseArchiveStr: string;
  WorkerName: string;
  WorkerRequestID: string;
begin
  QoS := (APublishFields.PublishCtrlFlags shr 1) and 3;
  Msg := StringReplace(DynArrayOfByteToString(APublishFields.ApplicationMessage), #0, '#0', [rfReplaceAll]);
  ID := APublishFields.PacketIdentifier;
  Topic := StringReplace(DynArrayOfByteToString(APublishFields.TopicName), #0, '#0', [rfReplaceAll]);

  if VerbLevel < 1 then
    AddToLog('Received PUBLISH  ServerPacketIdentifier: ' + IntToStr(ID) +
                                                   '  Msg: ' + Copy(Msg, 1, Pos(CProtocolParam_ResultImageArchive + '=', Msg) - 1) +
                                                   '  QoS: ' + IntToStr(QoS) +
                                                   '  TopicName: ' + Topic);

  if VerbLevel < 2 then
  begin
    s := '';
    for i := 0 to APublishProperties.SubscriptionIdentifier.Len - 1 do
      s := s + IntToStr(APublishProperties.SubscriptionIdentifier.Content^[i]) + ', ';
    AddToLog('SubscriptionIdentifier(s): ' + s);
  end;

  Content := TStringList.Create;
  try
    Content.LineBreak := #13#10;
    Content.Text := Msg;
    WorkerName := Content.Values[CProtocolParam_Name];
    WorkerRequestID := Content.Values[CProtocolParam_RequestID];

    if Topic = CTopicName_WorkerToApp_GetCapabilities then
    begin
      if WaitingForWorkerCapabilities and (WorkerRequestID = GetCapabilitiesRequestID) then //This is True only for a short while (see the state machine below). Any worker which publishes after this, is ignored.
      begin
        AddToLog(DateTimeToStr(Now) + ' (' + IntToStr(GetTickCount64) + ')  Adding worker[' + IntToStr(Length(AllWorkers)) + '] to list: ' + WorkerName);
        AddNewWorkerToList(WorkerName,
                           Content.Values[CProtocolParam_OS],
                           FastReplace_45ToReturn(Content.Values[CProtocolParam_FileCache]), //#4#5 separated list of files. Each item uses the CDefaultInMemFileNameHashSeparator string between name and hash.
                           Content.Values[CProtocolParam_ExtraName]
                          );
      end
      else
        AddToLog(DateTimeToStr(Now) + ' (' + IntToStr(GetTickCount64) + ')  Worker ' + WorkerName + ' responded too late. It won''t be added to list. WorkerRequestID: ' + WorkerRequestID);
    end;


    if Topic = CTopicName_WorkerToApp_SendBackground then
      if WorkerRequestID = SendBackgroundToAllRequestID then
      begin
        WorkerIndex := GetWorkerIndexByName(WorkerName);
        if WorkerIndex = -1 then
          AddToLog('Error: cannot find worker "' + WorkerName + '" on receiving result.')
        else
        begin
          if Content.Values['$ExecAction_Err$'] = CBackgroundOKResponse then
          begin
            Inc(WorkerRespondedCountBG);

            if VerbLevel < 2 then
              AddToLog('Worker[' + IntToStr(WorkerIndex) + '] responded with success when sending background image.');
          end
          else
            AddToLog('Worker[' + IntToStr(WorkerIndex) + '] responded with error when sending background image: ' + Content.Values['$ExecAction_Err$']);
        end;
      end;

    if Topic = CTopicName_WorkerToApp_FindSubControl then
    begin
      WorkerIndex := GetWorkerIndexByName(WorkerName);
      if WorkerIndex = -1 then
        AddToLog('Error: cannot find worker "' + WorkerName + '" on receiving result.')
      else
      begin
        if WorkerRequestID = AllWorkers[WorkerIndex].FindSubControlRequestID then
        begin
          Inc(WorkerRespondedCountFS);
          AllWorkers[WorkerIndex].ResponseReceived := True;
          AllWorkers[WorkerIndex].Response := Content.Values['$ExecAction_Err$'];  /////////////// there is also CActionPlugin_ExecutionResultErrorVar, but the response is set to $ExecAction_Err$
          AllWorkers[WorkerIndex].FindSubControlFound := AllWorkers[WorkerIndex].Response = '';

          AllWorkers[WorkerIndex].ResponseVars.ControlLeft := Content.Values['$Control_Left$'];
          AllWorkers[WorkerIndex].ResponseVars.ControlTop := Content.Values['$Control_Top$'];
          AllWorkers[WorkerIndex].ResponseVars.ControlRight := Content.Values['$Control_Right$'];
          AllWorkers[WorkerIndex].ResponseVars.ControlBottom := Content.Values['$Control_Bottom$'];
          AllWorkers[WorkerIndex].ResponseVars.ControlWidth := Content.Values['$Control_Width$'];
          AllWorkers[WorkerIndex].ResponseVars.ControlHeight := Content.Values['$Control_Height$'];
          AllWorkers[WorkerIndex].ResponseVars.HalfControlWidth := Content.Values['$Half_Control_Width$'];
          AllWorkers[WorkerIndex].ResponseVars.HalfControlHeight := Content.Values['$Half_Control_Height$'];
          AllWorkers[WorkerIndex].ResponseVars.SubCnvXOffset := Content.Values['$DebugVar_SubCnvXOffset$'];
          AllWorkers[WorkerIndex].ResponseVars.SubCnvYOffset := Content.Values['$DebugVar_SubCnvYOffset$'];

          if GetAllControls then
          begin
            AllWorkers[WorkerIndex].ResponseVars.AllControl_Handles := Content.Values['$AllControl_Handles$'];
            AllWorkers[WorkerIndex].ResponseVars.AllControl_XOffsets := Content.Values['$AllControl_XOffsets$'];
            AllWorkers[WorkerIndex].ResponseVars.AllControl_YOffsets := Content.Values['$AllControl_YOffsets$'];

            AllWorkers[WorkerIndex].ResponseVars.AllControl_MatchSource := Content.Values['$AllControl_MatchSource$'];
            AllWorkers[WorkerIndex].ResponseVars.AllControl_DetailedMatchSource := Content.Values['$AllControl_DetailedMatchSource$'];
            AllWorkers[WorkerIndex].ResponseVars.AllControl_ResultedErrorCount := Content.Values['$AllControl_ResultedErrorCount$'];

            AllWorkers[WorkerIndex].ResponseVars.AllControl_Lefts := Content.Values['$AllControl_Lefts$'];
            AllWorkers[WorkerIndex].ResponseVars.AllControl_Tops := Content.Values['$AllControl_Lefts$'];
            AllWorkers[WorkerIndex].ResponseVars.AllControl_Rights := Content.Values['$AllControl_Rights$'];
            AllWorkers[WorkerIndex].ResponseVars.AllControl_Bottoms := Content.Values['$AllControl_Bottoms$'];

            AllWorkers[WorkerIndex].ResponseVars.AllControl_Widths := Content.Values['$AllControl_Widths$'];
            AllWorkers[WorkerIndex].ResponseVars.AllControl_Heights := Content.Values['$AllControl_Heights$'];
            AllWorkers[WorkerIndex].ResponseVars.AllHalfControl_Widths := Content.Values['$AllHalf_Control_Widths$'];
            AllWorkers[WorkerIndex].ResponseVars.AllHalfControl_Heights := Content.Values['$AllHalf_Control_Heights$'];
          end;

          TempResponseArchiveStr := Copy(Msg, Pos(CProtocolParam_ResultImageArchive + '=', Msg) + Length(CProtocolParam_ResultImageArchive + '='), MaxInt);
          SetWorkerResponseBitmapStream(WorkerIndex, TempResponseArchiveStr, Content.Values[CProtocolParam_ResponseArchiveSize]);

          AtLeastOneWorkerFoundTheSubControl := GetAllWorkers_AtLeastOneFound;   //this should be set after all responses
        end  //WorkerRequestID = AllWorkers[WorkerIndex].FindSubControlRequestID
        else
          AddToLog('==================== Received FindSubControl response with RequestID = ' + AllWorkers[WorkerIndex].FindSubControlRequestID);
      end; //WorkerIndex = -1
    end; //Topic

    if Topic = CTopicName_WorkerToApp_GetListOfFonts then
      if WaitingForWorkerFonts then
      begin
        if VerbLevel < 2 then
          AddToLog('Received fonts from worker: ' + WorkerName);

        WorkerIndex := GetWorkerIndexByName(WorkerName);
        if WorkerIndex = -1 then
          AddToLog('Error: cannot find worker "' + WorkerName + '" on receiving result.')
        else
          AllWorkers[WorkerIndex].Fonts := Content.Values[CProtocolParam_Fonts];
      end;

    //other fields which may pass metadata:
    //APublishProperties.UserProperty;
    //APublishProperties.ContentType;
    //APublishProperties.CorrelationData;
    //APublishProperties.ResponseTopic;     //this should match the CTopicName_AppToWorker_FindSubControl topic   (i.e. AppToWorker)
  finally
    Content.Free;
  end;

  if VerbLevel < 1 then
    AddToLog('');
end;


procedure HandleOnBeforeSending_MQTT_PUBREC(ClientInstance: DWord; var ATempPubRecFields: TMQTTPubRecFields; var ATempPubRecProperties: TMQTTPubRecProperties);
begin
  if VerbLevel < 1 then
    AddToLog('Acknowledging with PUBREC for ServerPacketID: ' + IntToStr(ATempPubRecFields.PacketIdentifier));
end;


procedure HandleOnAfterReceiving_MQTT_PUBREC(ClientInstance: DWord; var ATempPubRecFields: TMQTTPubRecFields; var ATempPubRecProperties: TMQTTPubRecProperties);
begin
  if VerbLevel < 1 then
    AddToLog('Received PUBREC for PacketID: ' + IntToStr(ATempPubRecFields.PacketIdentifier));
end;


//Sending PUBREL after the PUBREC response from server, after the client has sent a PUBLISH packet with QoS=2.
procedure HandleOnBeforeSending_MQTT_PUBREL(ClientInstance: DWord; var ATempPubRelFields: TMQTTPubRelFields; var ATempPubRelProperties: TMQTTPubRelProperties);
begin
  if VerbLevel < 1 then
    AddToLog('Acknowledging with PUBREL for PacketID: ' + IntToStr(ATempPubRelFields.PacketIdentifier));
end;


procedure HandleOnAfterReceiving_MQTT_PUBREL(ClientInstance: DWord; var ATempPubRelFields: TMQTTPubRelFields; var ATempPubRelProperties: TMQTTPubRelProperties);
begin
  if VerbLevel < 1 then
    AddToLog('Received PUBREL for ServerPacketID: ' + IntToStr(ATempPubRelFields.PacketIdentifier));
end;


procedure HandleOnBeforeSending_MQTT_PUBCOMP(ClientInstance: DWord; var ATempPubCompFields: TMQTTPubCompFields; var ATempPubCompProperties: TMQTTPubCompProperties);
begin
  if VerbLevel < 1 then
    AddToLog('Acknowledging with PUBCOMP for PacketID: ' + IntToStr(ATempPubCompFields.PacketIdentifier));
end;


procedure HandleOnAfterReceiving_MQTT_PUBCOMP(ClientInstance: DWord; var ATempPubCompFields: TMQTTPubCompFields; var ATempPubCompProperties: TMQTTPubCompProperties);
begin
  if VerbLevel < 1 then
    AddToLog('Received PUBCOMP for ServerPacketID: ' + IntToStr(ATempPubCompFields.PacketIdentifier));
end;


procedure HandleOnAfterReceivingMQTT_PINGRESP(ClientInstance: DWord);
begin
  if VerbLevel < 1 then
    AddToLog('Received PINGRESP');
end;


procedure HandleOnBeforeSendingMQTT_DISCONNECT(ClientInstance: DWord;  //The lower word identifies the client instance
                                               var ADisconnectFields: TMQTTDisconnectFields;
                                               var ADisconnectProperties: TMQTTDisconnectProperties;
                                               ACallbackID: Word);
begin
  if VerbLevel < 1 then
    AddToLog('Sending DISCONNECT');
  //ADisconnectFields.EnabledProperties := CMQTTDisconnect_EnSessionExpiryInterval;   //uncomment if needed
  //ADisconnectProperties.SessionExpiryInterval := 1;

  //From spec, pag 89:
  //If the Session Expiry Interval is absent, the Session Expiry Interval in the CONNECT packet is used.
  //If the Session Expiry Interval in the CONNECT packet was zero, then it is a Protocol Error to set a non-
  //zero Session Expiry Interval in the DISCONNECT packet sent by the Client.

  //From spec, pag 89:
  //After sending a DISCONNECT packet the sender
  //  MUST NOT send any more MQTT Control Packets on that Network Connection
  //  MUST close the Network Connection
end;


procedure HandleOnAfterReceivingMQTT_DISCONNECT(ClientInstance: DWord;  //The lower word identifies the client instance
                                                var ADisconnectFields: TMQTTDisconnectFields;
                                                var ADisconnectProperties: TMQTTDisconnectProperties);
begin
  if VerbLevel < 1 then
  begin
    AddToLog('Received DISCONNECT');

    AddToLog('ADisconnectFields.EnabledProperties' + IntToStr(ADisconnectFields.EnabledProperties));
    AddToLog('ADisconnectFields.DisconnectReasonCode' + IntToStr(ADisconnectFields.DisconnectReasonCode));

    AddToLog('ADisconnectProperties.SessionExpiryInterval' + IntToStr(ADisconnectProperties.SessionExpiryInterval));
    AddToLog('ADisconnectProperties.ReasonString' + StringReplace(DynArrayOfByteToString(ADisconnectProperties.ReasonString), #0, '#0', [rfReplaceAll]));
    AddToLog('ADisconnectProperties.ServerReference' + StringReplace(DynArrayOfByteToString(ADisconnectProperties.ServerReference), #0, '#0', [rfReplaceAll]));
    AddToLog('ADisconnectProperties.UserProperty' + StringReplace(DynOfDynArrayOfByteToString(ADisconnectProperties.UserProperty), #0, '#0', [rfReplaceAll]));
  end;
end;


procedure HandleOnBeforeSendingMQTT_AUTH(ClientInstance: DWord;  //The lower word identifies the client instance
                                         var AAuthFields: TMQTTAuthFields;
                                         var AAuthProperties: TMQTTAuthProperties;
                                         ACallbackID: Word);
begin
  if VerbLevel < 1 then
    AddToLog('Sending AUTH');

  AAuthFields.AuthReasonCode := $19; //Example: reauth   - see spec, pag 108.

  StringToDynArrayOfByte('SCRAM-SHA-1', AAuthProperties.AuthenticationMethod);       //some example from spec, pag 108
  StringToDynArrayOfByte('client-second-data', AAuthProperties.AuthenticationData);   //some modified example from spec, pag 108
end;


procedure HandleOnAfterReceivingMQTT_AUTH(ClientInstance: DWord;  //The lower word identifies the client instance
                                          var AAuthFields: TMQTTAuthFields;
                                          var AAuthProperties: TMQTTAuthProperties);
begin
  if VerbLevel < 1 then
  begin
    AddToLog('Received AUTH');

    AddToLog('AAuthFields.EnabledProperties' + IntToStr(AAuthFields.EnabledProperties));
    AddToLog('AAuthFields.AuthReasonCode' + IntToStr(AAuthFields.AuthReasonCode));

    AddToLog('AAuthProperties.ReasonString' + StringReplace(DynArrayOfByteToString(AAuthProperties.ReasonString), #0, '#0', [rfReplaceAll]));
    AddToLog('AAuthProperties.ServerReference' + StringReplace(DynArrayOfByteToString(AAuthProperties.AuthenticationMethod), #0, '#0', [rfReplaceAll]));
    AddToLog('AAuthProperties.ServerReference' + StringReplace(DynArrayOfByteToString(AAuthProperties.AuthenticationData), #0, '#0', [rfReplaceAll]));
    AddToLog('AAuthProperties.UserProperty' + StringReplace(DynOfDynArrayOfByteToString(AAuthProperties.UserProperty), #0, '#0', [rfReplaceAll]));
  end;
end;


procedure InitHandlers;
begin
  OnMQTTError^ := @HandleOnMQTTError;
  OnSendMQTT_Packet^ := @HandleOnSend_MQTT_Packet;
  OnBeforeMQTT_CONNECT^ := @HandleOnBeforeMQTT_CONNECT;
  OnAfterMQTT_CONNACK^ := @HandleOnAfterMQTT_CONNACK;
  OnBeforeSendingMQTT_PUBLISH^ := @HandleOnBeforeSendingMQTT_PUBLISH;
  OnBeforeSendingMQTT_PUBACK^ := @HandleOnBeforeSendingMQTT_PUBACK;
  OnAfterReceivingMQTT_PUBACK^ := @HandleOnAfterReceivingMQTT_PUBACK;
  OnAfterReceivingMQTT_PUBLISH^ := @HandleOnAfterReceivingMQTT_PUBLISH;
  OnBeforeSendingMQTT_PUBREC^ := @HandleOnBeforeSending_MQTT_PUBREC;
  OnAfterReceivingMQTT_PUBREC^ := @HandleOnAfterReceiving_MQTT_PUBREC;
  OnBeforeSendingMQTT_PUBREL^ := @HandleOnBeforeSending_MQTT_PUBREL;
  OnAfterReceivingMQTT_PUBREL^ := @HandleOnAfterReceiving_MQTT_PUBREL;
  OnBeforeSendingMQTT_PUBCOMP^ := @HandleOnBeforeSending_MQTT_PUBCOMP;
  OnAfterReceivingMQTT_PUBCOMP^ := @HandleOnAfterReceiving_MQTT_PUBCOMP;
  OnBeforeSendingMQTT_SUBSCRIBE^ := @HandleOnBeforeSendingMQTT_SUBSCRIBE;
  OnAfterReceivingMQTT_SUBACK^ := @HandleOnAfterReceivingMQTT_SUBACK;
  OnBeforeSendingMQTT_UNSUBSCRIBE^ := @HandleOnBeforeSendingMQTT_UNSUBSCRIBE;
  OnAfterReceivingMQTT_UNSUBACK^ := @HandleOnAfterReceivingMQTT_UNSUBACK;
  OnAfterReceivingMQTT_PINGRESP^ := @HandleOnAfterReceivingMQTT_PINGRESP;
  OnBeforeSendingMQTT_DISCONNECT^ := @HandleOnBeforeSendingMQTT_DISCONNECT;
  OnAfterReceivingMQTT_DISCONNECT^ := @HandleOnAfterReceivingMQTT_DISCONNECT;
  OnBeforeSendingMQTT_AUTH^ := @HandleOnBeforeSendingMQTT_AUTH;
  OnAfterReceivingMQTT_AUTH^ := @HandleOnAfterReceivingMQTT_AUTH;
end;


procedure TMQTTReceiveThread.AddMsgToLog(s: string);
begin
  AddToLog(s);
end;


procedure TMQTTReceiveThread.Execute;
var
  TempReadBuf, ExactPacket: TDynArrayOfByte;
  //ReadCount: Integer;
  TempByte: Byte;
  PacketName: string;
  PacketSize: DWord;
  //LoggedDisconnection: Boolean;
  TempArr: TIdBytes;
  SuccessfullyDecoded: Boolean;
  ProcessBufferLengthResult: Word;
begin
  FDone := False;

  try
    //ReadCount := 0;
    InitDynArrayToEmpty(TempReadBuf);

    try
      //LoggedDisconnection := False;
      repeat
        //try
        //  TempByte := IdTCPClient1.IOHandler.ReadByte;
        //  AddByteToDynArray(TempByte, TempReadBuf);
        //except
        //  on E: Exception do      ////////////////// ToDo: switch to EIdReadTimeout
        //  begin
        //    if (E.Message = 'Read timed out.') and (TempReadBuf.Len > 0) then
        //    begin
        //      MQTTPacketToString(TempReadBuf.Content^[0], PacketName);
        //      AddMsgToLog('done receiving packet: ' + E.Message + {'   ReadCount: ' + IntToStr(ReadCount) +} '   E.ClassName: ' + E.ClassName);
        //      AddMsgToLog('Buffer size: ' + IntToStr(TempReadBuf.Len) + '  Packet header: $' + IntToHex(TempReadBuf.Content^[0]) + ' (' + PacketName + ')');
        //
        //      SyncReceivedBuffer(TempReadBuf);
        //
        //      FreeDynArray(TempReadBuf);
        //      //ReadCount := 0; //reset for next packet
        //    end
        //    else
        //      if E.Message = 'Connection Closed Gracefully.' then
        //        if not LoggedDisconnection then
        //        begin
        //          LoggedDisconnection := True;
        //          AddMsgToLog('Disconnected from server. Cannot receive more data. Ex: ' + E.Message);
        //        end;
        //
        //    Sleep(1);
        //  end;
        //end;

        try
          if IdTCPClient1 = nil then //don't mind the race condition, the next iteration will catch the var to be nil
          begin
            FDone := True;
            Exit;
          end;

          TempByte := IdTCPClient1.IOHandler.ReadByte;
          if not AddByteToDynArray(TempByte, TempReadBuf) then
          begin
            HandleOnMQTTError(0, CMQTT_UserError, CMQTT_UNDEFINED);
            AddToLog('Cannot allocate buffer when reading. TempReadBuf.Len = ' + IntToStr(TempReadBuf.Len));
            MessageBoxFunction('Cannot allocate buffer when reading.', 'th_', 0);
            FreeDynArray(TempReadBuf);
            Sleep(1000);
          end
          else
          begin
            SuccessfullyDecoded := True;                                         //PacketSize should be the expected size, which can be greater than TempReadBuf.Len
            ProcessBufferLengthResult := MQTT_ProcessBufferLength(TempReadBuf, PacketSize);

            if ProcessBufferLengthResult <> CMQTTDecoderNoErr then
            begin
              SuccessfullyDecoded := False;

              if (ProcessBufferLengthResult = CMQTTDecoderIncompleteBuffer) and (PacketSize > 0) then  //PacketSize is successfully decoded, but the packet is incomplete
              begin
                //to get a complete packet, the number of bytes to be read next is PacketSize - TempReadBuf.Len.
                IdTCPClient1.IOHandler.ReadTimeout := 10;

                SetLength(TempArr, 0);
                IdTCPClient1.IOHandler.ReadBytes(TempArr, PacketSize - TempReadBuf.Len);

                if Length(TempArr) > 0 then //it should be >0, otherwise there should be a read timeout exception
                begin
                  if not AddBufferToDynArrayOfByte(@TempArr[0], Length(TempArr), TempReadBuf) then
                  begin
                    AddToLog('Out of memory on allocating TempReadBuf, for multiple bytes.');
                    MessageBoxFunction('Cannot allocate buffer when reading multiple bytes.', 'th_', 0);
                    FreeDynArray(TempReadBuf);
                    Sleep(1000);
                  end
                  else
                  begin
                    SetLength(TempArr, 0);
                    ProcessBufferLengthResult := MQTT_ProcessBufferLength(TempReadBuf, PacketSize);
                    SuccessfullyDecoded := ProcessBufferLengthResult = CMQTTDecoderNoErr;
                  end;
                end;

                IdTCPClient1.IOHandler.ReadTimeout := 10; //restore timeout, in case the above is increased
              end;
            end;

            if SuccessfullyDecoded then
            begin
              MQTTPacketToString(TempReadBuf.Content^[0], PacketName);

              if VerbLevel < 1 then
              begin
                AddToLog('done receiving packet');
                AddToLog('Buffer size: ' + IntToStr(TempReadBuf.Len) + '  Packet header: $' + IntToHex(TempReadBuf.Content^[0]) + ' (' + PacketName + ')');
              end;

              if PacketSize <> TempReadBuf.Len then
              begin
                if CopyFromDynArray(ExactPacket, TempReadBuf, 0, PacketSize) then
                begin
                  SyncReceivedBuffer(ExactPacket);
                  FreeDynArray(ExactPacket);
                  if not RemoveStartBytesFromDynArray(PacketSize, TempReadBuf) then
                    AddToLog('Cannot remove processed packet from TempReadBuf. Packet type: '+ PacketName);
                end
                else
                  AddToLog('Out of memory on allocating ExactPacket.');
              end
              else
              begin
                SyncReceivedBuffer(TempReadBuf);   //MQTT_Process returns an error for unknown and incomplete packets
                FreeDynArray(TempReadBuf);   //freed here, only when a valid packet is formed
              end;

              Sleep(1);
            end; //SuccessfullyDecoded
          end;
        except
          Sleep(1);
        end;

        //Inc(ReadCount);
      until Terminated;
    finally
      AddMsgToLog(DateTimeToStr(Now) + ' (' + IntToStr(GetTickCount64) + ')  Thread done..');
    end;
  except
    on E: Exception do
      AddMsgToLog('Th ex: ' + E.Message);
  end;

  FDone := True;
end;



function GetAPIVersion: DWord; cdecl;
begin
  Result := CActionPlugin_APIVersion;
end;


procedure GetListOfProperties(APluginReference: Pointer;                 //UIClicker passes the plugin reference to the plugin, then the plugin calls some callbacks with that reference
                              AListOfProperties: Pointer;
                              AListOfPropertiesLen: PDWord;
                              AOnActionPlugin_UpdatePropertyIcons: TOnActionPlugin_UpdatePropertyIcons); cdecl;
var
  Properties: string;
  i: Integer;
  TempMemStream: TMemoryStream;
  Bmp: TBitmap;
begin
  Properties := FillInPropertyDetails;
  AListOfPropertiesLen^ := SetPointedContentFromString(Properties, AListOfProperties);

  dmProperties := TdmProperties.Create(nil);
  try
    for i := 0 to CPropertiesCount - 1 do
    begin
      TempMemStream := TMemoryStream.Create;
      Bmp := TBitmap.Create;
      try
        Bmp.PixelFormat := pf24bit;
        Bmp.Width := dmProperties.imglstProperties.Width;
        Bmp.Height := dmProperties.imglstProperties.Height;
        Bmp.Canvas.Pen.Color := clWhite;
        Bmp.Canvas.Brush.Color := clWhite;
        Bmp.Canvas.Rectangle(0, 0, Bmp.Width, Bmp.Height);

        dmProperties.imglstProperties.Draw(Bmp.Canvas, 0, 0, i, dsNormal, itImage);
        Bmp.SaveToStream(TempMemStream);

        AOnActionPlugin_UpdatePropertyIcons(APluginReference, TempMemStream.Memory, TempMemStream.Size);
      finally
        TempMemStream.Free;
        Bmp.Free;
      end;
    end;
  finally
    dmProperties.Free;
  end;
end;


constructor TPluginMQTTClientHandlers.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  tmrProcessRecData := TTimer.Create(Self);
  tmrProcessRecData.Interval := 5;
  tmrProcessRecData.OnTimer := tmrProcessRecDataTimer;
  tmrProcessRecData.Enabled := True;
end;


procedure TPluginMQTTClientHandlers.tmrProcessRecDataTimer(Sender: TObject);
var
  i: Integer;
begin
  //try
  //  DebugPoint('ProcessReceivedBuffer timer', '');
  //except
  //end;

  try
    ProcessReceivedBuffer;
  except
    on E: Exception do
    begin
      tmrProcessRecData.Enabled := False;  //disable the timer, to allow calling Application.ProcessMessages
      try
        AddToLog('_________________ Ex on processing received data: ' + E.Message);

        for i := 1 to 10 do
        begin
          Sleep(100); //this loop is pretty fast, so slow it to the point where the user can manually stop the process
          AppProcMsg;
        end;
      finally
        if IdTCPClient1 <> nil then  //re-enable if not closing
          tmrProcessRecData.Enabled := True;
      end;

      //The following code was causing the timer to keep running, even after pressing the Stop button.
      //The Test_EnsureTheDistPluginStopsExecutionOnBadCredentials test verifyes this. The above code, which stops the timer, should fix the bug.
      //AddToLog('_________________ Ex on processing received data: ' + E.Message);
      //Sleep(1000); //this loop is pretty fast, so slow it to the point where the user can manually stop the process
    end;
  end;
end;


procedure TPluginMQTTClientHandlers.HandleClientOnConnected(Sender: TObject);
begin
  AddToLog('Connected to broker... on port ' + IntToStr(IdTCPClient1.Port));
end;


procedure TPluginMQTTClientHandlers.HandleClientOnDisconnected(Sender: TObject);
var
  tk: QWord;
begin
  AddToLog('Disconnected from broker...');

  if RecTh = nil then
  begin
    AddToLog('+++++++++++++++++++ RecTh is nil on disconnecting. Nothing to wait for then. (This is a race condition)'); //This handler should be called when RecTh is still valid.
    Exit;
  end;

  try
    tk := GetTickCount64;
    RecTh.Terminate;
    repeat
      AppProcMsg;
      Sleep(1);

      if GetTickCount64 - tk > 2000 then
      begin
        AddToLog('+++++++++++++++++++ Timeout waiting for RecTh to terminate.');
        Break;
      end;
    until RecTh.FDone;
  except
    on E: Exception do
      AddToLog('+++++++++++++++++++ Ex on terminating RecTh: ' + E.Message + '   Waiting duration: ' + IntToStr(GetTickCount64 - tk) + '  RecTh = ' + IntToStr(QWord(RecTh)));
  end;
end;


function DoConnectToBroker: Boolean;
begin
  Result := False;
  try
    IdTCPClient1.Connect(AddressPropertyValue, StrToIntDef(PortPropertyValue, 12345));
    IdTCPClient1.IOHandler.ReadTimeout := 1;

    RecTh := TMQTTReceiveThread.Create(True);
    RecTh.FreeOnTerminate := False;
    RecTh.Start;

    if not MQTT_CONNECT(0, 0) then
    begin
      Result := False;
      Exit;
    end;

    Result := True;
  except
    on E: Exception do
      AddToLog('Can''t connect.  ' + E.Message + '   Class: ' + E.ClassName);
  end; //connect
end;


//procedure DoWaitForAllResponses;
//var
//  tk: QWord;
//begin
//  PublishAckReceived := False;
//  tk := GetTickCount64;
//  repeat
//    Application.ProcessMessages;
//    Sleep(1);
//  until (GetTickCount64 - tk > 1500) or PublishAckReceived;
//end;


function DoDisconnect: Boolean;
var
  tk: QWord;
  ClientToServerBuf: {$IFDEF SingleOutputBuffer} PMQTTBuffer; {$ELSE} PMQTTMultiBuffer; {$ENDIF}
  Err: Word;
  //StillRunning: Boolean;
begin
  Result := False;
  //Disconnecting:
  if not MQTT_DISCONNECT(0, 0) then
  begin
    AddToLog('Can''t disconnect.');
    Exit;
  end;

  tk := GetTickCount64;
  repeat
    ClientToServerBuf := MQTT_GetClientToServerBuffer(0, Err);
    AppProcMsg;
    Sleep(10);
  until (GetTickCount64 - tk > 1500) or ((ClientToServerBuf <> nil) and (ClientToServerBuf^.Len = 0));

  RecTh.Terminate;
  tk := GetTickCount64;
  repeat
    AppProcMsg;
    Sleep(1);
  until (GetTickCount64 - tk > 1500) or RecTh.Terminated;

  //StillRunning := not RecTh.Terminated;
  FreeAndNil(RecTh);

  IdTCPClient1.Disconnect(False);
  Result := True;

  //if StillRunning then
  //  MessageBox(0, 'MQTT thread is still running..', 'Dist plugin', 0);
end;



procedure GetAllVarsAndValuesFromVarsForWorkers(AVarsForWorkers: string; AListOfAllVars: TStringList; out AAllNames, AAllValues, AAllEvalBefore: string);
var
  ListOfVarsForWorkers: TStringList;
  i: Integer;
  VarName, VarValue: string;
begin
  ListOfVarsForWorkers := TStringList.Create;
  try
    ListOfVarsForWorkers.LineBreak := #13#10;
    AVarsForWorkers := StringReplace(AVarsForWorkers, ', ', #13#10, [rfReplaceAll]);
    AVarsForWorkers := StringReplace(AVarsForWorkers, ',', #13#10, [rfReplaceAll]);

    ListOfVarsForWorkers.Text := AVarsForWorkers;

    AAllNames := '';
    AAllValues := '';
    AAllEvalBefore := '';
    for i := 0 to ListOfVarsForWorkers.Count - 1 do
    begin
      VarName := ListOfVarsForWorkers.Strings[i];
      VarValue := AListOfAllVars.Values[VarName];

      AAllNames := AAllNames + VarName + #4#5;
      AAllValues := AAllValues + VarValue + #4#5;
      AAllEvalBefore := AAllEvalBefore + '0' + #4#5;
    end;
  finally
    ListOfVarsForWorkers.Free;
  end;
end;


procedure GetPluginSettingsFromProperties(AProperties: TStringList; AListOfVars: string);
var
  ListOfVars: TStringList;
begin
  FindSubControlActionPropertyValue := AProperties.Values[CFindSubControlActionPropertyName];
  CredentialsFullFileNamePropertyValue := AProperties.Values[CCredentialsFullFileNamePropertyName];  //for connection to broker
  AddressPropertyValue := AProperties.Values[CAddressPropertyName];
  PortPropertyValue := AProperties.Values[CPortPropertyName];

  ListOfVars := TStringList.Create;
  try
    ListOfVars.LineBreak := #13#10;
    ListOfVars.Text := AListOfVars;
    CredentialsFullFileNamePropertyValue := EvaluateAllReplacements(ListOfVars, CredentialsFullFileNamePropertyValue);
    AddressPropertyValue := EvaluateAllReplacements(ListOfVars, AddressPropertyValue);
    PortPropertyValue := EvaluateAllReplacements(ListOfVars, PortPropertyValue);

    // AProperties.Values[CVariablesForWorkersPropertyName] is a comma-separated list of vars
    GetAllVarsAndValuesFromVarsForWorkers(AProperties.Values[CVariablesForWorkersPropertyName], ListOfVars, VarsForWorkers_Names, VarsForWorkers_Values, VarsForWorkers_EvalBefore);
  finally
    ListOfVars.Free;
  end;
end;


procedure ExecFSM_Part1;
var
  i: Integer;
begin
  case State of
    SInit:
    begin
      FSMDone := False;
      ConnectedSucessfully := False;
      ConAckReceived := False;
      SubAckReceived := False;
      SubscribedSucessfully := False;
      DisconnectedSuccessfully := False;
      tk := GetTickCount64;
    end;

    SConnectToBroker:
    begin
      if VerbLevel < 2 then
        AddToLog('Connecting to broker.');

      ConnectedSucessfully := DoConnectToBroker;

      if ConnectedSucessfully then
      begin
        tk := GetTickCount64;
        DbgPoint('Connected to broker.', '')
      end
      else
      begin
        FSMError := 'Can''t connect to broker. ' + AddressPropertyValue + ':' + PortPropertyValue;
        AddToLog(FSMError);
      end;
    end;

    SWaitForConAck:
    begin
      // ConAckReceived is set by handler
    end;

    SSubscribeToResponses:
    begin
      SubscribedSucessfully := MQTT_SUBSCRIBE(0, 0);     //subscribing with CTopicNameResult
      if not SubscribedSucessfully then
      begin
        FSMError := 'Can''t subscribe for responses.';
        AddToLog(FSMError);
      end
      else
        tk := GetTickCount64;
    end;

    SWaitForResponsesSubAck:   //Responses can be capabilities, lists of missing files, processing results
    begin
      //SubAckReceived is set by handler
    end;

    SRequestCapabilities:
    begin
      WaitingForWorkerCapabilities := True;    //reset below
      if not MQTT_PUBLISH(0, CCallbackID_GetCapabilities, WorkerQoS) then  //notice CallbackID = 0      (i.e. 'GetCapabilities')
      begin
        FSMError := 'Can''t send GetCapabilities request to broker.';
        AddToLog(FSMError);
      end
      else
        tk := GetTickCount64;
    end;

    SWaitForCapabilitiesResponse:
    begin
      // Every worker has to respond with what capabilities is configured.
      // Some can process Text, others Bmp files, others Primitives.
      // If the FindSubControl action has only two text profiles, it makes sense to distribute the search to both workers.
      // That means, all workers should be able to process anything. Anyway, since all have UIClicker installed, all of them should be able to do all.
      // The only real difference between workers would be the OS (Win vs Lin), where each may have different lists of fonts and different GPU rendering settings.
      // So, the best option would be to evenly split (as best as possible) all types of FindSubControls (Txt, Bmp, Pmtv) across all workers.

      // For efficient use of the network, it would be better if all workers can respond here with the list of the bmp/pmtv files (including backgrounds),
      // along with their MD5 hashes, so that the plugin would know what files to send to each worker.
      // Since all backgrounds may have the same name ('Background.bmp'), this bmp should be renamed to 'Background_<MD5>.bmp'.
      // The backgrounds are likely to change, but some of them, like menus or various window parts may stay the same.
      // The worker should be configurable about the cache size.
    end;

    SGetFindSubControlActionContent:
    begin
      //This is where GetFindControlActionProperties is called (unfortunately in FSM's loop) instead of this case item.
    end;

    SPublishBackgroundImageToAllWorkers:
    begin
      AtLeastOneWorkerFoundTheSubControl := False;
      WorkerRespondedCountBG := 0;

      if VerbLevel < 2 then
        AddToLog('Sending background image to broker...');

      if not MQTT_PUBLISH(0, CCallbackID_SendBackgroundToAll, WorkerQoS) then   //notice CallbackID = 1     (i.e. 'SendBackgroundToAll')
      begin
        FSMError := 'Can''t send background image to all workers.';
        AddToLog(FSMError);
      end
      else
        tk := GetTickCount64;

      if VerbLevel < 2 then
        AddToLog('Done sending background image.');
    end;

    SWaitForBackgroundImageResults:
    begin

    end;

    SPublishFindSubControlToAllWorkers:
    begin
      AtLeastOneWorkerFoundTheSubControl := False;
      WorkerRespondedCountFS := 0;

      if VerbLevel < 2 then
        AddToLog('Sending FindSubControl settings to broker...');

      for i := 0 to Length(AllWorkers) - 1 do
      begin
        if not MQTT_PUBLISH(0, CCallbackID_SendFindSubControl or (i shl 8), WorkerQoS) then   //notice CallbackID = 3     (i.e. 'FindSubControl')
        begin
          FSMError := 'Can''t send FindSubControl settings to broker for worker[' + IntToStr(i) + '].';
          AddToLog(FSMError);
        end
        else
          tk := GetTickCount64;
      end;

      if VerbLevel < 2 then
        AddToLog('Done sending FindSubControl settings.');
    end;

    SWaitForFindSubControlResults:
    begin
      // It is possible that the plugin may receive "missing files" requests.
      // If that's the case, it should send those files, here in the same state.
    end;

    SGetListOfFonts:
    begin
      WaitingForWorkerFonts := True; //reset below
      for i := 0 to Length(AllWorkers) - 1 do
      begin
        if not MQTT_PUBLISH(0, CCallbackID_GetListOfFonts or (i shl 8), WorkerQoS) then   //notice CallbackID = 4     (i.e. 'GetListOfFonts')
        begin
          FSMError := 'Can''t send GetListOfFonts settings to broker for worker[' + IntToStr(i) + '].';
          AddToLog(FSMError);
        end
        else
          tk := GetTickCount64;
      end;
    end;

    SWaitForListOfFonts:
    begin

    end;

    SUpdateCache:
    begin
      if VerbLevel < 2 then
        AddToLog('Updating plugin cache..');

      if UpdateCacheActionName = '' then
      begin
        FSMError := 'There is no configured action for updating plugin cache.';
        AddToLog(FSMError);
      end
      else
        if not ActionPlugin_ExecuteActionCallback(GPluginReference, @UpdateCacheActionName[1]) then
          FSMError := 'Error updating plugin cache. The ' + UpdateCacheActionName + ' action failed.';
          //ToDo: load all vars, then read the value of $ExecAction_Err$ and concatenate it to the error message above.
    end;

    SLoadCache:
    begin
      if VerbLevel < 2 then
        AddToLog('Loading plugin cache..');

      if LoadCacheActionName = '' then
      begin
        FSMError := 'There is no configured action for loading plugin cache.';
        AddToLog(FSMError);
      end
      else
        if not ActionPlugin_ExecuteActionCallback(GPluginReference, @LoadCacheActionName[1]) then
          FSMError := 'Error loading plugin cache. The ' + LoadCacheActionName + ' action failed.';
          //ToDo: load all vars, then read the value of $ExecAction_Err$ and concatenate it to the error message above.
    end;

    SDisconnectFromBroker:
    begin
      FSMDone := True;
      DisconnectedSuccessfully := DoDisconnect;
    end;

    SDone:
    begin
      FSMDone := True;
      AddToLog('Plugin done');
    end;
  end;
end;


procedure ExecFSM_Part2;
begin
  case State of
    SInit:
      NextState := SConnectToBroker;

    SConnectToBroker:
      if ConnectedSucessfully then
        NextState := SWaitForConAck
      else
        NextState := SDisconnectFromBroker;

    SWaitForConAck:
    begin
      if ConAckReceived then  //there should be one ConAckReceived event only (this plugin to broker), unlike multiple workers below
        NextState := SSubscribeToResponses
      else
        if GetTickCount64 - tk > 1000 then
          NextState := SDisconnectFromBroker  //Timeout
        else
          NextState := SWaitForConAck;
    end;

    SSubscribeToResponses:
      if SubscribedSucessfully then
        NextState := SWaitForResponsesSubAck
      else
        NextState := SDisconnectFromBroker;

    SWaitForResponsesSubAck:   //Responses can be capabilities, lists of missing files, processing results
      if SubAckReceived then
      begin
        if WorkerCapabilitiesSource = CReqCapOperation_wcsLoadCacheAndFindSubControl then
          NextState := SLoadCache
        else
          NextState := SRequestCapabilities;
      end
      else
      begin
        if GetTickCount64 - tk > 1000 then
          NextState := SDisconnectFromBroker  //Timeout
        else
          NextState := SWaitForResponsesSubAck;
      end;

    SRequestCapabilities:
      NextState := SWaitForCapabilitiesResponse;

    SWaitForCapabilitiesResponse:
      if (GetTickCount64 - tk > GetWorkerCapabilitiesTimeout) or  //Waiting for some time, for all workers to present their capabilities. This way, the plugin knows home many are they.
         (Length(AllWorkers) >= MinExpectedWorkerCount) then      //Or enough workers are available, no need to wait for more.
      begin
        if WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndFindSubControl then
          NextState := SGetFindSubControlActionContent
        else
          if WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndGetFonts then
            NextState := SGetListOfFonts
          else
            if WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndGetFontsAndFindSubControl then
              NextState := SGetListOfFonts  //in SWaitForListOfFonts, there is still a verification of WorkerCapabilitiesSource
            else
              if WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndUpdateCache then
                NextState := SUpdateCache
              else
                if WorkerCapabilitiesSource = CReqCapOperation_wcsLoadCacheAndFindSubControl then   //////////// this should not happen in this state
                begin
                  NextState := SDisconnectFromBroker; /////////////// set here to a different state when implemented
                  AddToLog('________' + CReqCapOperation_wcsLoadCacheAndFindSubControl + ' not implemented yet...'); //remove comment
                end
                else
                begin
                  NextState := SDisconnectFromBroker;
                  AddToLog('________ Unknown operation: ' + WorkerCapabilitiesSource + '. Exiting plugin.');
                end;

        WaitingForWorkerCapabilities := False;
      end
      else
        NextState := SWaitForCapabilitiesResponse;

    SGetFindSubControlActionContent:
    begin
      if Length(AllWorkers) > 255 then
      begin
        FSMError := 'Too many workers (' + IntToStr(Length(AllWorkers)) + '). Please modify the index encoding to raise the limit above 255.';
        AddToLog(FSMError);
        NextState := SDisconnectFromBroker;
      end
      else
        NextState := SPublishBackgroundImageToAllWorkers;
    end;

    SPublishBackgroundImageToAllWorkers:
      NextState := SWaitForBackgroundImageResults;

    SWaitForBackgroundImageResults:
      if GetTickCount64 - tk > FindSubControlWorkerTimeout then   //not sure what timeout to use here
      begin
        NextState := SDisconnectFromBroker;  //Timeout

        if WorkerRespondedCountBG = 0 then
          FSMError := 'Timeout waiting for workers to send the background image to their local UIClicker.'
        else
          FSMError := 'Some of the responding workers could not send the background image to their local UIClicker.';

        FSMError := FSMError + ' ResponseCount = ' + IntToStr(WorkerRespondedCountBG) + ' / ' + IntToStr(Length(AllWorkers)) + '.';  //Do not change this format. It is used later.

        AddToLog(FSMError);
        AddToLog('Sending background image duration: ' + IntToStr(GetTickCount64 - tk) + 'ms.  FindSubControlWorkerTimeout is set to ' + IntToStr(FindSubControlWorkerTimeout) + 'ms.');
      end
      else
      begin
        NextState := SWaitForBackgroundImageResults;

        if WorkerRespondedCountBG >= Length(AllWorkers) then
        begin
          NextState := SPublishFindSubControlToAllWorkers;

          if VerbLevel < 2 then
            AddToLog('All workers responded after having the background image in ' + IntToStr(GetTickCount64 - tk) + 'ms.');
        end;
      end;

    SPublishFindSubControlToAllWorkers:
      NextState := SWaitForFindSubControlResults;

    SWaitForFindSubControlResults:
      if AtLeastOneWorkerFoundTheSubControl then
        NextState := SDisconnectFromBroker
      else
        if GetTickCount64 - tk > FindSubControlWorkerTimeout then
        begin
          NextState := SDisconnectFromBroker;  //Timeout

          if WorkerRespondedCountFS = 0 then
            FSMError := 'Timeout waiting for workers to find the SubControl.'
          else
            FSMError := CNoWorkerFoundSubControlErr;

          FSMError := FSMError + ' ResponseCount = ' + IntToStr(WorkerRespondedCountFS) + ' / ' + IntToStr(Length(AllWorkers)) + '.';  //Do not change this format. It is used later.

          AddToLog(FSMError);
        end
        else
          NextState := SWaitForFindSubControlResults;

    SGetListOfFonts:
      NextState := SWaitForListOfFonts;

    SWaitForListOfFonts:
      if GetTickCount64 - tk > GetWorkerCapabilitiesTimeout then   //Waiting for some time, for all workers to present their fonts.
      begin
        if WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndGetFontsAndFindSubControl then
          NextState := SGetFindSubControlActionContent
        else
          NextState := SDisconnectFromBroker;

        WaitingForWorkerFonts := False;
      end
      else
        NextState := SWaitForListOfFonts;

    SUpdateCache:
      NextState := SDisconnectFromBroker;

    SLoadCache:
    begin
      //NextState := SGetFindSubControlActionContent;  //from SLoadCache, the next state should be SGetFindSubControlActionContent
      WorkerCapabilitiesSource := CReqCapOperation_wcsReqCapAndFindSubControl; //but the list of workers is not updated yet by the cache.  ToDo
      NextState := SRequestCapabilities; //Go and get capabilities, which updates the list of workers and then execute FindSubControl. (Temp solution.)
    end;

    SDisconnectFromBroker:
      NextState := SDone;

    SDone:
      NextState := SDone;
  end;
end;


procedure ExecFSM;
begin
  ExecFSM_Part1;
  ExecFSM_Part2;
  State := NextState;
end;


procedure HandleOnFileContent(ACallReference, AStreamContent: Pointer; AStreamSize: Int64); cdecl;
var
  TempStream: TMemoryStream;
  DestBmp: TBitmap;
begin
  if AStreamSize <= 0 then
    Exit;

  DestBmp := TBitmap(ACallReference); //created by caller

  TempStream := TMemoryStream.Create;
  try
    TempStream.SetSize(AStreamSize);
    Move(AStreamContent^, TempStream.Memory^, AStreamSize);
    DestBmp.LoadFromStream(TempStream, AStreamSize);
  finally
    TempStream.Free;
  end;
end;


procedure HandleOnFileContentAsRawStream(ACallReference, AStreamContent: Pointer; AStreamSize: Int64); cdecl;
var
  DestMemStream: TMemoryStream;
begin
  if AStreamSize <= 0 then
    Exit;

  DestMemStream := TMemoryStream(ACallReference); //created by caller
  DestMemStream.SetSize(AStreamSize);
  Move(AStreamContent^, DestMemStream.Memory^, AStreamSize);
end;


function ExecutePlugin(APluginReference: Pointer;
                       AListOfPluginSettings: Pointer;
                       AListOfPluginSettingsLen: PDWord;

                       AOnActionPlugin_GetActionCount: TOnActionPlugin_GetActionCount;
                       AOnActionPlugin_GetActionInfoByIndex: TOnActionPlugin_GetActionInfoByIndex;
                       AOnActionPlugin_GetActionContentByIndex: TOnActionPlugin_GetActionContentByIndex;
                       AOnActionPlugin_ExecuteAction: TOnActionPlugin_ExecuteAction;
                       AOnActionPlugin_GetAllTemplateVars: TOnActionPlugin_GetAllTemplateVars;
                       AOnActionPlugin_SetTemplateVar: TOnActionPlugin_SetTemplateVar;
                       AOnActionPlugin_DebugPoint: TOnActionPlugin_DebugPoint;
                       AOnActionPlugin_AddToLog: TOnActionPlugin_AddToLog;
                       AOnActionPlugin_SetResultImg: TOnActionPlugin_SetResultImg;
                       AOnActionPlugin_LoadBitmap: TOnActionPlugin_LoadBitmap;
                       AOnActionPlugin_GetAllowedFilesInfo: TOnActionPlugin_GetAllowedFilesInfo;
                       AOnActionPlugin_SetBitmap: TOnActionPlugin_SetBitmap;
                       AOnActionPlugin_Screenshot: TOnActionPlugin_Screenshot;
                       AOnActionPlugin_CheckStopAllActionsOnDemand: TOnActionPlugin_CheckStopAllActionsOnDemand;
                       AOnActionPlugin_InMemFS: TOnActionPlugin_InMemFS;
                       AOnActionPlugin_AppProcMsg: TOnActionPlugin_AppProcMsg
                       ): Boolean; cdecl;
var
  ActionCount, IndexOfFindSubControlActionProperty: Integer;
  PluginSettingsStr, AllVarsStr: string;
  TempPluginMQTTClientHandlers: TPluginMQTTClientHandlers;
  s: string;
  ActionTypeDWord: DWord;
  ActionType: TClkAction;
  UsingCompression: Boolean;
  PluginSettings: TStringList;

  procedure SetTemplateVar(AVarName, AVarValue: string);
  begin
    AOnActionPlugin_SetTemplateVar(APluginReference, @AVarName[1], @AVarValue[1]);
  end;

  procedure GetActionInfoByIndex(AIndex: Integer; out AActionName: string; var AActionType: DWord);
  var
    Buffer: string;
    ActionNamePtr: Pointer;
    NameLengthDWord: DWord;
  begin
    SetLength(Buffer, CMaxSharedStringLength + 1);
    ActionNamePtr := @Buffer[1];
    NameLengthDWord := 0;

    AActionName := '';
    AOnActionPlugin_GetActionInfoByIndex(APluginReference, AIndex, ActionNamePtr, @NameLengthDWord, @AActionType);
    SetPointedContentToString(ActionNamePtr, AActionName);
    SetLength(AActionName, NameLengthDWord);
  end;

  procedure GetAllTemplateVars(out AAllTemplateVars: string);  //AAllTemplateVars are encoded as CRLF separated key=value strings, ready to be used on a TStringlist
  var
    Buffer: string;
    AllTemplateVarsPtr: Pointer;
    NameLengthDWord: DWord;
  begin
    SetLength(Buffer, CMaxSharedStringLength + 1);
    AllTemplateVarsPtr := @Buffer[1];
    NameLengthDWord := 0;
    AAllTemplateVars := '';

    AOnActionPlugin_GetAllTemplateVars(APluginReference, AllTemplateVarsPtr, @NameLengthDWord);  //decode action execution results

    SetPointedContentToString(AllTemplateVarsPtr, AAllTemplateVars);
    SetLength(AAllTemplateVars, NameLengthDWord);
  end;

  function GetPluginSettings: string;
  begin
    SetLength(Result, CMaxSharedStringLength);
    SetPointedContentToString(AListOfPluginSettings, Result);
    SetLength(Result, AListOfPluginSettingsLen^);
  end;

  function BitmapIsAllowedToBeLoaded(AFnm: string; out ADenyReason: string): Boolean;
  var
    TempFileProvider: TFileProvider;
    FullTemplatesDir, AllowedFileDirsForServer, AllowedFileExtensionsForServer: string;
    FullTemplatesDirPtr, AllowedFileDirsForServerPtr, AllowedFileExtensionsForServerPtr: Pointer;
  begin
    TempFileProvider := TFileProvider.Create;
    try
      SetLength(FullTemplatesDir, CMaxSharedStringLength + 1);
      SetLength(AllowedFileDirsForServer, CMaxSharedStringLength + 1);
      SetLength(AllowedFileExtensionsForServer, CMaxSharedStringLength + 1);

      FullTemplatesDirPtr := @FullTemplatesDir[1];
      AllowedFileDirsForServerPtr := @AllowedFileDirsForServer[1];
      AllowedFileExtensionsForServerPtr := @AllowedFileExtensionsForServer[1];

      AOnActionPlugin_GetAllowedFilesInfo(APluginReference, FullTemplatesDirPtr, AllowedFileDirsForServerPtr, AllowedFileExtensionsForServerPtr);
      FullTemplatesDir := Copy(FullTemplatesDir, 1, Pos(#0, FullTemplatesDir) - 1);
      AllowedFileDirsForServer := Copy(AllowedFileDirsForServer, 1, Pos(#0, AllowedFileDirsForServer) - 1);
      AllowedFileExtensionsForServer := Copy(AllowedFileExtensionsForServer, 1, Pos(#0, AllowedFileExtensionsForServer) - 1);

      TempFileProvider.FullTemplatesDir := FullTemplatesDir;

      TempFileProvider.AddListOfAccessibleDirs(AllowedFileDirsForServer);
      TempFileProvider.AddListOfAccessibleFileExtensions(AllowedFileExtensionsForServer);

      Result := TempFileProvider.FileIsAllowed(AFnm, ADenyReason);
    finally
      TempFileProvider.Free;
    end;
  end;

  function LoadBitmap(AListOfAllVars: TStringList; AFnm: string; ADestBmp: TBitmap; AFileLocation: TImageSourceFileNameLocation): Boolean;
  var
    TempDenyReason: string;
  begin
    AFnm := EvaluateAllReplacements(AListOfAllVars, AFnm);

    if BitmapIsAllowedToBeLoaded(AFnm, TempDenyReason) then                                      //isflDisk=0, isflMem=1
      Result := AOnActionPlugin_LoadBitmap(APluginReference, @AFnm[1], ADestBmp, Ord(AFileLocation), @HandleOnFileContent)
    else
      Result := False;
  end;

  function LoadBitmapAsStream(AListOfAllVars: TStringList; AFnm: string; AMemStream: TMemoryStream; AFileLocation: TImageSourceFileNameLocation): Boolean;
  var
    TempDenyReason: string;
    IsPmtv: Byte;
  begin
    AFnm := EvaluateAllReplacements(AListOfAllVars, AFnm);

    if BitmapIsAllowedToBeLoaded(AFnm, TempDenyReason) then                                      //isflDisk=0, isflMem=1
    begin
      IsPmtv := Ord(UpperCase(ExtractFileExt(AFnm)) = '.PMTV') shl 3;  //use bit 3 for "DoNotRender" flag, to reserve bits 2 and 1 for future use.
      Result := AOnActionPlugin_LoadBitmap(APluginReference, @AFnm[1], AMemStream, Ord(AFileLocation) or IsPmtv, @HandleOnFileContentAsRawStream)
    end
    else
    begin
      AddToLog('Bitmap/pmtv is not allowed to be loaded: "' + AFnm + '"   ' + TempDenyReason + '   ImgSrc: ' + CImageSourceFileNameLocationStr[AFileLocation]);
      Result := False;
    end;
  end;

  procedure GenerateSomeResultImg(AListOfAllVars: TStringList);
  var
    TempBmp, BkBmp: TBitmap;
    TempStream: TMemoryStream;
  begin
    TempBmp := TBitmap.Create;
    BkBmp := TBitmap.Create;
    TempStream := TMemoryStream.Create;
    try
      TempBmp.Width := 700;
      TempBmp.Height := 400;
      TempBmp.Canvas.Brush.Color := clBlack;
      TempBmp.Canvas.Pen.Color := clBlack;

      if LoadBitmap(AListOfAllVars, ExtractFilePath(ParamStr(0)) + 'Tests\TestFiles\Gradient30deg.bmp', BkBmp, isflDisk) then
        TempBmp.Canvas.Draw(50, 25, BkBmp);

      TempBmp.Canvas.Font.Color := clYellow;
      TempBmp.Canvas.Font.Name := 'Courier New';
      TempBmp.Canvas.TextOut(30, 10, 'Plugin done.');

      TempBmp.SaveToStream(TempStream);
      AOnActionPlugin_SetResultImg(APluginReference, 0, 0, 0, TempStream.Memory, TempStream.Size, TempBmp.Width, TempBmp.Height);
    finally
      TempStream.Free;
      TempBmp.Free;
      BkBmp.Free;
    end;
  end;

  procedure SaveBitmapToExtRenderingInMemFS;
  var
    Bmp: TBitmap;
    MemStream: TMemoryStream;
  begin
    Bmp := TBitmap.Create;
    MemStream := TMemoryStream.Create;
    try
      Bmp.Width := 150;
      Bmp.Height := 180;
      Bmp.PixelFormat := pf24bit;
      Bmp.Canvas.Brush.Color := clBlack;
      Bmp.Canvas.Font.Color := clYellow;
      Bmp.Canvas.TextOut(50, 60, 'Generated bitmap');
      Bmp.Canvas.TextOut(50, 130, 'Generated bitmap');
      bmp.SaveToStream(MemStream);

      AOnActionPlugin_SetBitmap(APluginReference, @string('GenBmp.bmp')[1], MemStream.Memory, MemStream.Size, Bmp.Width, Bmp.Height);
    finally
      Bmp.Free;
      MemStream.Free;
    end;
  end;

  //var
  //  SplitActions: array of TClkFindControlOptions;

  function HashFoundInFileCacheInfo(AFileCacheInfo: TStringList; AHash: string): Boolean;
  var
    i: Integer;
    s: string;
  begin
    Result := False;

    for i := 0 to AFileCacheInfo.Count - 1 do
    begin
      s := AFileCacheInfo.Strings[i];
      s := Copy(s, Pos(CDefaultInMemFileNameHashSeparator, s) + Length(CDefaultInMemFileNameHashSeparator), MaxInt);

      if s = AHash then
      begin
        Result := True;
        Break;
      end;
    end;
  end;

  procedure OpenWorkerArchivesForAddingBitmaps(AArchiveHandlers: TArchiveHandlers);
  var
    i: Integer;
  begin
    for i := 0 to Length(AllWorkers) - 1 do
    begin
      AllWorkers[i].Archive.OpenArchive(AllWorkers[i].ArchiveStream, True);
      AllWorkers[i].Archive.OnCompress := AArchiveHandlers.HandleOnCompress;
      AllWorkers[i].Archive.OnDecompress := AArchiveHandlers.HandleOnDecompress;
      AllWorkers[i].Archive.OnComputeArchiveHash := AArchiveHandlers.HandleOnComputeArchiveHash;
      AllWorkers[i].Archive.Password := '';

      AllWorkers[i].Archive.CompressionLevel := 9 * Ord(UsingCompression);
    end;

    BkArchive.OpenArchive(BkArchiveStream, True);
    BkArchive.OnCompress := AArchiveHandlers.HandleOnCompress;
    BkArchive.OnDecompress := AArchiveHandlers.HandleOnDecompress;
    BkArchive.OnComputeArchiveHash := AArchiveHandlers.HandleOnComputeArchiveHash;
    BkArchive.Password := '';

    BkArchive.CompressionLevel := 9 * Ord(UsingCompression);
  end;


  function FileExistsInCache(AWorkerCache: TStringList; AFileName: string; AFileContent: TMemoryStream): Boolean;
  var
    FileHash: string;
  begin
    FileHash := ClickerExtraUtils.ComputeHash(AFileContent.Memory, AFileContent.Size);
    Result := AWorkerCache.IndexOf(AFileName + CDefaultInMemFileNameHashSeparator + FileHash) > -1;
  end;


  function AddBackgroundBitmapToWorkerArchives(AListOfAllVars: TStringList; AImageSource, AImageSourceFileNameLocation, ASourceFileName: string; out ABackgroundSize: Int64; out ABackgroundWidth, ABackgroundHeight: Integer): Boolean;
  var
    TempBk: TMemoryStream;
    BkFileNameLocation: TImageSourceFileNameLocation;
    //BkHash: string;
    TempBmp: TBitmap;
  begin
    ABackgroundSize := -2; //init with something
    ABackgroundWidth := 1;
    ABackgroundHeight := 1;

    if AImageSource = '0' then  //isScreenshot
    begin
      if VerbLevel < 2 then
        AddToLog('----------- ImageSource is a screenshot. Taking the screenshot, using the settings from ' + PluginSettings.ValueFromIndex[CFindSubControlActionPropertyIndex] + ' action.');

      AOnActionPlugin_Screenshot(APluginReference, @string(PluginSettings.ValueFromIndex[CFindSubControlActionPropertyIndex])[1]);

      if VerbLevel < 2 then
        AddToLog('----------- The screenshot should be found in in-mem FS, as ' + CScreenshotFilename);

      ASourceFileName := CScreenshotFilename;
    end;

    BkFileNameLocation := TImageSourceFileNameLocation(StrToIntDef(AImageSourceFileNameLocation, 1));

    if VerbLevel < 2 then
      AddToLog('----------- Loading background bitmap as stream and adding it to archive...');

    TempBk := TMemoryStream.Create;
    try
      if LoadBitmapAsStream(AListOfAllVars, ASourceFileName, TempBk, BkFileNameLocation) then
      begin
        ABackgroundSize := TempBk.Size;
        //BkHash := ComputeHash(TempBk.Memory, TempBk.Size);

        //if not FileExistsInCache(AllWorkers[0].FileCacheInfo, CBackgroundFileNameInArchive, TempBk) then    The problem right now, is that the same background archive is sent to all workers. That means the cache has to be verified for all workers and only some of them may need thi archive.
        BkArchive.AddFromStream(CBackgroundFileNameInArchive, TempBk);

        TempBmp := TBitmap.Create;
        try
          TempBk.Position := 0;
          TempBmp.LoadFromStream(TempBk);
          ABackgroundWidth := TempBmp.Width;
          ABackgroundHeight := TempBmp.Height;

          if VerbLevel < 2 then
            AddToLog('----------- Background size: ' + IntToStr(TempBmp.Width) + ' : ' + IntToStr(TempBmp.Height));
        finally
          TempBmp.Free;
        end;
      end
      else
      begin
        ABackgroundSize := 0;
        raise Exception.Create('----------- LoadBitmapAsStream is False. Probably the file does not exist: ' + ASourceFileName);
        //Result := False;
        //Exit;
      end;
    finally
      TempBk.Free;
    end;
  end;


  function GetFullTemplatesDir: string;
  var
    FullTemplatesDir, AllowedFileDirsForServer, AllowedFileExtensionsForServer: string;
    FullTemplatesDirPtr, AllowedFileDirsForServerPtr, AllowedFileExtensionsForServerPtr: Pointer;
  begin
    SetLength(FullTemplatesDir, CMaxSharedStringLength + 1);
    SetLength(AllowedFileDirsForServer, CMaxSharedStringLength + 1);
    SetLength(AllowedFileExtensionsForServer, CMaxSharedStringLength + 1);

    FullTemplatesDirPtr := @FullTemplatesDir[1];
    AllowedFileDirsForServerPtr := @AllowedFileDirsForServer[1];
    AllowedFileExtensionsForServerPtr := @AllowedFileExtensionsForServer[1];

    AOnActionPlugin_GetAllowedFilesInfo(APluginReference, FullTemplatesDirPtr, AllowedFileDirsForServerPtr, AllowedFileExtensionsForServerPtr);
    FullTemplatesDir := Copy(FullTemplatesDir, 1, Pos(#0, FullTemplatesDir) - 1);
    Result := FullTemplatesDir;
  end;


  function ResolveTemplatePath(APath: string): string;
  begin
    if (Pos('$TemplateDir$', APath) = 0) and
       (Pos('$SelfTemplateDir$', APath) = 0)and
       (Pos('$AppDir$', APath) = 0) then
    begin
      Result := APath;
      Exit;
    end;

    Result := StringReplace(APath, '$TemplateDir$', GetFullTemplatesDir, [rfReplaceAll]);
    Result := StringReplace(Result, '$SelfTemplateDir$', '<$SelfTemplateDir$ replacement is not supported in plugins.>', [rfReplaceAll]);
    Result := StringReplace(Result, '$AppDir$', ExtractFileDir(ParamStr(0)), [rfReplaceAll]);
  end;


  //procedure RemoveDuplicatesFromTStringList(AListOfStr: TStringList);
  //var
  //  i, j: Integer;
  //  s: string;
  //begin
  //  for i := AListOfStr.Count - 1 downto 0 do
  //  begin
  //    s := AListOfStr.Strings[i]; //use a temp var, because the item will be deleted
  //    for j := AListOfStr.Count - 1 downto 0 do
  //      if j <> i then
  //        if AListOfStr.Strings[j] = s then
  //          AListOfStr.Delete(j);
  //  end;
  //end;


  procedure AddBitmapsToWorkerArchives(AListOfAllVars: TStringList);
  const
    CFileExistsInArchiveErr = 'Another file with the exact same name is already in archive.';
  var
    i, j, k: Integer;
    TempFilesToSend: TStringList;
    TempMemFile, UsedBmpTempMemFile: TMemoryStream;
    FileLoc: TImageSourceFileNameLocation;
    PmtvIni: TClkIniFile;
    BmpsInPmtv: TStringList;
    Fnm, BmpFnm, FnmForArchive: string;
  begin
    for i := 0 to Length(AllWorkers) - 1 do
    begin
      TempFilesToSend := TStringList.Create;
      try
        TempFilesToSend.LineBreak := #13#10;
        TempFilesToSend.Text := AllWorkers[i].FilesToSend;

        //RemoveDuplicatesFromTStringList(TempFilesToSend); //not enough to be called here

        for j := 0 to TempFilesToSend.Count - 1 do
        begin
          TempMemFile := TMemoryStream.Create;
          try
            if VerbLevel < 2 then
              AddToLog('----------- Loading bitmap as stream: "' + TempFilesToSend.Strings[j] + '" and adding it to archive.');

            if Pos(CExtBmp_PrefixUpperCase, UpperCase(TempFilesToSend.Strings[j])) = 1 then
              FileLoc := isflMem
            else
              FileLoc := isflDisk;

                   //The use of ExpandFileName requires more testing.
            Fnm := ResolveTemplatePath(TempFilesToSend.Strings[j]);
            if Pos(CExtBmp_PrefixUpperCase, UpperCase(Fnm)) = 0 then //do not expand ExtMem paths
              if Pos('$APPDIR$', UpperCase(Fnm)) = 1 then //do not expand for other vars, because the path will result in double expansion, e.g. "C:\UIClicker\$TestFilesDir$\WinOnlyFonts.pmtv", where $TestFilesDir$ already contains "C:\UIClickerDistFindSubControlPlugin\Tests".
                Fnm := ExpandFileName(Fnm);

            if LoadBitmapAsStream(AListOfAllVars, Fnm, TempMemFile, FileLoc) then
            begin
              TempFilesToSend.Strings[j] := ResolveTemplatePath(TempFilesToSend.Strings[j]);

              if UpperCase(ExtractFileExt(TempFilesToSend.Strings[j])) = '.PMTV' then
              begin           //open the pmtv file and get the list of used bitmaps
                TempMemFile.Position := 0;
                PmtvIni := TClkIniFile.Create(TempMemFile);
                try
                  BmpsInPmtv := TStringList.Create;
                  try
                    BmpsInPmtv.LineBreak := #13#10;
                    GetPathsToImagesFromPrimitivesFile(PmtvIni, BmpsInPmtv);
                    for k := 0 to BmpsInPmtv.Count - 1 do
                    begin
                      UsedBmpTempMemFile := TMemoryStream.Create;
                      try
                        if VerbLevel < 2 then
                          AddToLog('----------- Loading bitmap (used by pmtv) as stream: "' + BmpsInPmtv.Strings[k] + '" and adding it to archive.');

                        if Pos(CExtBmp_PrefixUpperCase, UpperCase(BmpsInPmtv.Strings[k])) = 1 then
                          FileLoc := isflMem
                        else
                          FileLoc := isflDisk;

                        BmpFnm := ResolveTemplatePath(BmpsInPmtv.Strings[k]);
                        //The use of ExpandFileName requires more testing.
                        if Pos(CExtBmp_PrefixUpperCase, UpperCase(BmpFnm)) = 0 then //do not expand ExtMem paths
                          if Pos('$APPDIR$', UpperCase(BmpFnm)) = 1 then //do not expand for other vars, because the path will result in double expansion, e.g. "C:\UIClicker\$TestFilesDir$\Win.bmp", where $TestFilesDir$ already contains "C:\UIClickerDistFindSubControlPlugin\Tests".
                            BmpFnm := ExpandFileName(BmpFnm);

                        if LoadBitmapAsStream(AListOfAllVars, BmpFnm, UsedBmpTempMemFile, FileLoc) then
                        begin
                          BmpsInPmtv.Strings[k] := ResolveTemplatePath(BmpsInPmtv.Strings[k]);

                          if EvaluateFileNameBeforeSending then
                          begin
                            FnmForArchive := EvaluateAllReplacements(AListOfAllVars, BmpsInPmtv.Strings[k]);

                            if VerbLevel < 2 then
                              AddToLog('--------------- Adding "' + FnmForArchive + '" bitmap used by pmtv, to archive');

                            try
                              if not FileExistsInCache(AllWorkers[i].FileCacheInfo, FnmForArchive, UsedBmpTempMemFile) then
                                AllWorkers[i].Archive.AddFromStream(FnmForArchive, UsedBmpTempMemFile);
                            except
                              on E: Exception do
                                if Pos(CFileExistsInArchiveErr, E.Message) <> 1 then
                                  raise;
                            end;
                          end
                          else
                          begin
                            FnmForArchive := BmpsInPmtv.Strings[k];

                            if VerbLevel < 2 then
                              AddToLog('--------------- Adding "' + FnmForArchive + '" bitmap used by pmtv, to archive');

                            try
                              if not FileExistsInCache(AllWorkers[i].FileCacheInfo, FnmForArchive, UsedBmpTempMemFile) then
                                AllWorkers[i].Archive.AddFromStream(FnmForArchive, UsedBmpTempMemFile);
                            except
                              on E: Exception do
                                if Pos(CFileExistsInArchiveErr, E.Message) <> 1 then
                                  raise;
                            end;
                          end;

                          if VerbLevel < 2 then
                            AddToLog('--------------- Added "' + BmpsInPmtv.Strings[k] + '" bitmap used by pmtv, to archive, of ' + IntToStr(UsedBmpTempMemFile.Size) + 'bytes in size.');
                        end
                        else
                        begin
                          FnmForArchive := BmpsInPmtv.Strings[k]; //Provide a default. Anyway, the task will fail.
                          FLatestMsg := 'Error loading bitmap used by pmtv as stream: "' + BmpsInPmtv.Strings[k] + '".';
                          raise Exception.Create('----------- ' + FLatestMsg + '  Either the file is not allowed to be loaded or it doesn''t exist.');
                        end;
                      finally
                        UsedBmpTempMemFile.Free;
                      end;

                      if EvaluateFileNameBeforeSending then
                      begin
                        if VerbLevel < 2 then
                          AddToLog('--------------- Updating "' + BmpsInPmtv.Strings[k] + '" to "' + FnmForArchive + '" in pmtv.  Initial pmtv file size: ' + IntToStr(TempMemFile.Size));

                        BmpsInPmtv.Strings[k] := FnmForArchive;
                      end;
                    end;  //for k

                    if EvaluateFileNameBeforeSending then
                    begin
                      SetPathsToImagesFromPrimitivesFile(PmtvIni, BmpsInPmtv);
                      //PmtvIni.WriteString('[NewSection]', 'For debugging', 'Increased size.');
                      PmtvIni.UpdateStream; //this updates TempMemFile to the new content of PmtvIni

                      if VerbLevel < 2 then
                        AddToLog('--------------- Updated bmp file names in pmtv.  Updated pmtv file size: ' + IntToStr(TempMemFile.Size));
                    end;
                  finally
                    BmpsInPmtv.Free;
                  end;
                finally
                  PmtvIni.Free;
                end;
              end; //it's a pmtv file

              TempMemFile.Position := 0;
              if EvaluateFileNameBeforeSending then    //moved from before "UpperCase(ExtractFileExt(TempFilesToSend.Strings[j])) = '.PMTV'", because the pmtv may be modified here, to have evaluated paths to bmps
              begin
                FnmForArchive := EvaluateAllReplacements(AListOfAllVars, Fnm);

                if VerbLevel < 2 then
                  AddToLog('--------------- Adding "' + FnmForArchive + '" to archive.');

                try
                  if not FileExistsInCache(AllWorkers[i].FileCacheInfo, FnmForArchive, TempMemFile) then
                    AllWorkers[i].Archive.AddFromStream(FnmForArchive, TempMemFile);
                except
                  on E: Exception do
                    if Pos(CFileExistsInArchiveErr, E.Message) <> 1 then
                      raise;
                end;
              end
              else
              begin
                FnmForArchive := TempFilesToSend.Strings[j];

                if VerbLevel < 2 then
                  AddToLog('--------------- Adding "' + FnmForArchive + '" to archive.');

                try
                  if not FileExistsInCache(AllWorkers[i].FileCacheInfo, FnmForArchive, TempMemFile) then
                    AllWorkers[i].Archive.AddFromStream(FnmForArchive, TempMemFile);
                except
                  on E: Exception do
                    if Pos(CFileExistsInArchiveErr, E.Message) <> 1 then
                      raise;
                end;
              end;

              if VerbLevel < 2 then
                AddToLog('----------- Added "' + TempFilesToSend.Strings[j] + '" to archive, of ' + IntToStr(TempMemFile.Size) + 'bytes in size.  Resolved name: "' + Fnm + '".  Evaluated name: "' + EvaluateAllReplacements(AListOfAllVars, Fnm) + '".');
            end
            else
            begin
              FLatestMsg := 'Error loading bitmap as stream: "' + TempFilesToSend.Strings[j] + '".   Resolved name: ' + Fnm + '  Evaluated name: "' + EvaluateAllReplacements(AListOfAllVars, Fnm) + '".';
              raise Exception.Create('----------- ' + FLatestMsg + '  Either the file is not allowed to be loaded or it doesn''t exist.');
            end;
          finally
            TempMemFile.Free;
          end;
        end; //for j

        TempMemFile := TMemoryStream.Create;
        try
          TempMemFile.Write(VarsForWorkers_Names[1], Length(VarsForWorkers_Names));
          AllWorkers[i].Archive.AddFromStream(CVarsForWorkersInArchive_Names, TempMemFile);
          TempMemFile.Clear;

          TempMemFile.Write(VarsForWorkers_Values[1], Length(VarsForWorkers_Values));
          AllWorkers[i].Archive.AddFromStream(CVarsForWorkersInArchive_Values, TempMemFile);
          TempMemFile.Clear;

          TempMemFile.Write(VarsForWorkers_EvalBefore[1], Length(VarsForWorkers_EvalBefore));
          AllWorkers[i].Archive.AddFromStream(CVarsForWorkersInArchive_EvalBefore, TempMemFile);
        finally
          TempMemFile.Free;
        end;
      finally
        TempFilesToSend.Free;
      end;
    end; //for i
  end;


  procedure GetFontsUsedByPmtvs(AListOfAllVars: TStringList; var AFindSubControlOptions: TClkFindSubControlOptions; var AFontsUsedByPmtvs: TStringArray);
  var
    ListOfPmtvFiles: TStringList;
    i: Integer;
    TempMemFile: TMemoryStream;
    PmtvIni: TClkIniReadonlyFile;
    FileLoc: TImageSourceFileNameLocation;
    Fnm: string;
  begin
    ListOfPmtvFiles := TStringList.Create;
    try
      ListOfPmtvFiles.LineBreak := #13#10;
      ListOfPmtvFiles.Text := AFindSubControlOptions.MatchPrimitiveFiles;

      SetLength(AFontsUsedByPmtvs, ListOfPmtvFiles.Count);
      for i := 0 to ListOfPmtvFiles.Count - 1 do
      begin
        if Pos(CExtBmp_PrefixUpperCase, UpperCase(ListOfPmtvFiles.Strings[i])) = 1 then
          FileLoc := isflMem
        else
          FileLoc := isflDisk;

        TempMemFile := TMemoryStream.Create;
        try
          Fnm := ResolveTemplatePath(ListOfPmtvFiles.Strings[i]);
          if Pos(CExtBmp_PrefixUpperCase, UpperCase(Fnm)) = 0 then //do not expand ExtMem paths
            if Pos('$APPDIR$', UpperCase(Fnm)) = 1 then //do not expand for other vars, because the path will result in double expansion, e.g. "C:\UIClicker\$TestFilesDir$\WinOnlyFonts.pmtv", where $TestFilesDir$ already contains "C:\UIClickerDistFindSubControlPlugin\Tests".
              Fnm := ExpandFileName(Fnm);  //The use of ExpandFileName requires more testing.

          if LoadBitmapAsStream(AListOfAllVars, Fnm, TempMemFile, FileLoc) then
          begin
            TempMemFile.Position := 0;
            PmtvIni := TClkIniReadonlyFile.Create(TempMemFile);
            try
              AFontsUsedByPmtvs[i] := GetListOfFontsUsedByPrimitivesFile(PmtvIni);
            finally
              PmtvIni.Free;
            end;
          end; //LoadBitmapAsStream  - load pmtv file
        finally
          TempMemFile.Free;
        end;
      end;
    finally
      ListOfPmtvFiles.Free;
    end;
  end;


  procedure AssignTasksToWorkers(AMaxSplitActionsCount: Integer; AListOfBmps, AListOfPmtvs, AListOfAllVars: TStringList; var AFindSubControlOptions: TClkFindSubControlOptions);
  var
    i, j: Integer;
    WorkersIndex, StartIndex: Integer;
    WorkersMatchingOS: TIntArr; //each item is an index in the AllWorkers array
    WorkersMatchingFonts: TIntArr; //this is a subset of WorkersMatchingOS, based on what fonts are available on every worker
    SortedByDuplicatedFont: TIntArr;
  begin
    Randomize;

    if Length(AllWorkers) > 0 then
    begin
      if VerbLevel < 3 then
        AddToLog('Splitting work from ' + IntToStr(AMaxSplitActionsCount) + ' (max) task(s).');

      //Filter, based on RequestedTextRenderingOS.  - property at CTextRenderingOSPropertyIndex index
      SetLength(WorkersMatchingOS, 0);
      for i := 0 to Length(AllWorkers) - 1 do
        if Pos(AllWorkers[i].OS, RequestedTextRenderingOS) > 0 then    //RequestedTextRenderingOS can be 'Win', 'Lin', 'Win+Lin'.
        begin
          SetLength(WorkersMatchingOS, Length(WorkersMatchingOS) + 1);
          WorkersMatchingOS[Length(WorkersMatchingOS) - 1] := i;
        end;

      if AFindSubControlOptions.MatchCriteria.WillMatchBitmapText then
      begin
        SetLength(SortedByDuplicatedFont, Length(AFindSubControlOptions.MatchBitmapText));
        for i := 0 to Length(SortedByDuplicatedFont) - 1 do
          SortedByDuplicatedFont[i] := i;

        //The following "for i" loop uses an array of integers called SortedByDuplicatedFont, generated by sorting,
        //where each element is an index in the MatchBitmapText array, something like MatchBitmapText[SortedByDuplicatedFont[i]].
        //The first elements of this array should point to profiles, which do not exist in all workers, then the last, in all workers.

        //FindSubControlFonts := AFindSubControlOptions.MatchBitmapText;  //Already set before calling AssignTasksToWorkers.

        //Kind of ugly to set these global vars here, but it works. An object would look better, for another time.
        AllWorkersForSorting := AllWorkers;
        AddToLogCallbackForSorting := AddToLogCallback;
        FindSubControlFontsForSorting := FindSubControlFonts;
        FontsUsedByPmtvsForSorting := FontsUsedByPmtvs;
        SortByDupFonts_Txt(SortedByDuplicatedFont);

        //Filter, based on available fonts.
        for i := 0 to Length(AFindSubControlOptions.MatchBitmapText) - 1 do
        begin
          SetLength(WorkersMatchingFonts, 0);
          for j := 0 to Length(WorkersMatchingOS) - 1 do
            if FontExistsInList(AFindSubControlOptions.MatchBitmapText[SortedByDuplicatedFont[i]].FontName, AllWorkers[WorkersMatchingOS[j]].Fonts) then
            begin
              SetLength(WorkersMatchingFonts, Length(WorkersMatchingFonts) + 1);
              WorkersMatchingFonts[Length(WorkersMatchingFonts) - 1] := WorkersMatchingOS[j];
            end;

          //Here, WorkersMatchingFonts is sorted based on AllWorkers[WorkersMatchingFonts[k]].TxtCntW;  where, k goes from 0 to Length(WorkersMatchingFonts)
          SortByTxtTaskCount(WorkersMatchingFonts);

          //Allocate:
          if Length(WorkersMatchingFonts) > 0 then
          begin
            WorkersIndex := WorkersMatchingFonts[0];  //since the WorkersMatchingFonts is sorted, the first item should point to the worker with the least number of allocated tasks
            AllWorkers[WorkersIndex].WorkerSpecificTask := AllWorkers[WorkersIndex].WorkerSpecificTask + CWorkerTask_TxtPrefix + IntToStr(SortedByDuplicatedFont[i]) + '=1&';  //i is the profile index
            Inc(AllWorkers[WorkersIndex].TxtCntW);
          end;
        end;
      end;

      Sleep(33);
      Randomize;
      StartIndex := Random(Length(WorkersMatchingOS));

      if AFindSubControlOptions.MatchCriteria.WillMatchBitmapFiles then
      begin
        for i := 0 to AListOfBmps.Count - 1 do
        begin
          WorkersIndex := WorkersMatchingOS[(i + StartIndex) mod Length(WorkersMatchingOS)];  //simple load balancing
          AllWorkers[WorkersIndex].WorkerSpecificTask := AllWorkers[WorkersIndex].WorkerSpecificTask + CWorkerTask_BmpPrefix + IntToStr(i) + '=1&';
          AllWorkers[WorkersIndex].FilesToSend := AllWorkers[WorkersIndex].FilesToSend + AListOfBmps.Strings[i] + #13#10;
          AllWorkers[WorkersIndex].BmpFilesToSend := AllWorkers[WorkersIndex].BmpFilesToSend + AListOfBmps.Strings[i] + #13#10;
          Inc(AllWorkers[WorkersIndex].BmpCntW);
        end;
      end;

      //continue with the value of StartIndex, set by WillMatchBitmapFiles section above (if that's the case)
      //Pmtv tasks will also require filtering by available fonts, at least when they have to render text.
      if AFindSubControlOptions.MatchCriteria.WillMatchPrimitiveFiles then
      begin
        if VerbLevel < 2 then
          AddToLog('Loading pmtv files, to get the list of used fonts.');

        GetFontsUsedByPmtvs(AListOfAllVars, AFindSubControlOptions, FontsUsedByPmtvs);   //Every item is a #13#10-separated list of fonts. The number of items matches the number of pmtv files. Not all pmtv files use text.

        SetLength(SortedByDuplicatedFont, Length(FontsUsedByPmtvs));
        for i := 0 to Length(SortedByDuplicatedFont) - 1 do
          SortedByDuplicatedFont[i] := i;

        //FontsUsedByPmtvs is already set  (as "FindSubControlFonts := .." above)
        SortByDupFonts_Pmtv(SortedByDuplicatedFont);

        //Filter, based on available fonts.
        for i := 0 to Length(FontsUsedByPmtvs) - 1 do
        begin
          SetLength(WorkersMatchingFonts, 0);
          for j := 0 to Length(WorkersMatchingOS) - 1 do
            if MultipleFontsExistInList(FontsUsedByPmtvs[SortedByDuplicatedFont[i]], AllWorkers[WorkersMatchingOS[j]].Fonts) then   //MultipleFontsExistInList returns True if FontsUsedByPmtvs[<idx>] is ''. That means that every worker is capable of non-SetFont work.
            begin
              SetLength(WorkersMatchingFonts, Length(WorkersMatchingFonts) + 1);
              WorkersMatchingFonts[Length(WorkersMatchingFonts) - 1] := WorkersMatchingOS[j];
            end;

          //Here, WorkersMatchingFonts is sorted based on AllWorkers[WorkersMatchingFonts[k]].PmtvCntW;  where, k goes from 0 to Length(WorkersMatchingFonts)
          SortByPmtvTaskCount(WorkersMatchingFonts);

          //Allocate:
          if Length(WorkersMatchingFonts) > 0 then
          begin
            WorkersIndex := WorkersMatchingFonts[0];  //since the WorkersMatchingFonts is sorted, the first item should point to the worker with the least number of allocated tasks
            AllWorkers[WorkersIndex].WorkerSpecificTask := AllWorkers[WorkersIndex].WorkerSpecificTask + CWorkerTask_PmtvPrefix + IntToStr(SortedByDuplicatedFont[i]) + '=1&';  //i is the pmtv index
            AllWorkers[WorkersIndex].FilesToSend := AllWorkers[WorkersIndex].FilesToSend + AListOfPmtvs.Strings[i] + #13#10;   //AListOfPmtvs has the same length as FontsUsedByPmtvs
            AllWorkers[WorkersIndex].PmtvFilesToSend := AllWorkers[WorkersIndex].PmtvFilesToSend + AListOfPmtvs.Strings[i] + #13#10;
            Inc(AllWorkers[WorkersIndex].PmtvCntW);
          end;
        end;
      end;  //WillMatchPrimitiveFiles

      if VerbLevel < 3 then
      begin
        AddToLog('Worker allocation on ' + IntToStr(Length(AllWorkers)) + ' available worker(s):');
        for i := 0 to Length(AllWorkers) - 1 do
        begin
          AllWorkers[i].WorkerSpecificTask := 'TxtCnt' + '=' + IntToStr(AllWorkers[i].TxtCntW) + '&' +
                                              'BmpCnt' + '=' + IntToStr(AllWorkers[i].BmpCntW) + '&' +
                                              'PmtvCnt' + '=' + IntToStr(AllWorkers[i].PmtvCntW) + '&' +
                                              AllWorkers[i].WorkerSpecificTask;
          AddToLog('  Worker[' + IntToStr(i) + '] = ' + AllWorkers[i].WorkerSpecificTask + '  Files to send: ' + FastReplace_ReturnTo45(AllWorkers[i].FilesToSend));
        end;
      end;
    end; //Length(AllWorkers) > 0
  end;

  procedure CloseWorkerArchives;
  var
    i: Integer;
  begin
    for i := 0 to Length(AllWorkers) - 1 do
    begin
      try
        //AddToLog('----------- closing archive at index ' + IntToStr(i));
        AllWorkers[i].CompressionTime := GetTickCount64;
        try
          AllWorkers[i].Archive.CloseArchive;
        finally
          AllWorkers[i].CompressionTime := GetTickCount64 - AllWorkers[i].CompressionTime;
        end;
      except
        on E: Exception do
        begin
          FLatestMsg := 'Error closing archive at index ' + IntToStr(i) + '.  Ex: ' + E.Message;
          AddToLog('----------- ' + FLatestMsg);
          Result := False;
        end;
      end;
    end;

    try
      BkCompressionTime := GetTickCount64;
      try
        BkArchive.CloseArchive;
      finally
        BkCompressionTime := GetTickCount64 - BkCompressionTime;
      end;
    except
      on E: Exception do
      begin
        FLatestMsg := 'Error closing archive with background image.  Ex: ' + E.Message;
        AddToLog('----------- ' + FLatestMsg);
        Result := False;
      end;
    end;
  end;

  function GetFindSubControlContent(AListOfAllVars: TStringList; out AHasTxtTasks: Boolean): Boolean;
  const
    CWillMatchBitmapText = 'WillMatchBitmapText'; //0..1
    //CWillMatchBitmapFiles = 'WillMatchBitmapFiles'; //0..1
    //CWillMatchPrimitiveFiles = 'WillMatchPrimitiveFiles'; //0..1
    CTxtProfilesCount_PropName = 'MatchBitmapText.Count';
    CBmpFiles_PropName = 'MatchBitmapFiles';     // #4#5 separated paths
    CPmtvFiles_PropName = 'MatchPrimitiveFiles'; // #4#5 separated paths
    CPrecisionTimeout_PropName = 'PrecisionTimeout';
    CFullBackgroundImageInResult_PropName = 'FullBackgroundImageInResult';
    CGetAllControls_PropName = 'GetAllControls';
  var
    ActionContentStr: string;
    ActionContentPtr: Pointer;
    ActionContentLen: DWord;
    i, WorkersIndex: Integer;
    ListOfFindSubControlProperties, ListOfBmps, ListOfPmtvs: TStringList;
    MaxSplitActionsCount, TxtCount: Integer;
    DecodedAction: TClkFindSubControlOptions;
    DecodingErr: string;
    ActionOptions: TClkActionOptions;
    TempBkStr: string;
    Fnm: string;
    TempArchiveHandlers: TArchiveHandlers;
    BkSize: Int64;
    BackgroundWidth, BackgroundHeight: Integer;
    CustomProfiles: TClkFindControlMatchBitmapTextDistArr;
  begin
    Result := True;

    SetLength(ActionContentStr, CMaxSharedStringLength + 1);
    ActionContentPtr := @ActionContentStr[1];
    AOnActionPlugin_GetActionContentByIndex(APluginReference, IndexOfFindSubControlActionProperty, ActionContentPtr, @ActionContentLen);
    SetLength(ActionContentStr, ActionContentLen);

    AHasTxtTasks := False;
    //AddToLog('ActionContentStr: ' + #13#10 + ActionContentStr);
    //
    ListOfFindSubControlProperties := TStringList.Create;
    try
      ListOfFindSubControlProperties.LineBreak := #13#10;
      ListOfFindSubControlProperties.Text := StringReplace(ActionContentStr, '&', #13#10, [rfReplaceAll]);
      //for i := 0 to ListOfFindSubControlProperties.Count - 1 do
      //  AddToLog('===Prop: ' + ListOfFindSubControlProperties.Strings[i]);

      if ListOfFindSubControlProperties.Values[CPrecisionTimeout_PropName] <> '1' then
      begin
        FLatestMsg := 'Error: Bad action configuration. This plugin requires that the "PrecisionTimeout" property of the configured FindSubControl action, to be set to True.';
        AddToLog(FLatestMsg);
        Result := False;
        Exit;
      end;

      GetAllControls := ListOfFindSubControlProperties.Values[CGetAllControls_PropName] = '1';

      if ListOfFindSubControlProperties.Values[CFullBackgroundImageInResult_PropName] <> '0' then
        AddToLog('Warning: The "' + CFullBackgroundImageInResult_PropName + '" property, of the configured FindSubControl action, is set to True. This will cause resulted debugging images to have full size, which will take longer to be compressed and transferred.');

      TxtCount := StrToIntDef(ListOfFindSubControlProperties.Values[CTxtProfilesCount_PropName], 0);
      MaxSplitActionsCount := TxtCount;   //updated later, if UsingCustomFontProfiles  (kind of ugly)
      AHasTxtTasks := (TxtCount > 0) and (ListOfFindSubControlProperties.Values['MatchCriteria.' + CWillMatchBitmapText] = '1'); //updated later, if UsingCustomFontProfiles

      ListOfBmps := TStringList.Create;
      ListOfPmtvs := TStringList.Create;
      TempArchiveHandlers := TArchiveHandlers.Create;

      for i := 0 to Length(AllWorkers) - 1 do
      begin
        AllWorkers[i].ArchiveStream := TMemoryStream.Create;
        AllWorkers[i].Archive := TMemArchive.Create;
        //AllWorkers[i].ResponseBitmapStream := TMemoryStream.Create;   //do not create here
      end;
      BkArchiveStream := TMemoryStream.Create;
      BkArchive := TMemArchive.Create;

      try
        ListOfBmps.LineBreak := #13#10;
        ListOfPmtvs.LineBreak := #13#10;

        ListOfBmps.Text := FastReplace_45ToReturn(ListOfFindSubControlProperties.Values[CBmpFiles_PropName]);
        MaxSplitActionsCount := Max(MaxSplitActionsCount, ListOfBmps.Count);

        ListOfPmtvs.Text := FastReplace_45ToReturn(ListOfFindSubControlProperties.Values[CPmtvFiles_PropName]);
        MaxSplitActionsCount := Max(MaxSplitActionsCount, ListOfPmtvs.Count);

        DecodingErr := SetFindSubControlActionProperties(ListOfFindSubControlProperties, nil, DecodedAction, ActionOptions);
        if DecodingErr <> '' then
        begin
          AddToLog('--- Action decoding errror: ' + DecodingErr);
          //SetLength(SplitActions, 0);
          MaxSplitActionsCount := 0; /////////////////////////////////// added later (to prevent indexing an empty SplitActions array), not sure if ok
        end
        else
          ;//SetLength(SplitActions, MaxSplitActionsCount);

        if UsingCustomFontProfiles then
        begin
          if VerbLevel < 2 then
            AddToLog('Loading custom font profiles from ' + CustomProfilesFnm);

          if Pos('MEM:', UpperCase(CustomProfilesFnm)) = 0 then
            if not FileExists(CustomProfilesFnm) then
              raise Exception.Create('File not found: ' + CustomProfilesFnm);

          LoadClkPrf(APluginReference, AOnActionPlugin_InMemFS, CustomProfilesFnm, CustomProfiles);

          if VerbLevel < 2 then
            AddToLog('Found ' + IntToStr(Length(CustomProfiles)) + ' unique custom profile group(s).');

          UpdateFindSubControlActionWithNewProfiles(DecodedAction, CustomProfiles);

          if VerbLevel < 2 then
            AddToLog('Found ' + IntToStr(Length(DecodedAction.MatchBitmapText)) + ' custom font profile(s).');

          TxtCount := Length(DecodedAction.MatchBitmapText);
          MaxSplitActionsCount := Max(MaxSplitActionsCount, TxtCount);
          AHasTxtTasks := (TxtCount > 0) and (ListOfFindSubControlProperties.Values['MatchCriteria.' + CWillMatchBitmapText] = '1');
        end;


        //The number of available workers can be less than, equal to or greater than the number of subproperties.
        //The number of some subproperties can be less than, other can be greater than.
        //If the number of all subproperty types is less than the number of workers, then the last remaining workers won't receive work.
        //Otherwise (if it's greater), then some workers will receive more work.
        //Delete from every action if the subproperty index is greater than MaxSplitActionsCount

        FindSubControlFonts := DecodedAction.MatchBitmapText;
        AssignTasksToWorkers(MaxSplitActionsCount, ListOfBmps, ListOfPmtvs, AListOfAllVars, DecodedAction);

        UsingCompression := PluginSettings.ValueFromIndex[CUseCompressionPropertyIndex] = 'True';
        if UsingCompression then
        begin
          TempArchiveHandlers.CompressionAlgorithm := TCompressionAlgorithm(Ord(PluginSettings.ValueFromIndex[CCompressionAlgorithmPropertyIndex] = CCompressionAlgorithms[caLzma]));  //default min max

          if TempArchiveHandlers.CompressionAlgorithm = caLzma then
            TempArchiveHandlers.LzmaOptions := FillInLzmaOptionsFromPluginProperties(PluginSettings);
        end;

        BackgroundWidth := -3;  //Values used for debugging. Do not change.
        BackgroundHeight := -3;

        TempArchiveHandlers.OnAddToLogNoObj := @AddToLog;
        OpenWorkerArchivesForAddingBitmaps(TempArchiveHandlers);   //creates new archive on BkArchiveStream
        try
          //for cropping, the following properties have to be read from ListOfFindSubControlProperties
          //InitialRectangle_Left
          //InitialRectangle_LeftOffset
          //Top, Right, Bottom

          if not AddBackgroundBitmapToWorkerArchives(AListOfAllVars,
                                                     ListOfFindSubControlProperties.Values['ImageSource'],
                                                     ListOfFindSubControlProperties.Values['ImageSourceFileNameLocation'],
                                                     ListOfFindSubControlProperties.Values['SourceFileName'],
                                                     BkSize,
                                                     BackgroundWidth,
                                                     BackgroundHeight) then
          begin
            FLatestMsg := 'Error loading background bitmap as stream.';
            AddToLog('----------- ' + FLatestMsg);
            Result := False;
            Exit;
          end;

          if ListOfFindSubControlProperties.Values['ImageSource'] = '0' then //screenshot
          begin
            DecodedAction.InitialRectangle.Left := '0';
            DecodedAction.InitialRectangle.Top := '0';
            DecodedAction.InitialRectangle.Right := IntToStr(BackgroundWidth);        //This fixes one problem and creates another.
            DecodedAction.InitialRectangle.Bottom := IntToStr(BackgroundHeight);      //HandleOnScreenshotByActionName , from UIClicker does extra cropping, based on InitialRectangle.<##>Offset fields.
            ActionContentStr := GetFindSubControlActionProperties(DecodedAction);     //The screenshot should not be cropped.

            if VerbLevel < 2 then
              AddToLog('Updated the search limits from the initial request, to fit the screenshot.  BackgroundWidth = ' + IntToStr(BackgroundWidth) + '  BackgroundHeight = ' + IntToStr(BackgroundHeight));
          end
          else
            if VerbLevel < 2 then
              AddToLog('Image source is "' + ListOfFindSubControlProperties.Values['ImageSource'] + '". The search limits remain as they are.');

          for WorkersIndex := 0 to Length(AllWorkers) - 1 do
          begin
            ListOfBmps.Text := AllWorkers[WorkersIndex].BmpFilesToSend;   //use only the worker-specific list
            ListOfPmtvs.Text := AllWorkers[WorkersIndex].PmtvFilesToSend; //use only the worker-specific list

            if EvaluateFileNameBeforeSending then    //Use the same property for now. If finer control is required, then create a new property.
            begin
              if VerbLevel < 2 then
                AddToLog('-------------- Evaluating bmp and pmtv paths and updating action...   ListOfBmps.Count = ' + IntToStr(ListOfBmps.Count) + '  ListOfPmtvs.Count = ' + IntToStr(ListOfPmtvs.Count));

              for i := 0 to ListOfBmps.Count - 1 do
              begin
                Fnm := ListOfBmps.Strings[i];
                Fnm := ResolveTemplatePath(Fnm);
                Fnm := EvaluateAllReplacements(AListOfAllVars, Fnm);
                if Pos(CExtBmp_PrefixUpperCase, UpperCase(Fnm)) = 0 then //do not expand ExtMem paths
                  //if Pos('$APPDIR$', UpperCase(Fnm)) = 1 then //do not expand for other vars, because the path will result in double expansion, e.g. "C:\UIClicker\$TestFilesDir$\WinOnlyFonts.pmtv", where $TestFilesDir$ already contains "C:\UIClickerDistFindSubControlPlugin\Tests".
                  begin
                    Fnm := ExpandFileName(Fnm);  //The use of ExpandFileName requires more testing.

                    if VerbLevel < 2 then
                      AddToLog('-------------- "' + ListOfBmps.Strings[i] + '" becomes "' + Fnm + '".');

                    ListOfBmps.Strings[i] := Fnm;
                  end;
              end;

              for i := 0 to ListOfPmtvs.Count - 1 do
              begin
                Fnm := ListOfPmtvs.Strings[i];
                Fnm := ResolveTemplatePath(Fnm);
                Fnm := EvaluateAllReplacements(AListOfAllVars, Fnm);
                if Pos(CExtBmp_PrefixUpperCase, UpperCase(Fnm)) = 0 then //do not expand ExtMem paths
                  //if Pos('$APPDIR$', UpperCase(Fnm)) = 1 then //do not expand for other vars, because the path will result in double expansion, e.g. "C:\UIClicker\$TestFilesDir$\WinOnlyFonts.pmtv", where $TestFilesDir$ already contains "C:\UIClickerDistFindSubControlPlugin\Tests".
                  begin
                    Fnm := ExpandFileName(Fnm);  //The use of ExpandFileName requires more testing.

                    if VerbLevel < 2 then
                      AddToLog('-------------- "' + ListOfPmtvs.Strings[i] + '" becomes "' + Fnm + '".');

                    ListOfPmtvs.Strings[i] := Fnm;
                  end;
              end;

              //update the action for every worker:
              DecodedAction.MatchBitmapFiles := ListOfBmps.Text;
              DecodedAction.MatchPrimitiveFiles := ListOfPmtvs.Text;

              AllWorkers[WorkersIndex].WorkerActionContentStr := GetFindSubControlActionProperties(DecodedAction);
            end //if EvaluateFileNameBeforeSending
            else
              AllWorkers[WorkersIndex].WorkerActionContentStr := ActionContentStr;
          end; //for WorkersIndex

          if VerbLevel < 2 then
            AddToLog('-------------- Done evaluating bmp and pmtv paths and updating action...');

          AddBitmapsToWorkerArchives(AListOfAllVars);
        finally
          CloseWorkerArchives;
        end;

        if VerbLevel < 2 then
        begin
          if UsingCompression then
          begin
            AddToLog('-----------');
            AddToLog('----------- The following ratio calculation is close to accurate, only if a single file is added to archive:');
            AddToLog('----------- Background bitmap size: ' + IntToStr(BkSize) + '  Compressed size: ' + IntToStr(BkArchiveStream.Size) + '   Ratio: ' + FloatToStr(BkSize / BkArchiveStream.Size) + '    CompressionTime: ' + FloatToStrF(BkCompressionTime / 1000, ffNumber, 15, 3) + 's.');
          end
          else
            AddToLog('----------- Not using compression. Background bitmap size: ' + IntToStr(BkSize) + '  Compressed size: ' + IntToStr(BkArchiveStream.Size));
        end;

        if Length(AllWorkers) > 0 then
        begin
          SetLength(AllWorkerBackgroundBmpStr, BkArchiveStream.Size);
          BkArchiveStream.Position := 0;
          BkArchiveStream.Read(AllWorkerBackgroundBmpStr[1], BkArchiveStream.Size);

          if BkArchiveStream.Size = 0 then
            BkArchiveStream.Write(string('1')[1], 1);  //prevent division by 0

          AllWorkerBackgroundBmpStr := CProtocolParam_UsingCompression + '=' + IntToStr(Ord(UsingCompression)) +
                             '&' + CProtocolParam_CompressionAlgorithm + '=' + CCompressionAlgorithms[TempArchiveHandlers.CompressionAlgorithm] +
                            '&' + CProtocolParam_ImageSourceRawContent + '=' + AllWorkerBackgroundBmpStr;

          for i := 0 to Length(AllWorkers) - 1 do
          begin
            SetLength(TempBkStr, AllWorkers[i].ArchiveStream.Size);
            AllWorkers[i].ArchiveStream.Position := 0;
            AllWorkers[i].ArchiveStream.Read(TempBkStr[1], AllWorkers[i].ArchiveStream.Size);

            if AllWorkers[i].ArchiveStream.Size = 0 then
              AllWorkers[i].ArchiveStream.Write(string('1')[1], 1);  //prevent division by 0

            AllWorkers[i].WorkerActionContentStr := AllWorkers[i].WorkerActionContentStr + //ActionContentStr +  //initialized above, with worker-specific action (list of bmps and list of pmtvs)
                                '&' + CPropertyName_ActionTimeout + '=' + IntToStr(Max(CMinFindSubControlActionTimeout, FindSubControlWorkerTimeout - FindSubControlTimeoutDiff)) +
                                '&' + AllWorkers[i].WorkerSpecificTask +
                                {'&' +} CProtocolParam_UsingCompression + '=' + IntToStr(Ord(UsingCompression)) +
                                '&' + CProtocolParam_CompressionAlgorithm + '=' + CCompressionAlgorithms[TempArchiveHandlers.CompressionAlgorithm] +
                                '&' + CProtocolParam_ImageSourceRawContent + '=' + TempBkStr;  //it is possible that the MQTT server won't allow big files to be sent in one piece
          end;

          if FindSubControlWorkerTimeout - FindSubControlTimeoutDiff < 100 then
          begin
            AddToLog('++++++++++++++++++++++++++++ ActionTimeout = ' + IntToStr(FindSubControlWorkerTimeout) + ' - ' + IntToStr(FindSubControlTimeoutDiff) + ' = ' + IntToStr(FindSubControlWorkerTimeout - FindSubControlTimeoutDiff) + 'ms is too low and will be constrained to ' + IntToStr(CMinFindSubControlActionTimeout) + 'ms.');
            AddToLog('++++++++++++++++++++++++++++ If the action fails, please increase the difference.');
          end
          else
            AddToLog('----------- Action timeout set to ' + IntToStr(FindSubControlWorkerTimeout - FindSubControlTimeoutDiff) + 'ms.');
        end  //if Length(AllWorkers) > 0 then
        else
        begin
          FLatestMsg := 'No workers available. (A worker application might still be running, but it may be busy.)';
          AddToLog('----------- ' + DateTimeToStr(Now) + ' (' + IntToStr(GetTickCount64) + ')  ' + FLatestMsg);
          Result := False;
        end;
      finally
        ListOfBmps.Free;
        ListOfPmtvs.Free;
        TempArchiveHandlers.Free;

        for i := 0 to Length(AllWorkers) - 1 do
        begin
          FreeAndNil(AllWorkers[i].ArchiveStream);
          FreeAndNil(AllWorkers[i].Archive);
          //FreeAndNil(AllWorkers[i].ResponseBitmapStream); //do not destroy here
        end;

        FreeAndNil(BkArchiveStream);
        FreeAndNil(BkArchive);
      end;
    finally
      ListOfFindSubControlProperties.Free;

      if VerbLevel < 2 then
        AddToLog('----------- Exiting GetFindSubControlContent with ' + BoolToStr(Result, 'True', 'False') + '.');
    end;
  end;  //GetFindSubControlContent

var
  i: Integer;
  TempResponseVars: TResponseVars;
  ListOfAllVars: TStringList;
  ResultImageAvailable: Boolean;
  FoundMatchingOS, HasTxtTasks: Boolean;
begin
  Result := False;
  //DebugPoint := @DbgPoint;
  SetLength(AllWorkers, 0);
  FLatestMsg := 'Error message not set.';
  SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, '');
  WorkerCapabilitiesSource := CReqCapOperation_wcsReqCapAndGetFonts; //Init here, in case an Exit is called later.
  GetCapabilitiesRequestID := 'NotSet';
  SendBackgroundToAllRequestID := 'NotSet';
  WorkerRespondedCountBG := 0;
  WorkerRespondedCountFS := 0;

  Randomize;
  RequestIDCnt := Random(MaxInt);
  VerbLevel := 2;

  try
    IdTCPClient1 := TIdTCPClient.Create;
    RecTh := nil;
    FRecBufFIFO := TPollingFIFO.Create;
    TempPluginMQTTClientHandlers := TPluginMQTTClientHandlers.Create(nil);
    PluginSettings := TStringList.Create;
    ListOfAllVars := TStringList.Create;
    try
      PluginSettings.LineBreak := #13#10;
      ListOfAllVars.LineBreak := #13#10;
      DefaultOnActionPlugin_DebugPoint := AOnActionPlugin_DebugPoint;
      DefaultPluginReference := APluginReference;
      AddToLogCallback := AOnActionPlugin_AddToLog;
      ActionPlugin_InMemFSCallback := AOnActionPlugin_InMemFS;
      ActionPlugin_ExecuteActionCallback := AOnActionPlugin_ExecuteAction;
      ActionPlugin_AppProcMsgCallback := AOnActionPlugin_AppProcMsg;
      GPluginReference := APluginReference;

      if FLatestMsg <> '' then
        FLatestMsg := FLatestMsg + ' +++ Error: This plugin hasn''t been unloaded successfully on previous execution.';

      FLatestMsg := FLatestMsg + ' /// Starting plugin...';
      AddToLog(FLatestMsg);
      FLatestMsg := '';

      IdTCPClient1.OnConnected := TempPluginMQTTClientHandlers.HandleClientOnConnected;
      IdTCPClient1.OnDisconnected := TempPluginMQTTClientHandlers.HandleClientOnDisconnected;

      if not DbgPoint('Entering ExecutePlugin', '') then     //see ClkDbgSym.ppr for expected statement formats
        Exit;

      ActionCount := AOnActionPlugin_GetActionCount(APluginReference);
      if ActionCount = 0 then
      begin
        FLatestMsg := 'This plugin does not run on an empty template.';
        SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, FLatestMsg);
        Exit;
      end;

      PluginSettingsStr := GetPluginSettings;
      PluginSettings.Text := PluginSettingsStr;

      if PluginSettings.Count <> CPropertiesCount then
      begin
        FLatestMsg := 'Cannot get the list of plugin properties.';
        SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, FLatestMsg);
        Exit;
      end;

      GetAllTemplateVars(AllVarsStr);
      GetPluginSettingsFromProperties(PluginSettings, AllVarsStr);
      ListOfAllVars.Text := AllVarsStr;

      s := 'unset action';
      IndexOfFindSubControlActionProperty := -1;
      for i := 0 to ActionCount - 1 do
      begin
        GetActionInfoByIndex(i, s, ActionTypeDWord);

        if VerbLevel < 2 then
          AddToLog('Found action [' + IntToStr(i) + ']: ' + s);

        if ActionTypeDWord <> $FFFFFFFF then
        begin
          ActionType := TClkAction(ActionTypeDWord);

          if ActionType in [acFindSubControl, acPlugin] then
            if s = PluginSettings.ValueFromIndex[CFindSubControlActionPropertyIndex] then   //the current action name ([i]) matches FindSubControl property
            begin
              IndexOfFindSubControlActionProperty := i;
              Break;
            end;
        end;
      end;

      if IndexOfFindSubControlActionProperty = -1 then
      begin
        FLatestMsg := 'FindSubControl action not configured.';
        AddToLog(FLatestMsg);
        SetTemplateVar('$ExecAction_Err$', FLatestMsg); //probably this var will be used for other type of errors.
        SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, FLatestMsg);
        Exit;
      end;

      WorkerQoS := StrToIntDef(PluginSettings.ValueFromIndex[CWorkerQoSPropertyIndex], 2);
      WorkerQoS := Min(Max(WorkerQoS, 1), 2);  //limited to 1..2

      GetWorkerCapabilitiesTimeout := StrToIntDef(PluginSettings.ValueFromIndex[CGetWorkerCapabilitiesTimeoutPropertyIndex], 2);
      GetWorkerCapabilitiesTimeout := Min(Max(GetWorkerCapabilitiesTimeout, 50), 60000);  //limited to 50..60000

      FindSubControlWorkerTimeout := StrToIntDef(PluginSettings.ValueFromIndex[CFindSubControlWorkerTimeoutPropertyIndex], 2);
      FindSubControlWorkerTimeout := Min(Max(FindSubControlWorkerTimeout, 50), 60000);  //limited to 50..60000

      FindSubControlTimeoutDiff := StrToIntDef(PluginSettings.ValueFromIndex[CFindSubControlTimeoutDiffPropertyIndex], 2500);
      FindSubControlTimeoutDiff := Min(Max(FindSubControlTimeoutDiff, 1500), 60000);  //limited to 1500..60000

      WorkerCapabilitiesSource := PluginSettings.ValueFromIndex[CWorkerCapabilitiesSourcePropertyIndex];
      UpdateCacheActionName := PluginSettings.ValueFromIndex[CSaveWorkerCapabilitiesCacheActionPropertyIndex];
      LoadCacheActionName := PluginSettings.ValueFromIndex[CLoadWorkerCapabilitiesCacheActionPropertyIndex];
      RequestedTextRenderingOS := PluginSettings.ValueFromIndex[CTextRenderingOSPropertyIndex];
      DisplayExtraDebuggingInfo := PluginSettings.ValueFromIndex[CExtraDebuggingInfoPropertyIndex] = 'True';
      EvaluateFileNameBeforeSending := PluginSettings.ValueFromIndex[CEvaluateFileNameBeforeSendingPropertyIndex] = 'True';
      UsingCustomFontProfiles := PluginSettings.ValueFromIndex[CUseFontProfilesPropertyIndex] = CUseFontProfiles_FromCustom;
      CustomProfilesFnm := PluginSettings.ValueFromIndex[CCustomFontProfilesPropertyIndex];

      MinExpectedWorkerCount := StrToIntDef(PluginSettings.ValueFromIndex[CMinExpectedWorkerCountPropertyIndex], 4);
      MinExpectedWorkerCount := Min(Max(FindSubControlTimeoutDiff, 1), 50);  //limited to 1..50

      if VerbLevel < 2 then
        AddToLog('WorkerCapabilitiesSource: ' + WorkerCapabilitiesSource);

      MQTT_Init;
      FSMError := '';
      State := SInit;

      if MQTT_CreateClient then
      begin
        try
          InitHandlers;

          repeat
            ExecFSM;

            if State = SGetFindSubControlActionContent then
            begin
              try
                if not GetFindSubControlContent(ListOfAllVars, HasTxtTasks) then
                begin
                  AddToLog('Stopping FSM, because GetFindSubControlContent returned False.');
                  FSMDone := True;
                end;
              except
                on EFSM: Exception do
                begin
                  FSMError := FSMError + 'Stopping FSM, because GetFindSubControlContent raised an exception: ' + EFSM.Message;
                  AddToLog(FSMError);
                  FSMDone := True;
                end;
              end;
            end;

            try
              AppProcMsg;
            except
              on E: Exception do
                AddToLog('-----------  Ex on FSM loop: ' + E.Message);
            end;

            if AOnActionPlugin_CheckStopAllActionsOnDemand(APluginReference) then
            begin
              FLatestMsg := 'Stopping plugin on demand...';
              AddToLog(FLatestMsg);
              Result := False;
              Exit;
            end;

            Sleep(1);
          until FSMDone;

          if VerbLevel < 2 then
            AddToLog('-----------  Exiting FSM');
        finally
          if VerbLevel < 2 then
            AddToLog('Last FSM state: ' + CFSMStr[State]);

          MQTT_DestroyClient(0);

          if VerbLevel < 2 then
            AddToLog('Client module destroyed successfully...');
        end;
      end
      else
      begin
        AddToLog('Can''t create client...');
        Result := False;
        Exit;
      end;

      TempPluginMQTTClientHandlers.tmrProcessRecData.Enabled := False;

      if VerbLevel < 2 then
        AddToLog('Stopped MQTT timer...');

      Result := DisconnectedSuccessfully;

      if FSMError <> '' then
      begin
        Result := False;
        FLatestMsg := FSMError;
      end;
    finally
      try
        AppProcMsg; //process last logging data

        //ToDo: set these vars only when their values are known

        if (WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndGetFonts) or
           (WorkerCapabilitiesSource = CReqCapOperation_wcsReqCapAndGetFontsAndFindSubControl) then
        begin
          SetTemplateVar('$WorkerCount$', IntToStr(Length(AllWorkers)));
          for i := 0 to Length(AllWorkers) - 1 do
          begin
            SetTemplateVar('$Worker[' + IntToStr(i) + '].Name$', AllWorkers[i].Name);
            SetTemplateVar('$Worker[' + IntToStr(i) + '].OS$', AllWorkers[i].OS);
            SetTemplateVar('$Worker[' + IntToStr(i) + '].Fonts$', AllWorkers[i].Fonts);  //it is possible that on a subsequent run, the workers come up in a different order, so this info will be outdated
            SetTemplateVar('$Worker[' + IntToStr(i) + '].ExtraName$', AllWorkers[i].ExtraName);

            if DisplayExtraDebuggingInfo then
            begin
              SetTemplateVar('$Worker[' + IntToStr(i) + '].WorkerSpecificTask$', AllWorkers[i].WorkerSpecificTask);
            end;
          end;
        end;

        if not Result then
        begin
          if FLatestMsg = CNoWorkerFoundSubControlErr + ' ResponseCount = ' + IntToStr(Length(AllWorkers)) + ' / ' + IntToStr(Length(AllWorkers)) + '.' then
          begin
            FoundMatchingOS := False;
            for i := 0 to Length(AllWorkers) - 1 do
              if Pos(AllWorkers[i].OS, RequestedTextRenderingOS) > 0 then    //RequestedTextRenderingOS can be 'Win', 'Lin', 'Win+Lin'.
              begin
                FoundMatchingOS := True;
                Break;
              end;

            if not FoundMatchingOS and HasTxtTasks then //no matching OS, but there are txt tasks
              FLatestMsg := CNoWorkerMatchesOSErr;
          end;

          SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, FLatestMsg);
        end
        else
        begin
          for i := 0 to Length(AllWorkers) - 1 do
            if AllWorkers[i].FindSubControlFound then
            begin
              SetTemplateVar('$Control_Left$', AllWorkers[i].ResponseVars.ControlLeft);
              SetTemplateVar('$Control_Top$', AllWorkers[i].ResponseVars.ControlTop);
              SetTemplateVar('$Control_Right$', AllWorkers[i].ResponseVars.ControlRight);
              SetTemplateVar('$Control_Bottom$', AllWorkers[i].ResponseVars.ControlBottom);

              SetTemplateVar('$Control_Width$', AllWorkers[i].ResponseVars.ControlWidth);
              SetTemplateVar('$Control_Height$', AllWorkers[i].ResponseVars.ControlHeight);
              SetTemplateVar('$Half_Control_Width$', AllWorkers[i].ResponseVars.HalfControlWidth);
              SetTemplateVar('$Half_Control_Height$', AllWorkers[i].ResponseVars.HalfControlHeight);

              SetTemplateVar('$DebugVar_SubCnvXOffset$', AllWorkers[i].ResponseVars.SubCnvXOffset);
              SetTemplateVar('$DebugVar_SubCnvYOffset$', AllWorkers[i].ResponseVars.SubCnvYOffset);

              if GetAllControls then
              begin
                TempResponseVars.AllControl_Handles := TempResponseVars.AllControl_Handles + AllWorkers[i].ResponseVars.AllControl_Handles;
                TempResponseVars.AllControl_XOffsets := TempResponseVars.AllControl_XOffsets + AllWorkers[i].ResponseVars.AllControl_XOffsets;
                TempResponseVars.AllControl_YOffsets := TempResponseVars.AllControl_YOffsets + AllWorkers[i].ResponseVars.AllControl_YOffsets;

                //ToDo: somehow, fix the index of each AllControl_MatchSource array item, for MatchSource and DetailedMatchSource, to be [0], [1], [2]...
                //This has to match text/bmp/pmtv profile index
                TempResponseVars.AllControl_MatchSource := TempResponseVars.AllControl_MatchSource + AllWorkers[i].ResponseVars.AllControl_MatchSource;
                TempResponseVars.AllControl_DetailedMatchSource := TempResponseVars.AllControl_DetailedMatchSource + AllWorkers[i].ResponseVars.AllControl_DetailedMatchSource;
                TempResponseVars.AllControl_ResultedErrorCount := TempResponseVars.AllControl_ResultedErrorCount + AllWorkers[i].ResponseVars.AllControl_ResultedErrorCount;

                TempResponseVars.AllControl_Lefts := TempResponseVars.AllControl_Lefts + AllWorkers[i].ResponseVars.AllControl_Lefts;
                TempResponseVars.AllControl_Tops := TempResponseVars.AllControl_Tops + AllWorkers[i].ResponseVars.AllControl_Tops;
                TempResponseVars.AllControl_Rights := TempResponseVars.AllControl_Rights + AllWorkers[i].ResponseVars.AllControl_Rights;
                TempResponseVars.AllControl_Bottoms := TempResponseVars.AllControl_Bottoms + AllWorkers[i].ResponseVars.AllControl_Bottoms;

                TempResponseVars.AllControl_Widths := TempResponseVars.AllControl_Widths + AllWorkers[i].ResponseVars.AllControl_Widths;
                TempResponseVars.AllControl_Heights := TempResponseVars.AllControl_Heights + AllWorkers[i].ResponseVars.AllControl_Heights;
                TempResponseVars.AllHalfControl_Widths := TempResponseVars.AllHalfControl_Widths + AllWorkers[i].ResponseVars.AllHalfControl_Widths;
                TempResponseVars.AllHalfControl_Heights := TempResponseVars.AllHalfControl_Heights + AllWorkers[i].ResponseVars.AllHalfControl_Heights;
              end;
            end;

          if GetAllControls then
          begin
            SetTemplateVar('$AllControl_Handles$', TempResponseVars.AllControl_Handles);
            SetTemplateVar('$AllControl_XOffsets$', TempResponseVars.AllControl_XOffsets);
            SetTemplateVar('$AllControl_YOffsets$', TempResponseVars.AllControl_YOffsets);

            //ToDo: somehow, fix the index of each AllControl_MatchSource array item, for MatchSource and DetailedMatchSource, to be [0], [1], [2]...
            //This has to match text/bmp/pmtv profile index
            SetTemplateVar('$AllControl_MatchSource$', TempResponseVars.AllControl_MatchSource);
            SetTemplateVar('$AllControl_DetailedMatchSource$', TempResponseVars.AllControl_DetailedMatchSource);
            SetTemplateVar('$AllControl_ResultedErrorCount$', TempResponseVars.AllControl_ResultedErrorCount);

            SetTemplateVar('$AllControl_Lefts$', TempResponseVars.AllControl_Lefts);
            SetTemplateVar('$AllControl_Tops$', TempResponseVars.AllControl_Tops);
            SetTemplateVar('$AllControl_Rights$', TempResponseVars.AllControl_Rights);
            SetTemplateVar('$AllControl_Bottoms$', TempResponseVars.AllControl_Bottoms);

            SetTemplateVar('$AllControl_Widths$', TempResponseVars.AllControl_Widths);
            SetTemplateVar('$AllControl_Heights$', TempResponseVars.AllControl_Heights);
            SetTemplateVar('$AllHalf_Control_Widths$', TempResponseVars.AllHalfControl_Widths);
            SetTemplateVar('$AllHalf_Control_Heights$', TempResponseVars.AllHalfControl_Heights);
          end;
        end;
      except
      end;

      FreeAndNil(IdTCPClient1);
      FreeAndNil(FRecBufFIFO);
      FreeAndNil(TempPluginMQTTClientHandlers);
      FreeAndNil(PluginSettings);

      if Length(AllWorkers) = 0 then
      begin
        GenerateSomeResultImg(ListOfAllVars);
        AddToLog('No available workers for result image.');
      end
      else
      begin
        ResultImageAvailable := False;
        for i := 0 to Length(AllWorkers) - 1 do
          if AllWorkers[i].ResponseBitmapStream.Size > 0 then
          begin
            ResultImageAvailable := True;
            Break;
          end;

        if ResultImageAvailable then
        begin
          if Result then
          begin
            for i := 0 to Length(AllWorkers) - 1 do
              if AllWorkers[i].FindSubControlFound then
              begin
                AOnActionPlugin_SetResultImg(APluginReference, i, 0, 0, AllWorkers[i].ResponseBitmapStream.Memory, AllWorkers[i].ResponseBitmapStream.Size, -1, -1);

                if VerbLevel < 2 then
                  AddToLog('Result image set from worker[' + IntToStr(i) + '].');

                Break;
              end;
          end
          else
          begin
            for i := 0 to Length(AllWorkers) - 1 do
              if (AllWorkers[i].WorkerSpecificTask <> '') and
                 (AllWorkers[i].WorkerSpecificTask <> 'TxtCnt=0&BmpCnt=0&PmtvCnt=0&') then  //Find a worker which received something to work on.
              begin
                AOnActionPlugin_SetResultImg(APluginReference, i, 0, 0, AllWorkers[i].ResponseBitmapStream.Memory, AllWorkers[i].ResponseBitmapStream.Size, -1, -1);

                if VerbLevel < 2 then
                  AddToLog('Result image set from worker[' + IntToStr(i) + '].');

                Break;
              end;
          end;
        end;

        if not ResultImageAvailable then
        begin
          GenerateSomeResultImg(ListOfAllVars);
          AddToLog('None of the workers returned a result image.');
        end;

        for i := 0 to Length(AllWorkers) - 1 do
          FreeAndNil(AllWorkers[i].ResponseBitmapStream);
      end;

      FreeAndNil(ListOfAllVars);

      try
        for i := 0 to Length(AllWorkers) - 1 do
          FreeAndNil(AllWorkers[i].FileCacheInfo);
      except
        on E: Exception do
          AddToLog('Cannot free FileCacheInfo at index ' + IntToStr(i));
      end;


      FLatestMsg := 'Cleaning up all worker info...';
      AddToLog(FLatestMsg);
      SetTemplateVar(CActionPlugin_DebuggingVar, FLatestMsg);
      SetLength(AllWorkers, 0);

      if RecTh <> nil then
        FreeAndNil(RecTh);
    end;

    SaveBitmapToExtRenderingInMemFS;

    FLatestMsg := 'Exiting plugin...';
    AddToLog(DateTimeToStr(Now) + ' (' + IntToStr(GetTickCount64) + ')  ' + FLatestMsg);
    SetTemplateVar(CActionPlugin_DebuggingVar, FLatestMsg);

    //AOnActionPlugin_Screenshot(APluginReference, @string('ScreenshotSettings')[1]);
  except
    on E: Exception do
      SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, 'Plugin exception: "' + E.Message + '".');
  end;
end;


function EditProperty(APluginReference: Pointer;
                      AOnActionPlugin_InMemFS: TOnActionPlugin_InMemFS;
                      AOnActionPlugin_AppProcMsg: TOnActionPlugin_AppProcMsg;
                      APropertyIndex: Integer;
                      ACurrentValue: Pointer;
                      ANewValue: Pointer;
                      ALenOfNewValue: PDWord): Boolean; cdecl;
var
  CurrentValue, NewValue: string;
begin
  ActionPlugin_AppProcMsgCallback := AOnActionPlugin_AppProcMsg;
  GPluginReference := APluginReference;
  DefaultPluginReference := APluginReference;

  VerbLevel := 2;
  SetPointedContentToString(ACurrentValue, CurrentValue);

  NewValue := CurrentValue;

  //open editor here
  Result := EditCustomFontProfilesProperty(APluginReference, AOnActionPlugin_InMemFS, APropertyIndex, CurrentValue, NewValue);
  ALenOfNewValue^ := SetPointedContentFromString(NewValue, ANewValue);
end;


exports
  GetAPIVersion,
  GetListOfProperties,
  ExecutePlugin,
  EditProperty;

begin
end.

