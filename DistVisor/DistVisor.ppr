{
    Copyright (C) 2025 VCC
    creation date: 28 Nov 2025
    initial release date: 28 Nov 2025

    author: VCC
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}


program DistVisor;

uses
  {$IFDEF UNIX}
    cthreads,
  {$ENDIF}
  Interfaces, SysUtils, Classes,
  ClickerUtils, ClickerActionsClient,
  DistPluginSender, DistVisorCommands, DistVisorFSM;


var
  FSMExecCnt: Integer;

{ToDo
- bug - If the service UIClicker is already running, but it does not contain the BrokerParams plugin, the FSM won't send its plugins.
        Probably, a similar bug exists for Dist UIClicker. The easiest fix is to autostart (from OS) the Monitoring instance, without the Service one.
- (see next task) After adding a dist machine, DistVisor should send a request to WPM, to add that machine to list. It should be paired to an mkWorker machine (same pool).
  This means that DistVisor should also keep track of pools of credentials, if implemented.
- Createa queue of operations, which allows setting pool credentials, via WPM, or other operation, which requires two machines (from the same pair), to be present.
  In case one of the machine is not yet created, or it is still booting up, the FSM should put the operation in queue and move on.
  It is also possible that the app/tool, which actually creates the machines, cannot wait for these machines to properly boot up and then send the request to DistVisor.
- WPM must close the workers + UIClickers when removing a machine.
- WPM must allow setting the required number of workers when adding a machine. The default is set from UI.
- Create a queue of error messages, that the caller app/tool can read via the HTTP API.
  It is required, because an HTTP request will not wait for the FSM to complete the action, which may result in an error.
  If the request contains a request ID, then this request ID should be part of the error message, so it can be identified later.
  Once the queue of error is read by the caller app/tool, it should be flushed from memory.
- A new scenario has to be tested: reusing the worker machine from one user to another, i.e. from one paired mkDist to another mkDist machine.
  This requires the AddMachine procedure to be able to do a similar pairing when called for an mkDist machine and be called.
  Another requirement would be to have a SPairWithWorker state, similar to the SPairWithDist state, which also calls SendPairingRequestToWPM.
- Since there are two separate requests to WPM, to remove a machine, the first one should be the Dist machine, then the worker machine.
  For now, nothing bad happens if removed in a different order, other than displaying the error message of CDistMachineNotFound.
[in work] - Implement a GetMachineStatus command in the HTTP API, which can verify if all the tools are properly running, because the AddMachine request does not wait.
  It may return different response details, based on a verbosity param.
  [done] - In case of an mkWorker machine, the command should allow asking WPM about the status of the actual workers.
}

begin
  GeneralConnectTimeout := 1500;   //expected to connect to local machines only

  SetKeys;

  WriteLn('Now waiting for HTTP commands..');
  WriteLn('Press Ctrl-C to close.');

  CreateServerModule;
  try
    FSMExecCnt := 0;
    repeat
      Inc(FSMExecCnt);

      if FSMExecCnt >= 30 then  //This constant depends on the below sleep value.
      begin                     //A 3s period allows running the FSM in the same waiting state, three times, before hitting the 10s waiting timeout.
        FSMExecCnt := 0;
        //WriteLn('FSM: ' + CDistVisorFSMStr[State]);
        ExecuteFSM;
      end;

      Sleep(100);  // a value, greater than 33, because of poor resolution
    until False;
  finally
    DestroyServerModule;
  end;
end.

